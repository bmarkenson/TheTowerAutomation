import subprocess
import time
import threading
from pynput import mouse
import re

def get_android_override_size():
    output = subprocess.check_output(['adb', 'shell', 'wm', 'size']).decode()
    for line in output.strip().splitlines():
        if line.startswith("Override size:"):
            _, override = line.split(":", 1)
            return tuple(map(int, override.strip().split("x")))
        elif line.startswith("Physical size:"):
            _, physical = line.split(":", 1)
            fallback = tuple(map(int, physical.strip().split("x")))
    return fallback

def get_android_screen_size():
    """Get the actual override screen size reported by adb shell wm size."""
    output = subprocess.check_output(['adb', 'shell', 'wm', 'size']).decode()
    override_match = re.search(r'Override size:\s*(\d+)x(\d+)', output)
    if override_match:
        width, height = map(int, override_match.groups())
        print(f"[DEBUG] Android override size: {width}x{height}")
        return (width, height)
    
    # Fall back to physical size
    physical_match = re.search(r'Physical size:\s*(\d+)x(\d+)', output)
    if physical_match:
        width, height = map(int, physical_match.groups())
        print(f"[DEBUG] Android physical size (fallback): {width}x{height}")
        return (width, height)

    raise RuntimeError("Could not determine Android screen size")

def get_scrcpy_window_rect():
    output = subprocess.check_output(['xwininfo', '-root', '-tree']).decode()
    for line in output.splitlines():
        if 'scrcpy' in line.lower() or 'SM-N950U' in line:
            match = re.match(r'\s*(0x[0-9a-f]+) "(.*?)"', line)
            if match:
                window_id = match.group(1)
                break
    else:
        raise RuntimeError("scrcpy window not found")

    # Query window geometry using its ID
    output = subprocess.check_output(['xwininfo', '-id', window_id]).decode()
    x = int(re.search(r"Absolute upper-left X:\s+(\d+)", output).group(1))
    y = int(re.search(r"Absolute upper-left Y:\s+(\d+)", output).group(1))
    width = int(re.search(r"Width:\s+(\d+)", output).group(1))
    height = int(re.search(r"Height:\s+(\d+)", output).group(1))

    return (x, y, width, height)

def map_to_android(x, y, window_rect, android_size):
    win_left, win_top, win_width, win_height = window_rect
    android_w, android_h = android_size

    # Compute Android and window aspect ratios
    android_aspect = android_w / android_h
    window_aspect = win_width / win_height

    # Determine scale factor and letterboxing
    if window_aspect > android_aspect:
        # Window is wider: black bars on left/right
        scale = win_height / android_h
        effective_width = android_w * scale
        margin_x = (win_width - effective_width) / 2
        rel_x = (x - win_left - margin_x) / effective_width
        rel_y = (y - win_top) / win_height
    else:
        # Window is taller: black bars on top/bottom
        scale = win_width / android_w
        effective_height = android_h * scale
        margin_y = (win_height - effective_height) / 2
        rel_x = (x - win_left) / win_width
        rel_y = (y - win_top - margin_y) / effective_height

    # Clamp relative values
    rel_x = max(0, min(1, rel_x))
    rel_y = max(0, min(1, rel_y))

    # Map to Android coordinates
    return int(rel_x * android_w), int(rel_y * android_h)

def send_tap(x, y):
    y -= 450  # try this experimentally
    print(f"[ADB] Tapping at {x}, {y}")
    output = subprocess.check_output(["adb", "shell", "wm", "size"]).decode()
    print(f"[DEBUG] wm size: {output}")
    subprocess.run(["adb", "shell", "input", "tap", str(x), str(y)])

def send_swipe(x1, y1, x2, y2, duration_ms):
    subprocess.run([
        "adb", "shell", "input", "swipe",
        str(x1), str(y1), str(x2), str(y2), str(duration_ms)
    ])

def start_mouse_listener(window_rect, android_size):
    press_pos = None
    press_time = None

    print(f"[DEBUG] Window rect: {window_rect}")
    print(f"[DEBUG] Android size: {android_size}")

    def on_click(x, y, button, pressed):
        nonlocal press_pos, press_time
        inside = (window_rect[0] <= x <= window_rect[0] + window_rect[2] and
                  window_rect[1] <= y <= window_rect[1] + window_rect[3])
        if not inside:
            return

        if pressed:
            press_pos = (x, y)
            press_time = time.time()
        else:
            release_time = time.time()
            duration = int((release_time - press_time) * 1000)

            if button == mouse.Button.left:
                print(f"[DEBUG] Raw click: {x}, {y}")
                start_x, start_y = map_to_android(*press_pos, window_rect, android_size)
                end_x, end_y = map_to_android(x, y, window_rect, android_size)
                print(f"[DEBUG] Android tap/swipe: {start_x}, {start_y} -> {end_x}, {end_y}")
                if (start_x, start_y) == (end_x, end_y):
                    send_tap(start_x, start_y)
                else:
                    send_swipe(start_x, start_y, end_x, end_y, duration)

            elif button == mouse.Button.right:
                subprocess.run(["adb", "shell", "input", "keyevent", "4"])  # BACK

            elif button == mouse.Button.middle:
                subprocess.run(["adb", "shell", "input", "keyevent", "3"])  # HOME

    listener = mouse.Listener(on_click=on_click)
    listener.start()


def launch_scrcpy():
    subprocess.Popen(["scrcpy", "--no-control"])
    time.sleep(2)

def main():
    launch_scrcpy()
    android_size = get_android_screen_size()
    window_rect = get_scrcpy_window_rect()
    print(f"Scrcpy window: {window_rect}")
    print(f"Android screen: {android_size}")
    start_mouse_listener(window_rect, android_size)
    print("Listening for input... Ctrl+C to stop.")
    while True:
        time.sleep(1)

if __name__ == "__main__":
    main()


