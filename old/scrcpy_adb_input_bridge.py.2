#!/usr/bin/env python3

import subprocess
import time
import re
from pynput import mouse

def get_android_screen_size():
    output = subprocess.check_output(['adb', 'shell', 'wm', 'size']).decode()
    print(f"[DEBUG] adb wm size output:\n{output}")
    override_match = re.search(r'Override size:\s*(\d+)x(\d+)', output)
    if override_match:
        size = tuple(map(int, override_match.groups()))
        print(f"[DEBUG] Android override size: {size}")
        return size
    physical_match = re.search(r'Physical size:\s*(\d+)x(\d+)', output)
    if physical_match:
        size = tuple(map(int, physical_match.groups()))
        print(f"[DEBUG] Android physical size (fallback): {size}")
        return size
    raise RuntimeError("Could not determine Android screen size")

def get_scrcpy_window_rect():
    try:
        win_id = subprocess.check_output(['xdotool', 'search', '--name', 'scrcpy-bridge']).decode().strip().splitlines()[0]
    except subprocess.CalledProcessError:
        raise RuntimeError("Could not find scrcpy window")

    tree = subprocess.check_output(['xwininfo', '-tree', '-id', win_id]).decode()
    print(f"[DEBUG] xwininfo -tree:\n{tree}")

    # Look for child window: 'N/A' or same dimensions as screen
    child_match = re.search(r'(0x[0-9a-f]+)\s+"N/A"', tree, re.IGNORECASE)
    if child_match:
        drawable_id = "0x" + child_match.group(1)
        width = int(child_match.group(2))
        height = int(child_match.group(3))
        x = int(child_match.group(4))
        y = int(child_match.group(5))
    else:
        print("[DEBUG] No child drawable window found; falling back to top-level window")
        # Try fallback: scrape the top-level window instead
        fallback_match = re.search(r'Window id: (0x[0-9a-f]+) "scrcpy-bridge"', tree)
        if not fallback_match:
            raise RuntimeError("Could not find scrcpy window at all")
        drawable_id = fallback_match.group(1)

        # Get its geometry
        geo = subprocess.check_output(['xwininfo', '-id', drawable_id]).decode()
        x = int(re.search(r"Absolute upper-left X:\s+(\d+)", geo).group(1))
        y = int(re.search(r"Absolute upper-left Y:\s+(\d+)", geo).group(1))
        width = int(re.search(r"Width:\s+(\d+)", geo).group(1))
        height = int(re.search(r"Height:\s+(\d+)", geo).group(1))

    print(f"[DEBUG] Drawable bounds: ({x}, {y}, {width}, {height})")
    return (x, y, width, height)

def map_to_android(x, y, window_rect, android_size):
    win_x, win_y, win_w, win_h = window_rect
    android_w, android_h = android_size

    android_aspect = android_w / android_h
    window_aspect = win_w / win_h

    print(f"[DEBUG] Mouse clicked at: {x}, {y}")
    print(f"[DEBUG] Window size: {win_w}x{win_h}, Android size: {android_w}x{android_h}")
    print(f"[DEBUG] Aspect ratio: win={window_aspect:.3f}, android={android_aspect:.3f}")

    if window_aspect > android_aspect:
        scale = win_h / android_h
        effective_w = android_w * scale
        margin_x = (win_w - effective_w) / 2
        rel_x = (x - win_x - margin_x) / effective_w
        rel_y = (y - win_y) / win_h
        print(f"[DEBUG] Letterboxing L/R: scale={scale:.4f}, margin_x={margin_x:.2f}")
    else:
        scale = win_w / android_w
        effective_h = android_h * scale
        margin_y = (win_h - effective_h) / 2
        rel_x = (x - win_x) / win_w
        rel_y = (y - win_y - margin_y) / effective_h
        print(f"[DEBUG] Letterboxing T/B: scale={scale:.4f}, margin_y={margin_y:.2f}")

    rel_x_clamped = max(0, min(1, rel_x))
    rel_y_clamped = max(0, min(1, rel_y))
    print(f"[DEBUG] Relative position unclamped: ({rel_x:.3f}, {rel_y:.3f})")
    print(f"[DEBUG] Relative position clamped: ({rel_x_clamped:.3f}, {rel_y_clamped:.3f})")

    mapped_x = int(rel_x_clamped * android_w)
    mapped_y = int(rel_y_clamped * android_h)
    print(f"[DEBUG] Final Android tap: {mapped_x}, {mapped_y}")
    return mapped_x, mapped_y

def send_tap(x, y):
    print(f"[ADB] tap {x}, {y}")
    subprocess.run(["adb", "shell", "input", "tap", str(x), str(y)])

def send_swipe(x1, y1, x2, y2, duration_ms):
    print(f"[ADB] swipe {x1},{y1} -> {x2},{y2} ({duration_ms}ms)")
    subprocess.run([
        "adb", "shell", "input", "swipe",
        str(x1), str(y1), str(x2), str(y2), str(duration_ms)
    ])

def start_mouse_listener(window_rect, android_size):
    press_pos = None
    press_time = None

    def on_click(x, y, button, pressed):
        nonlocal press_pos, press_time
    
        win_x, win_y, win_w, win_h = window_rect
        inside = (win_x <= x <= win_x + win_w and win_y <= y <= win_y + win_h)
    
        if not inside:
            if pressed:
                print(f"[DEBUG] Ignoring press outside scrcpy window: {x}, {y}")
            return
    
        if pressed:
            press_pos = (x, y)
            press_time = time.time()
            print(f"[DEBUG] Mouse down at: {x}, {y}")
        else:
            release_time = time.time()
            duration = int((release_time - press_time) * 1000)
            print(f"[DEBUG] Mouse up at: {x}, {y} (duration: {duration}ms)")
    
            if button == mouse.Button.left:
                start_x, start_y = map_to_android(*press_pos, window_rect, android_size)
                end_x, end_y = map_to_android(x, y, window_rect, android_size)
                if (start_x, start_y) == (end_x, end_y):
                    send_tap(start_x, start_y)
                else:
                    send_swipe(start_x, start_y, end_x, end_y, duration)
    
            elif button == mouse.Button.right:
                print("[DEBUG] Sending BACK keyevent")
                subprocess.run(["adb", "shell", "input", "keyevent", "4"])
            elif button == mouse.Button.middle:
                print("[DEBUG] Sending HOME keyevent")
                subprocess.run(["adb", "shell", "input", "keyevent", "3"])

    listener = mouse.Listener(on_click=on_click)
    listener.start()

def launch_scrcpy():
    subprocess.Popen(["scrcpy", "--no-control", "--window-title", "scrcpy-bridge"])
    time.sleep(2)

def main():
    launch_scrcpy()
    android_size = get_android_screen_size()
    window_rect = get_scrcpy_window_rect()
    print(f"[INFO] Android screen size: {android_size}")
    print(f"[INFO] scrcpy drawable window: {window_rect}")
    start_mouse_listener(window_rect, android_size)
    print("Listening for clicks... Ctrl+C to quit.")
    while True:
        time.sleep(1)

if __name__ == "__main__":
    main()


