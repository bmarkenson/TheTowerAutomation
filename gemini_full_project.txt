----------./core/scan_upgrades.py----------------------
./core/scan_upgrades.py
#!/usr/bin/env python3
# core/scan_upgrades.py
#
# Find an upgrade label reliably, scrolling as needed,
# and return a stable ROI for the right-hand value/cost box.

import time
from typing import Optional, Tuple, Dict, List

import cv2
import numpy as np

from utils.logger import log
from core.ss_capture import capture_adb_screenshot
from core.clickmap_access import resolve_dot_path
from core.label_tapper import get_label_match, page_column  # <-- adaptive scroll

# --- Tunables -----------------------------------------------------------------

POST_SWIPE_SLEEP = 0.35

EDGE_EPSILON = 0.004

# (dx, dy, w, h) relative to label bbox top-left
COST_BOX_OFFSET = {
    "left":  (300, 20,  210, 80),   # tune once for your setup
    "right": (300, 20,  210, 80),
}

# -----------------------------------------------------------------------------


def _get_column_region(column: str) -> Tuple[int, int, int, int]:
    dot = f"_shared_match_regions.upgrades_{column}"
    entry = resolve_dot_path(dot)
    if not entry or "match_region" not in entry:
        raise RuntimeError(f"Missing shared region: {dot}")
    r = entry["match_region"]
    return int(r["x"]), int(r["y"]), int(r["w"]), int(r["h"])


def _crop(img: np.ndarray, rect: Tuple[int, int, int, int]) -> np.ndarray:
    x, y, w, h = rect
    return img[y:y+h, x:x+w].copy()


def _roi_change_ratio(a: np.ndarray, b: np.ndarray) -> float:
    if a.shape != b.shape:
        h = min(a.shape[0], b.shape[0])
        w = min(a.shape[1], b.shape[1])
        a = cv2.resize(a, (w, h))
        b = cv2.resize(b, (w, h))
    a_g = cv2.cvtColor(a, cv2.COLOR_BGR2GRAY)
    b_g = cv2.cvtColor(b, cv2.COLOR_BGR2GRAY)
    diff = cv2.absdiff(a_g, b_g)
    return float(diff.mean()) / 255.0


def _page(side: str, direction: str, settle: float = POST_SWIPE_SLEEP) -> None:
    page_column(side, direction, strength="page")
    time.sleep(settle)


def scroll_to_top(side: str = "left", max_swipes: int = 12) -> bool:
    img = capture_adb_screenshot()
    if img is None:
        raise RuntimeError("No screenshot")

    col_rect = _get_column_region(side)
    prev = _crop(img, col_rect)

    for _ in range(max_swipes):
        _page(side, "up")
        img2 = capture_adb_screenshot()
        if img2 is None:
            continue
        roi = _crop(img2, col_rect)
        change = _roi_change_ratio(prev, roi)
        if change < EDGE_EPSILON:
            return True
        prev = roi
    return False


def _resolve_upgrade_keys(side: str) -> List[str]:
    base = f"upgrades.attack.{side}"
    node = resolve_dot_path(base) or {}
    keys = []
    for k, v in (node.items() if isinstance(node, dict) else []):
        if isinstance(v, dict) and ("match_template" in v or "region_ref" in v or "match_region" in v):
            keys.append(f"{base}.{k}")
    return sorted(keys)


def find_label_or_scroll(
    label_key: str,
    side: str,
    max_pages: int = 25,
) -> Optional[Tuple[int, int, int, int]]:
    for _ in range(max_pages):
        bbox = get_label_match(label_key, screenshot=None, return_meta=False)
        if bbox:
            return bbox
        _page(side, "down")
    return None


def cost_box_from_label_bbox(label_bbox: Tuple[int, int, int, int], side: str) -> Tuple[int, int, int, int]:
    x, y, w, h = label_bbox
    dx, dy, rw, rh = COST_BOX_OFFSET[side]
    return (x + dx, y + dy, rw, rh)


def sample_cost_color(img: np.ndarray, rect: Tuple[int, int, int, int]) -> Dict[str, float]:
    roi = _crop(img, rect)
    hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
    h, s, v = [c.mean() for c in cv2.split(hsv)]
    return {"H": float(h), "S": float(s), "V": float(v)}


def main():
    side = "left"
    label_key = "upgrades.attack.left.rend_armor_chance"  # change to any known label

    ok = scroll_to_top(side)
    log(f"scroll_to_top({side}) -> {ok}", "INFO")

    bbox = find_label_or_scroll(label_key, side, max_pages=30)
    if not bbox:
        log(f"Label not found: {label_key}", "FAIL")
        return

    log(f"FOUND {label_key} at bbox={bbox}", "INFO")

    img = capture_adb_screenshot()
    cost_rect = cost_box_from_label_bbox(bbox, side)
    stats = sample_cost_color(img, cost_rect)
    log(f"Cost-box HSV mean @ {cost_rect}: {stats}", "INFO")

    viz = img.copy()
    x,y,w,h = bbox
    cv2.rectangle(viz, (x,y), (x+w, y+h), (0,255,0), 2)
    cx,cy,cw,ch = cost_rect
    cv2.rectangle(viz, (cx,cy), (cx+cw, cy+ch), (255,0,0), 2)
    cv2.imwrite("screenshots/upgrade_debug.png", viz)
    log("Wrote screenshots/upgrade_debug.png", "INFO")


if __name__ == "__main__":
    main()
----------./core/automation_state.py----------------------
./core/automation_state.py
# core/automation_state.py
"""
Thread-safe automation run/mode state.

This module exposes a small, concurrency-safe controller for the current
run-state and execution mode used by handlers/loops.

YAML-in-docstring legend (kept tiny and consistent per module)

spec_legend:
  r: Return value (shape & invariants)
  s: Side effects (project tags; state/log/fs/adb/etc.)
  e: Errors/exceptions behavior
  p: Parameters (only non-obvious notes; types are in signature)
  notes: Brief extra context that aids correct use

defaults:
  thread_safety: property access is guarded by a threading.Lock
  initial_state: RUNNING
  initial_mode: RETRY
"""

import threading
from enum import Enum
from typing import Union, Final


class RunState(str, Enum):
    """
    spec:
      name: RunState
      kind: Enum[str]
      members: [RUNNING, PAUSED, STOPPED, UNKNOWN]
      r: Concrete values are strings; equality by identity/value.
      notes:
        - Used by loops/handlers to gate activity.
    """
    RUNNING = "RUNNING"
    PAUSED = "PAUSED"
    STOPPED = "STOPPED"
    UNKNOWN = "UNKNOWN"


class ExecMode(str, Enum):
    """
    spec:
      name: ExecMode
      kind: Enum[str]
      members: [RETRY, WAIT, HOME]
      notes:
        - WAIT: pause on GAME OVER and similar screens until operator flips mode.
        - HOME: navigate/idle on home screen (not all handlers implement this yet).
        - RETRY: default auto-progression behavior.
    """
    RETRY = "RETRY"
    WAIT = "WAIT"
    HOME = "HOME"


_StateLike = Union[RunState, str]
_ModeLike = Union[ExecMode, str]


class AutomationControl:
    """
    spec:
      name: AutomationControl
      purpose: Thread-safe holder for the automation's run state and execution mode.
      constructor:
        signature: AutomationControl() -> AutomationControl
        r: New controller with state=RUNNING, mode=RETRY
        s: [state]
      attributes:
        _lock: threading.Lock (private)
        _state: RunState
        _mode: ExecMode
      notes:
        - Property setters accept Enum or str; str is coerced to the Enum and may raise.
        - Access to _state/_mode is always guarded by _lock to avoid races.
    """

    def __init__(self) -> None:
        self._lock: Final = threading.Lock()
        self._state: RunState = RunState.RUNNING
        self._mode: ExecMode = ExecMode.RETRY

    @property
    def state(self) -> RunState:
        """
        spec:
          name: AutomationControl.state (getter)
          signature: state -> RunState
          r: Current run state (Enum)
          s: [state]
          e: none
        """
        with self._lock:
            return self._state

    @state.setter
    def state(self, value: _StateLike) -> None:
        """
        spec:
          name: AutomationControl.state (setter)
          signature: state = value
          p:
            value: RunState | str  # str is coerced via RunState(value)
          r: null
          s: [state]
          e:
            - ValueError: if value is a str not in RunState
            - TypeError: if value is neither RunState nor str
        """
        # Accept Enum or str and coerce; raise on invalid
        if isinstance(value, str):
            value = RunState(value)  # may raise ValueError
        elif not isinstance(value, RunState):
            raise TypeError("state must be RunState or str")
        with self._lock:
            self._state = value

    @property
    def mode(self) -> ExecMode:
        """
        spec:
          name: AutomationControl.mode (getter)
          signature: mode -> ExecMode
          r: Current execution mode (Enum)
          s: [state]
          e: none
        """
        with self._lock:
            return self._mode

    @mode.setter
    def mode(self, value: _ModeLike) -> None:
        """
        spec:
          name: AutomationControl.mode (setter)
          signature: mode = value
          p:
            value: ExecMode | str  # str is coerced via ExecMode(value)
          r: null
          s: [state]
          e:
            - ValueError: if value is a str not in ExecMode
            - TypeError: if value is neither ExecMode nor str
        """
        if isinstance(value, str):
            value = ExecMode(value)  # may raise ValueError
        elif not isinstance(value, ExecMode):
            raise TypeError("mode must be ExecMode or str")
        with self._lock:
            self._mode = value


AUTOMATION = AutomationControl()
"""
spec:
  name: AUTOMATION
  kind: singleton
  r: Module-level AutomationControl instance for global coordination
  notes:
    - Handlers/loops read and set this.
    - Treat as process-local singleton; do not recreate per thread.
"""
----------./core/floating_button_detector.py----------------------
./core/floating_button_detector.py
# core/floating_button_detector.py
"""
Floating (overlay) button detection and tapping helpers.

AUTO-SPEC legend used in docstrings below:
  R: Return value
  S: Side effects / external systems touched (tags: [adb], [cv2], [fs], [log])
  E: Errors raised (or error semantics)

Notes:
- Template paths are relative to assets/match_templates/.
- Inputs are OpenCV images in BGR order.
- Confidence thresholds are carried by clickmap entries (default handled upstream).
"""

import os
import cv2
from utils.template_matcher import match_region
from core.clickmap_access import get_entries_by_role
from utils.logger import log
from core.adb_utils import adb_shell


def tap_floating_button(name, buttons):
    """
    Tap a previously-detected floating button by name.

    AUTO-SPEC:
      signature: core.floating_button_detector.tap_floating_button(name: str, buttons: list[dict]) -> bool
      R: bool — True if a button with matching name was tapped; False if not found.
      S: [adb][log] — Injects a tap via ADB; emits an ACTION log line.
      E: None — adb_shell handles subprocess errors internally and returns None on failure.

    Args:
        name: The `name` field of the target button in `buttons`.
        buttons: A list of button dicts as produced by `detect_floating_buttons()`
                 (each contains keys: name, match_region, confidence, tap_point{ x,y }).

    Returns:
        True if a tap was issued; False if no matching button was present.
    """
    for b in buttons:
        if b["name"] == name:
            x, y = b["tap_point"]["x"], b["tap_point"]["y"]
            log(f"TAP_FLOATING: {name} at ({x},{y})", "ACTION")
            adb_shell(["input", "tap", str(x), str(y)])
            return True
    return False


def detect_floating_buttons(screen):
    """
    Detect all configured floating buttons in the given screen image.

    AUTO-SPEC:
      signature: core.floating_button_detector.detect_floating_buttons(screen: ndarray) -> list[dict]
      R: list[dict] — Each dict has:
           {"name": str,
            "match_region": {"x": int, "y": int, "w": int, "h": int},
            "confidence": float,
            "tap_point": {"x": int, "y": int}}
         Returns an empty list if none matched.
      S: [cv2][fs][log] — Reads template images from disk; uses OpenCV for matching; logs debug/errors.
      E: Per-entry exceptions are caught and logged; function returns partial results when possible.

    Args:
        screen: BGR ndarray of the current frame.

    Returns:
        A list of detected floating button descriptors suitable for `tap_floating_button()`.

    Notes:
        - Candidates are sourced from the clickmap entries whose roles include "floating_button".
        - For each candidate, a region match is attempted via `utils.template_matcher.match_region`.
        - Missing/unreadable template files are logged and skipped; detection continues for others.
    """
    results = []
    floating_buttons = get_entries_by_role("floating_button")

    for name, entry in floating_buttons.items():
        try:
            if not entry:
                continue

            pt, conf = match_region(screen, entry)
            if pt is None:
                log(f"{name} not matched (conf={conf:.2f})", "DEBUG")
                continue

            template_path = entry["match_template"]
            template_path_full = os.path.join("assets/match_templates", template_path)

            if not os.path.exists(template_path_full):
                log(f"Template file missing: {template_path}", "ERROR")
                continue

            template = cv2.imread(template_path_full)
            if template is None:
                log(f"Template failed to load (cv2.imread returned None): {template_path}", "ERROR")
                continue

            h, w = template.shape[:2]
            x, y = pt
            results.append({
                "name": name,
                "match_region": {"x": x, "y": y, "w": w, "h": h},
                "confidence": conf,
                "tap_point": {"x": x + w // 2, "y": y + h // 2}
            })
        except Exception as e:
            log(f"Exception during processing of {name}: {e}", "ERROR")

    return results
----------./core/adb_utils.py----------------------
./core/adb_utils.py
# core/adb_utils.py
"""
Utility functions for interacting with Android devices or emulators via ADB.

This module provides:
- adb_shell(): Run arbitrary shell commands on a connected device/emulator.
- screencap_png(): Capture a raw PNG screenshot from a connected device/emulator.

Device targeting:
    Functions respect the following precedence when selecting a device:
    1. Explicit `device_id` argument
    2. Environment variable ADB_DEVICE
    3. Module constant ADB_DEVICE_ID

Dependencies:
    - Requires `adb` to be installed and on the system PATH.
    - No heavy dependencies (e.g., OpenCV) are imported here.
      PNG decoding and image handling should be done in higher-level modules
      such as core/ss_capture.py.
"""

import os
import shlex
import subprocess
from typing import List, Optional, Union

#ADB_DEVICE_ID = "07171JEC203290"  # Or ""
ADB_DEVICE_ID = "localhost:5555"

def adb_shell(
    cmd: Union[str, List[str]],
    capture_output: bool = False,
    check: bool = True,
    device_id: Optional[str] = None,
):
    """
    ---
    spec:
      r: "subprocess.CompletedProcess | None"
      s: ["adb"]
      e:
        - "Returns None on CalledProcessError or unexpected Exception (error printed)"
      params:
        cmd: "str or list[str]; string is shlex-split"
        capture_output: "bool — when True, stdout/stderr captured (text=True)"
        check: "bool — if True, non‑zero exit triggers CalledProcessError (caught)"
        device_id: "str|None — explicit device; else env ADB_DEVICE; else module ADB_DEVICE_ID"
      notes:
        - "stdout/stderr suppressed when capture_output=False"
        - "Uses 'adb -s <target> shell …'"
    ---
    Run an ADB shell command.

    Args:
        cmd: Either a list of args (preferred) or a single string (split via shlex).
        capture_output: When True, returns stdout/stderr in the CompletedProcess.
        check: When True, raises CalledProcessError internally (caught below) on non-zero exit.
        device_id: Overrides target device. Falls back to env ADB_DEVICE, then ADB_DEVICE_ID.

    Returns:
        subprocess.CompletedProcess on success.
        None on failure (errors printed).
    """
    # Normalize command
    cmd_list = shlex.split(cmd) if isinstance(cmd, str) else cmd

    # Resolve device selection (explicit > env > module default)
    target = device_id or os.getenv("ADB_DEVICE") or ADB_DEVICE_ID

    base_cmd = ["adb"]
    if target:
        base_cmd += ["-s", target]
    full_cmd = base_cmd + ["shell"] + cmd_list

    try:
        if capture_output:
            result = subprocess.run(
                full_cmd,
                check=check,
                text=True,
                capture_output=True
            )
        else:
            result = subprocess.run(
                full_cmd,
                check=check,
                text=True,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )
        return result
    except subprocess.CalledProcessError as e:
        print(f"[ERROR] ADB command failed: {e}")
        if hasattr(e, 'stderr') and e.stderr:
            print(f"[STDERR] {e.stderr.strip()}")
        return None
    except Exception as e:
        print(f"[ERROR] Unexpected ADB exception: {e}")
        return None


def screencap_png(
    device_id: Optional[str] = None,
    check: bool = True,
) -> Optional[bytes]:
    """
    ---
    spec:
      r: "bytes | None (PNG)"
      s: ["adb"]
      e:
        - "Returns None on non-zero exit or invalid/empty data; error printed"
      params:
        device_id: "str|None — explicit device; else env ADB_DEVICE; else module ADB_DEVICE_ID"
        check: "bool — if True, non‑zero exit raises CalledProcessError (caught)"
      notes:
        - "Uses 'adb exec-out screencap -p'"
    ---
    Capture a screenshot via `adb exec-out screencap -p`.

    Args:
        device_id: Overrides target device. Falls back to env ADB_DEVICE, then ADB_DEVICE_ID.
        check: When True, raises CalledProcessError internally (caught) on non-zero exit.

    Returns:
        PNG bytes on success, or None on failure.
    """
    target = device_id or os.getenv("ADB_DEVICE") or ADB_DEVICE_ID

    base_cmd = ["adb"]
    if target:
        base_cmd += ["-s", target]
    full_cmd = base_cmd + ["exec-out", "screencap", "-p"]

    try:
        result = subprocess.run(
            full_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=check,
        )
        return result.stdout
    except subprocess.CalledProcessError as e:
        # Mirror adb_shell's lightweight reporting without pulling in logger here.
        print(f"[ERROR] ADB screencap failed: {e}")
        if e.stderr:
            try:
                print(f"[STDERR] {e.stderr.decode(errors='ignore').strip()}")
            except Exception:
                pass
        return None
    except Exception as e:
        print(f"[ERROR] Unexpected ADB screencap exception: {e}")
        return None
----------./core/clickmap_access.py----------------------
./core/clickmap_access.py
import os
import json
from typing import Any, Dict, Optional, Tuple, List, Mapping
from core.adb_utils import adb_shell
from utils.logger import log

CLICKMAP_FILE = os.path.join(os.path.dirname(__file__), "../config/clickmap.json")

try:
    with open(CLICKMAP_FILE, "r", encoding="utf-8") as f:
        _clickmap: Dict[str, Any] = json.load(f)
except Exception as e:
    log(f"[ERROR] Failed to load clickmap: {e}", "FAIL")
    _clickmap = {}

_last_region_group: Optional[str] = None

def get_clickmap() -> Dict[str, Any]:
    """
    ---
    spec:
      r: "dict[str, Any] (mutable reference)"
      s: []
      e: []
      params: {}
      notes:
        - "Backed by module-global _clickmap loaded at import time"
        - "Mutations affect in-memory state; persist via save_clickmap()"
    ---
    Return the in-memory clickmap dict (mutable reference).
    """
    return _clickmap

def get_clickmap_path() -> str:
    """
    ---
    spec:
      r: "str (absolute path)"
      s: []
      e: []
      params: {}
      notes:
        - "Resolves to utils/config/clickmap.json relative to this module"
    ---
    Return absolute filesystem path to the clickmap JSON file.
    """
    return CLICKMAP_FILE

def resolve_dot_path(dot_path: str, data: Optional[Mapping[str, Any]] = None) -> Any:
    """
    ---
    spec:
      r: "Any | None"
      s: []
      e: []
      params:
        dot_path: "str — nested keys separated by '.' (colons ':' are part of keys)"
        data: "mapping | None — optional root mapping; defaults to global clickmap"
      notes:
        - "Returns None if any segment is missing or a non-dict is traversed"
    ---
    Resolve and return the value at a dot-separated path in the provided mapping
    (or the global clickmap). Return None if any segment is missing.
    """
    parts = dot_path.split(".")
    cur: Any = data or _clickmap
    for p in parts:
        if isinstance(cur, dict) and p in cur:
            cur = cur[p]
        else:
            return None
    return cur

def dot_path_exists(dot_path: str, data: Optional[Mapping[str, Any]] = None) -> bool:
    """
    ---
    spec:
      r: "bool"
      s: []
      e: []
      params:
        dot_path: "str"
        data: "mapping | None"
      notes:
        - "Thin wrapper over resolve_dot_path()"
    ---
    True if resolve_dot_path finds a non-None value; False otherwise.
    """
    return resolve_dot_path(dot_path, data) is not None

def set_dot_path(dot_path: str, value: Any, allow_overwrite: bool = False) -> None:
    """
    ---
    spec:
      r: "None"
      s: []
      e:
        - "KeyError if final key exists and allow_overwrite is False"
        - "ValueError if path traverses a non-dict element"
      params:
        dot_path: "str"
        value: "Any"
        allow_overwrite: "bool — default False"
      notes:
        - "Creates intermediate dicts as needed; does not persist to disk"
    ---
    Set value at dot-separated path in the global clickmap.
    Creates intermediate dicts as needed.
    Raises KeyError on existing final key unless allow_overwrite=True.
    Raises ValueError if path traverses a non-dict.
    """
    parts = dot_path.split(".")
    cur = _clickmap
    for p in parts[:-1]:
        if p not in cur:
            cur[p] = {}
        elif not isinstance(cur[p], dict):
            raise ValueError(f"Cannot set path through non-dict element: {p}")
        cur = cur[p]

    final_key = parts[-1]
    if final_key in cur and not allow_overwrite:
        raise KeyError(f"Key '{dot_path}' already exists. Use allow_overwrite=True to overwrite.")
    cur[final_key] = value

def _valid_group_name(name: str) -> bool:
    """
    ---
    spec:
      r: "bool"
      s: []
      e: []
      params:
        name: "str"
      notes:
        - "Internal helper used by interactive flows"
    ---
    Keep this simple and predictable:
    - start with letter or underscore
    - then letters, digits, or underscores
    """
    if not name:
        return False
    if not (name[0].isalpha() or name[0] == "_"):
        return False
    for c in name[1:]:
        if not (c.isalnum() or c == "_"):
            return False
    return True

def interactive_get_dot_path(clickmap: Dict[str, Any]) -> Optional[str]:
    """
    ---
    spec:
      r: "str | None"
      s: ["fs?", "stdio"]
      e: []
      params:
        clickmap: "dict[str, Any] — working mapping to display/update"
      notes:
        - "Interactive console UI; updates _last_region_group on selection"
        - "Special-cases 'upgrades' group for nested category/side/label"
        - "Returns dot-path string or None on cancel"
    ---
    Interactive helper to choose/create a top-level group and enter an entry key.
    Returns 'group.suffix' for generic groups, or 'upgrades.<category>.<side>.<label>' for upgrades,
    or None if the user cancels. Updates _last_region_group when selection is made. (I/O via input/print)
    """
    global _last_region_group
    top_level_keys = list(clickmap.keys())

    while True:
        print("\nAvailable groups:")
        for i, group in enumerate(top_level_keys):
            marker = " (last used)" if group == _last_region_group else ""
            print(f"  {i + 1}. {group}{marker}")
        print("  n. <create new group>")

        prompt = "[Enter]=reuse last, [n]=new group, [q]=cancel, or choose number/name: "
        choice = input(prompt).strip()

        if choice.lower() == "q":
            print("[INFO] Skipped saving.")
            return None

        # Reuse last group
        if choice == "":
            if _last_region_group:
                group = _last_region_group
                print(f"[INFO] Reusing last group: {group}")
            else:
                print("❌ No group selected yet.")
                continue

        # Create new group
        elif choice.lower() == "n":
            new_group = input("Enter new group name (letters/digits/underscore; must start with letter/_): ").strip()
            if not _valid_group_name(new_group):
                print("❌ Invalid group name.")
                continue
            if new_group in top_level_keys:
                print("ℹ️    That group already exists; selecting it.")
                group = new_group
            else:
                confirm = input(f"Create new group '{new_group}'? (Y/n): ").strip().lower()
                if confirm not in ("", "y", "yes"):
                    print("[INFO] Creation cancelled.")
                    continue
                # Create it in-memory so it appears immediately
                clickmap[new_group] = {}
                top_level_keys.append(new_group)
                group = new_group
                print(f"[INFO] Group '{group}' created.")

        # Numeric select
        elif choice.isdigit() and 1 <= int(choice) <= len(top_level_keys):
            group = top_level_keys[int(choice) - 1]

        # Name select
        elif choice in top_level_keys:
            group = choice

        else:
            print(f"❌ Invalid selection. Choose one of: {', '.join(top_level_keys)} or 'n' for new.")
            continue

        _last_region_group = group

        # Upgrades retains its specialized flow
        if group == "upgrades":
            subgroup = input("Enter upgrade category [attack, defense, utility]: ").strip().lower()
            if subgroup not in {"attack", "defense", "utility"}:
                print("[ERROR] Invalid upgrade subgroup.")
                continue

            side = input("Enter side [left, right]: ").strip().lower()
            if side not in {"left", "right"}:
                print("[ERROR] Invalid upgrade side.")
                continue

            label = input("Enter upgrade label key (e.g., damage, attack_speed): ").strip()
            if not _valid_group_name(label):
                print("❌ Invalid label key. Use letters/digits/underscore; start with letter/_")
                continue

            return f"{group}.{subgroup}.{side}.{label}"

        # Generic suffix
        suffix = input(f"Enter entry key for `{group}` (e.g., retry, attack_menu, claim_ad_gem): ").strip()
        if not suffix:
            print("[INFO] Skipped saving.")
            return None

        return f"{group}.{suffix}"

def prompt_roles(group: str, key: str) -> List[str]:
    """
    ---
    spec:
      r: "list[str]"
      s: ["stdio"]
      e: []
      params:
        group: "str"
        key: "str"
      notes:
        - "Suggests a role based on group; user can override via input"
        - "Returns [default] if user presses Enter"
    ---
    Suggest roles for a (group, key) and allow interactive override.
    """
    group = group.lower()
    if group == "gesture_targets":
        default = "gesture"
    elif group == "upgrades":
        default = "upgrade_label"
    elif group == "util":
        print(f"[?] Group '{group}' may refer to either a tap or a swipe.")
        user_input = input("    Enter roles manually (e.g., tap, swipe): ").strip()
        roles = [r.strip() for r in user_input.split(",") if r.strip()]
        return roles if roles else ["unknown"]
    else:
        default = group.rstrip("s")
    user_input = input(f"Suggested roles for `{group}:{key}`: [{default}] (edit or press Enter to accept): ").strip()
    if user_input:
        roles = [r.strip() for r in user_input.split(",")]
    else:
        roles = [default]
    return roles

def get_click(name: str) -> Optional[Tuple[int, int]]:
    """
    ---
    spec:
      r: "tuple[int,int] | None"
      s: ["log?"]
      e: []
      params:
        name: "str — dot-path to entry"
      notes:
        - "Prefers explicit 'tap' coords; falls back to center of 'match_region'"
        - "Logs WARN if dot-path cannot be resolved"
    ---
    Return (x, y) for a named entry. Prefers explicit 'tap' coords; falls
    back to the center of 'match_region'. Returns None if unresolved.
    Note: does not perform any device I/O.
    """
    entry = resolve_dot_path(name)
    if not entry:
        log(f"[DEBUG] get_click: resolve_dot_path failed for {name}", "WARN")
        return None
    if "tap" in entry:
        tap = entry["tap"]
        return tap["x"], tap["y"]
    elif "match_region" in entry:
        region = entry["match_region"]
        x, y, w, h = map(int, (region["x"], region["y"], region["w"], region["h"]))
        return x + w // 2, y + h // 2
    return None

def get_swipe(name: str) -> Optional[Dict[str, int]]:
    """
    ---
    spec:
      r: "dict[str,int] | None"
      s: []
      e: []
      params:
        name: "str"
      notes:
        - "Returns stored swipe params {x1,y1,x2,y2,duration_ms} or None"
    ---
    Return a swipe dict {x1,y1,x2,y2,duration_ms} for a named entry, or None.
    """
    entry = resolve_dot_path(name)
    if not entry:
        return None
    return entry.get("swipe")

def has_click(name: str) -> bool:
    """
    ---
    spec:
      r: "bool"
      s: ["log?"]
      e: []
      params:
        name: "str"
      notes:
        - "Delegates to get_click(); may log WARN if unresolved"
    ---
    True if get_click(name) resolves to coordinates.
    """
    return get_click(name) is not None

def tap_now(name: str) -> None:
    """
    ---
    spec:
      r: "None"
      s: ["adb", "log"]
      e:
        - "No exception on ADB failures; adb_shell() handles errors and returns None"
      params:
        name: "str"
      notes:
        - "Logs ACTION on success; logs FAIL if coordinates unavailable"
    ---
    Issue an ADB tap at the resolved coordinates for 'name'. Logs action.
    """
    pos = get_click(name)
    if pos:
        log(f"TAP_NOW: {name} at {pos}", "ACTION")
        adb_shell(["input", "tap", str(pos[0]), str(pos[1])])
    else:
        log(f"[ERROR] tap_now: No coordinates for '{name}'", "FAIL")

def swipe_now(name: str) -> None:
    """
    ---
    spec:
      r: "None"
      s: ["adb", "log"]
      e:
        - "No exception on ADB failures; adb_shell() handles errors and returns None"
      params:
        name: "str"
      notes:
        - "Uses stored swipe parameters under entry['swipe']"
        - "Logs FAIL if swipe data missing"
    ---
    Issue an ADB swipe for 'name' using stored swipe parameters. Logs action.
    """
    swipe = get_swipe(name)
    if swipe:
        log(f"SWIPE_NOW: {name} ({swipe['x1']},{swipe['y1']})→({swipe['x2']},{swipe['x2']}) in {swipe['duration_ms']}ms", "ACTION")
        adb_shell([
            "input", "swipe",
            str(swipe["x1"]), str(swipe["y1"]),
            str(swipe["x2"]), str(swipe["y2"]),
            str(swipe["duration_ms"])
        ])
    else:
        log(f"[ERROR] swipe_now: No swipe data for '{name}'", "FAIL")

def save_clickmap(data: Optional[Dict[str, Any]] = None) -> None:
    """
    ---
    spec:
      r: "None"
      s: ["fs"]
      e:
        - "OSError/IOError may propagate on write/replace errors"
      params:
        data: "dict[str, Any] | None — defaults to global _clickmap"
      notes:
        - "Writes UTF-8 JSON atomically via temp file + os.replace"
    ---
    Persist the clickmap (or provided dict) to disk atomically as UTF-8 JSON.
    """
    if data is None:
        data = _clickmap
    tmp_path = CLICKMAP_FILE + ".tmp"
    with open(tmp_path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)
    os.replace(tmp_path, CLICKMAP_FILE)
    print("[INFO] Saved clickmap to", CLICKMAP_FILE)

def flatten_clickmap(data: Optional[Dict[str, Any]] = None, prefix: str = "") -> Dict[str, Any]:
    """
    ---
    spec:
      r: "dict[str, Any] — flat dot-path → leaf value"
      s: []
      e: []
      params:
        data: "dict[str, Any] | None — defaults to global _clickmap"
        prefix: "str — optional path prefix"
      notes:
        - "Recurses into dicts; leaves non-dict values at their full dot-path"
    ---
    Return a flat mapping of dot-path → leaf value for the clickmap (or provided dict).
    """
    entries: Dict[str, Any] = {}
    if data is None:
        data = _clickmap
    for key, value in data.items():
        full_key = f"{prefix}.{key}" if prefix else key
        if isinstance(value, dict):
            entries.update(flatten_clickmap(value, full_key))
        else:
            entries[full_key] = value
    return entries

def get_entries_by_role(role: str) -> Dict[str, Dict[str, Any]]:
    """
    ---
    spec:
      r: "dict[str, dict] — dot-path → entry with matching role"
      s: []
      e: []
      params:
        role: "str — role name to filter by (must be present in entry['roles'])"
      notes:
        - "Searches entire clickmap for dicts containing 'roles' with the given role"
    ---
    Return a dict of entries (dot-path → entry) whose 'roles' includes the given role.
    """
    results: Dict[str, Dict[str, Any]] = {}
    def _search(d: Dict[str, Any], path: str = "") -> None:
        for k, v in d.items():
            new_path = f"{path}.{k}" if path else k
            if isinstance(v, dict):
                if "roles" in v and role in v["roles"]:
                    results[new_path] = v
                _search(v, new_path)
    _search(_clickmap)
    return results
----------./core/state_detector.py----------------------
./core/state_detector.py
# core/state_detector.py
"""
State detection against clickmap + YAML rules.

This module reads `config/state_definitions.yaml` and classifies a frame into a
single **primary** state, optional **secondary** states, optional mutually
exclusive **menu** state, and any number of **overlays**.

YAML-in-docstring legend (kept tiny and consistent per module)

spec_legend:
  r: Return value (shape & invariants)
  s: Side effects (tags from project primer)
  e: Errors/exceptions behavior
  p: Parameters (only non-obvious notes; types are in signature)
  notes: Brief extra context that aids correct use

defaults:
  threshold_default: 0.90
  images: BGR; origin=(0,0) top-left
  matcher: OpenCV TM_CCOEFF_NORMED via utils.template_matcher/core.matcher
  clickmap: config/clickmap.json (resolved via core.clickmap_access)
  state_yaml: config/state_definitions.yaml (safe_load)
  invariants:
    - Exactly one primary state per frame; multiple → RuntimeError
    - Menus are mutually exclusive; choose first match in YAML order
    - Overlays: 0..N may co-exist
"""

from utils.template_matcher import match_region
from utils.logger import log
from core.clickmap_access import resolve_dot_path, get_clickmap
from core.matcher import get_match
import yaml
import os

STATE_DEF_PATH = os.path.join(os.path.dirname(__file__), "../config/state_definitions.yaml")


def load_state_definitions():
    """
    spec:
      name: load_state_definitions
      signature: load_state_definitions() -> dict
      r: YAML dict loaded via yaml.safe_load from STATE_DEF_PATH
      s: [fs]
      e:
        - FileNotFoundError: when the YAML file path is missing
        - yaml.YAMLError: when parsing fails
      notes:
        - Caller treats the structure as authoritative for state/menu/overlay rules
    """
    with open(STATE_DEF_PATH, "r", encoding="utf-8") as f:
        return yaml.safe_load(f)


state_definitions = load_state_definitions()
clickmap = get_clickmap()


def detect_state_and_overlays(screen, *, log_matches: bool = False):
    """
    spec:
      name: detect_state_and_overlays
      signature: detect_state_and_overlays(screen, *, log_matches: bool = False) -> dict
      p:
        screen: BGR ndarray (full screen capture)
        log_matches: emit MATCH logs for debugging if True
      r:
        dict with keys:
          state: str  # one of primary names or "UNKNOWN"
          secondary_states: list[str]
          overlays: list[str]
          menu: str|null  # chosen from states of type: menu by YAML order
      s: [cv2][state][log]
      e:
        - RuntimeError: when multiple primary states match in the same frame
      notes:
        - Uses core.matcher.get_match for primary/menu checks (clickmap-backed)
        - Uses utils.template_matcher.match_region for overlay checks
        - Unresolved clickmap keys are WARN-logged and skipped
        - If no primary matches, state remains "UNKNOWN"
    """
    result = {
        "state": "UNKNOWN",
        "secondary_states": [],
        "overlays": [],
        "menu": None,  # mutually-exclusive menu secondary (from states with type: menu)
    }

    matched_states = []

    # Match all states
    for state in state_definitions.get("states", []):
        state_name = state["name"]
        match_keys = state.get("match_keys", [])
        for key in match_keys:
            entry = resolve_dot_path(key)
            if not entry:
                log(f"[WARN] Unresolved key: {key}", "WARN")
                continue
            pt, conf = get_match(key, screenshot=screen)
            if "match_template" not in entry:
                log(f"[WARN] No match_template for {key}; template matcher will always fail", "WARN")
                continue
            if pt:
                if log_matches:
                    log(f"[MATCH] State {state_name} via {key} at {pt} ({conf:.3f})", "MATCH")
                matched_states.append(state_name)
                break

    # Classify into primary, secondary, and menu (mutually exclusive selection)
    menu_candidates_in_order = []  # preserve YAML order for priority
    for name in matched_states:
        # find the state entry (by name) in YAML
        state_entry = next((s for s in state_definitions["states"] if s["name"] == name), None)
        if not state_entry:
            continue
        state_type = state_entry.get("type", "unknown")

        if state_type == "primary":
            if result["state"] != "UNKNOWN":
                raise RuntimeError(f"[ERROR] Multiple primary states matched: {result['state']} and {name}")
            result["state"] = name
        elif state_type == "menu":
            menu_candidates_in_order.append(name)
        else:
            result["secondary_states"].append(name)

    if menu_candidates_in_order:
        # pick the first matched in YAML order (order = priority)
        result["menu"] = menu_candidates_in_order[0]
        if len(menu_candidates_in_order) > 1:
            log(f"[WARN] Multiple menus matched {menu_candidates_in_order} -> chose '{result['menu']}' (YAML order priority)", "WARN")

    # Match overlays (can be multiple)
    for overlay in state_definitions.get("overlays", []):
        overlay_name = overlay["name"]
        for key in overlay.get("match_keys", []):
            entry = resolve_dot_path(key)
            if not entry:
                log(f"[WARN]     Could not resolve: {key}", "WARN")
                continue
            pt, conf = match_region(screen, entry)
            if pt:
                if log_matches:
                    log(f"[MATCH] Overlay {overlay_name} via {key} at {pt} ({conf:.3f})", "MATCH")
                result["overlays"].append(overlay_name)
                break

    return result
----------./core/label_tapper.py----------------------
./core/label_tapper.py
"""
core/label_tapper.py

Spec legend for embedded YAML blocks
---
spec_legend:
  r: "Return value"
  s: "Side effects"
  e: "Errors/exceptions (raised or propagated)"
  params: "Parameter annotations"
  notes: "Important details/guards/defaults"
defaults:
  match_threshold: 0.90
  image_space: "OpenCV BGR; origin top-left; regions {x,y,w,h}"
  matching: "cv2.TM_CCOEFF_NORMED"
---
"""

import cv2
import numpy as np
import functools
from core.ss_capture import capture_adb_screenshot
from core.clickmap_access import get_clickmap, resolve_dot_path
from core.adb_utils import adb_shell
from utils.logger import log


def _normalize_region(r):
    """
    ---
    spec:
      r: "dict{x:int,y:int,w:int,h:int}"
      s: []
      e:
        - "ValueError on unsupported/invalid region format"
      params:
        r: "dict|tuple|list — supports entry, entry.match_region, {left,top,width,height}, or (x,y,w,h)"
      notes:
        - "Coerces values to int"
    ---
    """
    if isinstance(r, dict) and "match_region" in r and isinstance(r["match_region"], dict):
        r = r["match_region"]
    if isinstance(r, dict) and all(k in r for k in ("x", "y", "w", "h")):
        return {"x": int(r["x"]), "y": int(r["y"]), "w": int(r["w"]), "h": int(r["h"])}
    if isinstance(r, dict) and all(k in r for k in ("left", "top", "width", "height")):
        return {"x": int(r["left"]), "y": int(r["top"]), "w": int(r["width"]), "h": int(r["height"])}
    if isinstance(r, (list, tuple)) and len(r) == 4:
        x, y, w, h = r
        return {"x": int(x), "y": int(y), "w": int(w), "h": int(h)}
    raise ValueError(f"Unsupported region format: {r!r}")


def resolve_region(entry, clickmap):
    """
    ---
    spec:
      r: "dict{x:int,y:int,w:int,h:int}"
      s: []
      e:
        - "ValueError if region_ref unknown or neither match_region nor region_ref present"
      params:
        entry: "clickmap entry dict"
        clickmap: "dict — full clickmap mapping"
      notes:
        - "match_region takes precedence over region_ref"
        - "region_ref is resolved under _shared_match_regions.<name>"
    ---
    """
    if "match_region" in entry:
        return _normalize_region(entry["match_region"])
    elif "region_ref" in entry:
        ref = entry["region_ref"]
        shared = clickmap.get("_shared_match_regions", {})
        if ref not in shared:
            raise ValueError(f"Unknown region_ref '{ref}'")
        return _normalize_region(shared[ref])
    else:
        raise ValueError("No match_region or region_ref defined")


@functools.lru_cache(maxsize=128)
def _load_template(name: str):
    """
    ---
    spec:
      r: "ndarray|None (grayscale template)"
      s: ["fs"]
      e: []
      params:
        name: "str — path relative to assets/match_templates/"
      notes:
        - "Uses cv2.imread(..., IMREAD_GRAYSCALE); returns None if missing"
        - "Cached via lru_cache(128)"
    ---
    Cached grayscale template loader.
    """
    tpl = cv2.imread(f"assets/match_templates/{name}", cv2.IMREAD_GRAYSCALE)
    return tpl


def get_label_match(label_key: str, screenshot=None, return_meta=False):
    """
    ---
    spec:
      r: "(x:int,y:int,w:int,h:int) | dict(meta)"
      s: ["adb?", "cv2"]
      e:
        - "ValueError if key missing / region out-of-bounds / threshold fail"
        - "FileNotFoundError if template file not found"
        - "RuntimeError if screenshot capture fails"
      params:
        label_key: "str — clickmap dot-path"
        screenshot: "ndarray|None — BGR or gray; capture via ADB when None"
        return_meta: "bool — when True, return dict with metadata and match_score"
      notes:
        - "Converts screenshot to grayscale for matching"
        - "Threshold defaults to 0.9 unless entry.match_threshold provided"
        - "Clamps region to image bounds defensively"
    ---
    Matches a label using its match_template and match_region or region_ref.
    Returns (x, y, w, h) by default.
    If return_meta=True, returns a dict with match + metadata.
    """
    entry = resolve_dot_path(label_key)
    if not entry:
        raise ValueError(f"Label key '{label_key}' not found in clickmap")

    template = _load_template(entry["match_template"])
    if template is None:
        raise FileNotFoundError(
            f"Template not found: assets/match_templates/{entry['match_template']}"
        )

    if screenshot is None:
        screenshot = capture_adb_screenshot()
        if screenshot is None:
            raise RuntimeError("Failed to capture screenshot")

    # Convert to grayscale only when needed
    if screenshot is not None and getattr(screenshot, "ndim", None) == 3:
        screenshot = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)

    cm = get_clickmap()
    region = resolve_region(entry, cm)

    # Clamp region to screenshot bounds (defensive)
    H, W = screenshot.shape[:2]
    x = max(0, int(region["x"]))
    y = max(0, int(region["y"]))
    w = int(region["w"])
    h = int(region["h"])
    x2 = min(W, x + max(0, w))
    y2 = min(H, y + max(0, h))
    clamped_w = x2 - x
    clamped_h = y2 - y
    if clamped_w <= 0 or clamped_h <= 0:
        raise ValueError(
            f"Region out of bounds for {label_key}: {region} within image {W}x{H}"
        )

    region_img = screenshot[y : y + clamped_h, x : x + clamped_w]

    result = cv2.matchTemplate(region_img, template, cv2.TM_CCOEFF_NORMED)
    _, max_val, _, max_loc = cv2.minMaxLoc(result)

    if max_val < entry.get("match_threshold", 0.9):
        raise ValueError(f"Match for {label_key} failed threshold: {max_val:.2f}")

    match_x = x + max_loc[0]
    match_y = y + max_loc[1]
    th, tw = template.shape[:2]

    if return_meta:
        return {
            "x": match_x,
            "y": match_y,
            "w": tw,
            "h": th,
            "menu": entry.get("menu"),
            "region_ref": entry.get("region_ref"),
            "order": entry.get("order"),
            "match_score": max_val,
        }
    return (match_x, match_y, tw, th)


def tap_label_now(label_key: str) -> bool:
    """
    ---
    spec:
      r: "bool — True if tap issued, else False"
      s: ["adb", "log"]
      e: []
      params:
        label_key: "str"
      notes:
        - "Catches ValueError/FileNotFoundError/RuntimeError from get_label_match and returns False"
        - "Supports optional entry.tap_offset {x,y}"
        - "Taps center of matched bbox when no offset"
    ---
    Taps a label if it can be visually matched.
    Returns True if the tap succeeded, False otherwise.
    """
    try:
        x, y, w, h = get_label_match(label_key)
    except (ValueError, FileNotFoundError, RuntimeError) as e:
        log(f"[SKIP] tap_label_now failed for {label_key}: {e}", "WARN")
        return False

    entry = resolve_dot_path(label_key)
    # Prefer explicit per-entry offset. If missing and this is an upgrade label,
    # fall back to a sensible default that targets the right cost box.
    offset = entry.get("tap_offset", None)
    if offset is None:
        roles = entry.get("roles") or []
        if isinstance(roles, list) and "upgrade_label" in roles:
            offset = {"x": 405, "y": 60}

    tap_x = x + offset["x"] if offset else x + w // 2
    tap_y = y + offset["y"] if offset else y + h // 2

    log(f"TAP_LABEL_NOW: {label_key} at ({tap_x},{tap_y})", "ACTION")
    adb_shell(["input", "tap", str(tap_x), str(tap_y)])
    return True


def is_visible(label_key: str, screenshot=None) -> bool:
    """
    ---
    spec:
      r: "bool"
      s: ["adb?"]
      e: []
      params:
        label_key: "str"
        screenshot: "ndarray|None"
      notes:
        - "Returns True when get_label_match succeeds, else False (ValueError path)"
    ---
    """
    try:
        get_label_match(label_key, screenshot=screenshot)
        return True
    except ValueError:
        return False


def _get_shared_upgrade_region(side: str):
    """
    ---
    spec:
      r: "tuple(x:int,y:int,w:int,h:int)"
      s: []
      e:
        - "RuntimeError if shared region missing/invalid"
      params:
        side: "'left'|'right'"
      notes:
        - "Resolves _shared_match_regions.upgrades_<side>.match_region"
    ---
    Resolve _shared_match_regions.upgrades_left/right -> (x,y,w,h).
    Raises RuntimeError if missing.
    """
    key = f"_shared_match_regions.upgrades_{side}"
    entry = resolve_dot_path(key)
    if not entry or "match_region" not in entry:
        raise RuntimeError(f"Shared region not found or invalid: {key}")
    r = entry["match_region"]
    return int(r["x"]), int(r["y"]), int(r["w"]), int(r["h"])


def swipe_relative_in_region(region, start_frac=(0.50, 0.82), end_frac=(0.50, 0.25), duration_ms=260):
    """
    ---
    spec:
      r: "None"
      s: ["adb", "log"]
      e: []
      params:
        region: "tuple(x,y,w,h) — base rect in screen coords"
        start_frac: "(fx,fy) — relative inside inset rect"
        end_frac: "(fx,fy) — relative inside inset rect"
        duration_ms: "int"
      notes:
        - "Insets region by max(12, 1.2% of min(w,h)) to avoid borders"
        - "Clamps fractions to [0..1]"
    ---
    Send a raw ADB swipe using start/end positions relative to a region rect.

    region: (x,y,w,h)
    start_frac/end_frac: (fx, fy) with 0..1 inside the region AFTER insets.
    """
    x, y, w, h = map(int, region)
    # inset a bit to avoid borders/accidental chrome hits
    inset = max(12, int(0.012 * min(w, h)))
    x0, y0 = x + inset, y + inset
    w2, h2 = max(1, w - 2 * inset), max(1, h - 2 * inset)

    sx = int(x0 + max(0.0, min(1.0, start_frac[0])) * w2)
    sy = int(y0 + max(0.0, min(1.0, start_frac[1])) * h2)
    ex = int(x0 + max(0.0, min(1.0, end_frac[0])) * w2)
    ey = int(y0 + max(0.0, min(1.0, end_frac[1])) * h2)

    log(f"SWIPE_REL: ({sx},{sy})→({ex},{ey}) in {duration_ms}ms", "ACTION")
    adb_shell(["input", "swipe", str(sx), str(sy), str(ex), str(ey), str(duration_ms)])


def page_column(side: str, direction: str, strength: str = "page", duration_ms: int = 260):
    """
    ---
    spec:
      r: "None"
      s: ["adb", "log"]
      e:
        - "ValueError if side/direction/strength invalid"
      params:
        side: "'left'|'right'"
        direction: "'up'|'down'"
        strength: "'page'|'micro'"
        duration_ms: "int"
      notes:
        - "Chooses pre-tuned swipe vectors per strength & direction"
        - "Uses shared upgrade column region"
    ---
    Scroll the upgrades list adaptively within the shared column region.

    side: "left" | "right"
    direction: "up" (toward TOP/earlier rows) or "down" (toward BOTTOM/later rows)
    strength: "page" (~75% height) or "micro" (~25% height)
    """
    side = side.lower()
    if side not in ("left", "right"):
        raise ValueError("side must be 'left' or 'right'")
    direction = direction.lower()
    if direction not in ("up", "down"):
        raise ValueError("direction must be 'up' or 'down'")
    strength = strength.lower()
    if strength not in ("page", "micro"):
        raise ValueError("strength must be 'page' or 'micro'")

    region = _get_shared_upgrade_region(side)

    if strength == "page":
        # Large move
        up_start, up_end   = (0.50, 0.32), (0.50, 0.65)  # finger moves DOWN (content goes UP)
        down_start, down_end = (0.50, 0.65), (0.50, 0.32)
    else:
        # Smaller move for fine search
        up_start, up_end   = (0.50, 0.45), (0.50, 0.55)
        down_start, down_end = (0.50, 0.55), (0.50, 0.45)

    if direction == "up":
        swipe_relative_in_region(region, start_frac=up_start, end_frac=up_end, duration_ms=duration_ms)
    else:
        swipe_relative_in_region(region, start_frac=down_start, end_frac=down_end, duration_ms=duration_ms)
----------./core/ss_capture.py----------------------
./core/ss_capture.py
import os
import numpy as np
import cv2
from utils.logger import log
from core.adb_utils import screencap_png

LATEST_SCREENSHOT = "screenshots/latest.png"

def capture_adb_screenshot():
    """
    ---
    spec:
      r: "np.ndarray | None (BGR)"
      s: ["adb", "cv2", "log"]
      e:
        - "Returns None on capture or decode failure; logs ERROR"
      params: {}
      notes:
        - "Uses core.adb_utils.screencap_png() → PNG bytes"
        - "Validates PNG signature before decode"
        - "Decodes via cv2.imdecode to BGR ndarray"
    ---
    Capture a screenshot from the connected ADB device/emulator and decode to an OpenCV BGR image.

    Returns:
        np.ndarray (BGR) on success, or None on failure.
    """
    try:
        png_data = screencap_png()
        if not png_data:
            log("[ADB Error] Empty screenshot data", "ERROR")
            return None

        if not png_data.startswith(b'\x89PNG\r\n\x1a\n'):
            raise ValueError("Invalid screenshot data (not PNG)")

        # Convert PNG bytes to OpenCV image
        img_array = np.frombuffer(png_data, dtype=np.uint8)
        img = cv2.imdecode(img_array, cv2.IMREAD_COLOR)
        if img is None:
            raise ValueError("OpenCV failed to decode image")

        return img

    except Exception as e:
        log(f"[Error] {e}", "ERROR")
        return None


def capture_and_save_screenshot(path=LATEST_SCREENSHOT, *, log_capture: bool = True):
    """
    ---
    spec:
      r: "np.ndarray | None (BGR)"
      s: ["adb", "cv2", "fs", "log"]
      e:
        - "Returns None if capture fails"
        - "OSError may propagate from os.makedirs/cv2.imwrite on filesystem errors"
      params:
        path: "str — output PNG path (parents created)"
        log_capture: "bool — when False, suppress DEBUG log after save"
      notes:
        - "Delegates capture to capture_adb_screenshot()"
        - "Writes PNG to disk if capture succeeds"
    ---
    Capture a screenshot and save it to disk.

    Args:
        path: Output PNG path; parent directories will be created if needed.
        log_capture (bool): When False, suppress the debug log after saving.

    Returns:
        np.ndarray (BGR) on success, or None on failure.
    """
    img = capture_adb_screenshot()
    if img is not None:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        cv2.imwrite(path, img)
        if log_capture:
            log(f"Captured and saved screenshot: shape={img.shape}, path={path}", level="DEBUG")
    return img


def main():
    """
    ---
    spec:
      r: "None"
      s: ["adb", "cv2", "log"]
      e: []
      params: {}
      notes:
        - "Utility viewer: captures, logs size, optionally resizes to fit height≈2048, displays via cv2.imshow"
        - "Blocks on key; closes window afterward"
    ---
    CLI/display helper: capture once, log size, show a window for inspection.
    """
    image = capture_adb_screenshot()
    if image is not None:
        log(f"[Info] Screenshot shape: {image.shape}", "INFO")

        # Resize for screen display if too large (e.g., fit height to 2048px)
        max_height = 2048
        scale = min(1.0, max_height / image.shape[0])
        if scale < 1.0:
            resized = cv2.resize(image, None, fx=scale, fy=scale, interpolation=cv2.INTER_AREA)
            log(f"Resized for display: {resized.shape}", "INFO")
        else:
            resized = image

        cv2.imshow("ADB Screenshot", resized)
        cv2.waitKey(0)
        cv2.destroyAllWindows()
    else:
        log("Failed to capture or decode screenshot", "ERROR")


if __name__ == "__main__":
    main()
----------./core/tap_dispatcher.py----------------------
./core/tap_dispatcher.py
# tap_dispatcher.py
"""
Queued tap injection via a single background worker.

spec_legend:
  r: Return value (shape & invariants)
  s: Side effects (project tags like [tap][log][thread])
  e: Errors/exceptions behavior
  p: Parameter notes beyond the signature
  notes: Usage guidance / invariants

defaults:
  queue_semantics: FIFO ordering preserved per process
  worker: A daemon thread is started on import and processes TAP_QUEUE
  tap_path: Uses core.adb_utils.adb_shell → "input tap x y"
  logging: Per-tap logging goes through utils.logger.log when log_it=True
"""

import threading
import queue
import time
import random
from utils.logger import log
from core.adb_utils import adb_shell

TAP_QUEUE = queue.Queue()
"""
spec:
  name: TAP_QUEUE
  kind: queue.Queue
  r: In-process FIFO for (x:int, y:int, label:Optional[str], log_it:bool)
  notes:
    - Back-compat: the worker also accepts 3-tuples (x, y, label) and sets log_it=True.
"""


def log_tap(x, y, label):
    """
    spec:
      name: log_tap
      signature: log_tap(x:int, y:int, label: str|None) -> None
      r: null
      s: [log]
      notes:
        - Emits a single ACTION-level line with coordinates and optional label.
    """
    log(f"TAP {label or ''} at ({x},{y})", level="ACTION")


def tap(x, y, label=None, *, log_it: bool = True):
    """
    Public function for scripts to submit tap requests.

    spec:
      name: tap
      signature: tap(x:int, y:int, label:str|None=None, *, log_it:bool=True) -> None
      p:
        log_it: When False, the worker will perform the tap without calling log_tap.
      r: null
      s: [thread]
      e: none (puts into an unbounded Queue; may block briefly only under extreme memory pressure)
      notes:
        - Enqueues a 4-tuple (x, y, label, log_it) for the worker.
        - Callers should not assume immediate execution; it is asynchronous.
    """
    TAP_QUEUE.put((x, y, label, log_it))


def _tap_worker():
    """
    spec:
      name: _tap_worker
      kind: background-thread
      r: never returns (infinite loop)
      s: [tap][log]
      e:
        - queue.Empty is handled internally with a short idle wait.
        - Other exceptions from adb_shell are not re-raised here (same-process resilience).
      notes:
        - Accepts both 4-tuple and legacy 3-tuple items from TAP_QUEUE.
    """
    last_keepalive = time.time()
    while True:
        now = time.time()
        try:
            item = TAP_QUEUE.get(timeout=1)
            # Backward compatibility: accept old 3-tuples
            if isinstance(item, tuple) and len(item) == 3:
                x, y, label = item
                log_it = True
            else:
                x, y, label, log_it = item
            adb_shell(["input", "tap", str(x), str(y)])
            if log_it:
                log_tap(x, y, label)
        except queue.Empty:
            pass  # nothing to do

# Start worker thread (on import)
threading.Thread(target=_tap_worker, daemon=True).start()


def main():
    """
    spec:
      name: main
      signature: main() -> None
      r: null
      s: [log][loop]
      e:
        - KeyboardInterrupt: prints a shutdown message and exits cleanly.
      notes:
        - Utility runner that keeps the process alive so the worker can service taps.
    """
    log("Tap dispatcher running. Press Ctrl+C to exit.", level="INFO")
    try:
        while True:
            time.sleep(10)
    except KeyboardInterrupt:
        print("Shutting down dispatcher.")


if __name__ == "__main__":
    main()
----------./core/matcher.py----------------------
./core/matcher.py
# core/matcher.py
"""
Centralized, clickmap-backed matching utilities.

Public API:
    get_match(dot_path, *, screenshot, template_dir="assets/match_templates")
        → ((x, y), confidence) or (None, confidence)

Private helper (for shims/tests only):
    _match_entry(screenshot, entry, template_dir)
        → ((x, y), confidence) or (None, confidence)

Notes:
- Uses OpenCV template matching (cv2.TM_CCOEFF_NORMED).
- Reads template/region/threshold from clickmap entries (via clickmap.json).
- Expands the search region by optional 'match_padding' (default 12px), clamped to screen bounds.
"""

from __future__ import annotations
from typing import Optional, Tuple, Dict, Any
import os
import cv2
import numpy as np  # used by detect_floating_gem_square
from core.clickmap_access import resolve_dot_path


def _match_entry(
    screenshot,
    entry: Dict[str, Any],
    template_dir: str = "assets/match_templates",
) -> Tuple[Optional[Tuple[int, int]], float]:
    """
    Low-level matcher using an already-resolved clickmap entry dict.

    Entry contract:
      - 'match_template': path relative to template_dir (e.g., 'indicators/game_over.png')  [required]
      - One of:
          * 'match_region': {'x','y','w','h'}
          * 'region_ref': name referencing clickmap._shared_match_regions.<name>.match_region
      - Optional:
          * 'match_threshold' (float, default 0.9)
          * 'match_padding' (int pixels, default 12)

    Args:
        screenshot: BGR ndarray to search.
        entry: clickmap entry dict (see above).
        template_dir: base directory for templates.

    Returns:
        ((x, y), confidence) if confidence >= threshold; otherwise (None, confidence).

    Errors:
        FileNotFoundError if the template file is missing.
        ValueError if the template cannot be loaded.
        cv2.error if images are invalid.
    """
    if not entry or "match_template" not in entry:
        return None, 0.0

    template_path = os.path.join(template_dir, entry["match_template"])
    if not os.path.exists(template_path):
        raise FileNotFoundError(f"Template not found: {template_path}")

    # Resolve region
    region = entry.get("match_region")
    if region is None and "region_ref" in entry:
        region_entry = resolve_dot_path(f"_shared_match_regions.{entry['region_ref']}")
        region = region_entry.get("match_region") if region_entry else None

    if not region:
        return None, 0.0

    x, y, w, h = region["x"], region["y"], region["w"], region["h"]
    padding = int(entry.get("match_padding", 12))

    # Expand region with padding, clamp to screen bounds
    x1 = max(0, x - padding)
    y1 = max(0, y - padding)
    x2 = min(screenshot.shape[1], x + w + padding)
    y2 = min(screenshot.shape[0], y + h + padding)
    if x1 >= x2 or y1 >= y2:
        return None, 0.0

    region_img = screenshot[y1:y2, x1:x2]

    template = cv2.imread(template_path)
    if template is None:
        raise ValueError(f"Failed to load template: {template_path}")

    res = cv2.matchTemplate(region_img, template, cv2.TM_CCOEFF_NORMED)
    _, max_val, _, max_loc = cv2.minMaxLoc(res)

    threshold = float(entry.get("match_threshold", 0.9))
    if max_val >= threshold:
        match_x = x1 + max_loc[0] + template.shape[1] // 2
        match_y = y1 + max_loc[1] + template.shape[0] // 2
        return (match_x, match_y), max_val
    else:
        return None, max_val


def get_match(
    dot_path: str,
    *,
    screenshot,
    template_dir: str = "assets/match_templates",
) -> Tuple[Optional[Tuple[int, int]], float]:
    """
    Resolve a clickmap entry by dot-path, then perform matching.

    Args:
        dot_path: e.g., "indicators.game_over".
        screenshot: BGR ndarray to search.
        template_dir: base directory for templates.

    Returns:
        ((x, y), confidence) if found; else (None, confidence).
    """
    entry = resolve_dot_path(dot_path)
    if not entry:
        return None, 0.0
    return _match_entry(screenshot, entry, template_dir=template_dir)


def detect_floating_gem_square(screenshot, region: Dict[str, int], debug: bool = False) -> bool:
    """
    Heuristic detector for a bright magenta square within the given region.

    Args:
        screenshot: BGR ndarray.
        region: {'x','y','w','h'} bounding box.
        debug: if True, logs and writes 'debug_floating_gem_square.png'.

    Returns:
        True if a roughly square magenta contour is found; else False.
    """
    from utils.logger import log  # local import to avoid cycles

    x, y, w, h = region["x"], region["y"], region["w"], region["h"]
    roi = screenshot[y:y + h, x:x + w]

    hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)

    # Bright pink / magenta range
    lower = np.array([140, 100, 100])
    upper = np.array([170, 255, 255])
    mask = cv2.inRange(hsv, lower, upper)

    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    for cnt in contours:
        area = cv2.contourArea(cnt)
        if area < 150:
            continue

        epsilon = 0.02 * cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, epsilon, True)

        if len(approx) == 4:  # must be 4-sided
            x_, y_, w_, h_ = cv2.boundingRect(approx)
            aspect_ratio = w_ / h_
            if 0.8 <= aspect_ratio <= 1.2:  # roughly square
                if debug:
                    log(f"[DEBUG] Floating gem pink square detected at ({x_}, {y_}), size {w_}x{h_}", "DEBUG")
                    debug_img = cv2.cvtColor(mask, cv2.COLOR_GRAY2BGR)
                    cv2.drawContours(debug_img, [approx], -1, (0, 255, 0), 2)
                    cv2.imwrite("debug_floating_gem_square.png", debug_img)
                return True

    if debug:
        log("[DEBUG] No qualifying pink square detected in floating gem region", "DEBUG")

    return False
----------./core/watchdog.py----------------------
./core/watchdog.py
# core/watchdog.py
"""
Foreground/process watchdog for the game app.

spec_legend:
  r: Return value (shape & invariants)
  s: Side effects (project tags like [adb][log][sleep][state][loop])
  e: Errors/exceptions behavior
  p: Parameter notes beyond the signature
  notes: Usage guidance / invariants

defaults:
  game_package: com.TechTreeGames.TheTower
  detection:
    - Foreground app inferred via dumpsys window/windows → activity/activities
    - Multiple textual patterns supported for broad Android/emu coverage
  targeting: Uses core.adb_utils.adb_shell; device selection follows adb_utils precedence
  logging: Foreground package changes are INFO/DEBUG; failures WARN/ERROR
  sleep_delays:
    - bring_to_foreground: ~5s, restart_game: ~6s
  globals:
    - _last_foreground_pkg caches last seen foreground for change logging only
"""

import re
import time
from core.automation_state import AUTOMATION, RunState
from core.adb_utils import adb_shell
from utils.logger import log

GAME_PACKAGE = "com.TechTreeGames.TheTower"
"""
spec:
  name: GAME_PACKAGE
  kind: const
  r: Package name string used by monkey/force-stop checks.
  notes:
    - Override only if the target app id changes; other functions depend on it.
"""

_last_foreground_pkg = None
"""
spec:
  name: _last_foreground_pkg
  kind: module-global cache
  r: str|None (last detected foreground package), used to suppress noisy logs.
"""


def _parse_pkg_from_text(text: str):
    """
    spec:
      name: _parse_pkg_from_text
      signature: _parse_pkg_from_text(text:str) -> str|None
      r: Package name if any pattern matches; else None.
      s: none
      e: none (pure function)
      notes:
        - Supports multiple dumpsys formats (mCurrentFocus, topResumedActivity, mResumedActivity, mFocusedApp).
    """
    if not text:
        return None

    # Pattern 1: window mCurrentFocus (common on emu & older devices)
    m = re.search(r"mCurrentFocus=Window\{.*?\s+(\S+)/\S+\}", text)
    if m:
        return m.group(1)

    # Pattern 2: topResumedActivity (newer AOSP)
    m = re.search(r"topResumedActivity.*?\s+(\S+)/\S+", text)
    if m:
        return m.group(1)

    # Pattern 3: mResumedActivity (older/newer mixes)
    m = re.search(r"mResumedActivity.*?\s+(\S+)/\S+", text)
    if m:
        return m.group(1)

    # Pattern 4: focused app (very old fallbacks)
    m = re.search(r"mFocusedApp=.*\s+(\S+)/\S+", text)
    if m:
        return m.group(1)

    return None


def _get_foreground_package():
    """
    spec:
      name: _get_foreground_package
      signature: _get_foreground_package() -> str|None
      r: The currently foregrounded package name, or None if undetermined.
      s: [adb]
      e:
        - Suppresses CalledProcessError by using check=False in adb_shell.
        - Returns None on any non-zero exit or unparsable output.
      notes:
        - Tries dumpsys window windows first, then dumpsys activity activities.
    """
    # First try window service (often most reliable under emu)
    res = adb_shell(["dumpsys", "window", "windows"], capture_output=True, check=False)
    if res and res.returncode == 0:
        pkg = _parse_pkg_from_text(res.stdout)
        if pkg:
            return pkg

    # Fallback to activity service (formats vary by release)
    res = adb_shell(["dumpsys", "activity", "activities"], capture_output=True, check=False)
    if res and res.returncode == 0:
        pkg = _parse_pkg_from_text(res.stdout)
        if pkg:
            return pkg

    return None


def is_game_foregrounded():
    """
    spec:
      name: is_game_foregrounded
      signature: is_game_foregrounded() -> bool
      r: True if GAME_PACKAGE is foreground; False otherwise.
      s: [adb][log]
      e: none (logs WARN when foreground cannot be determined)
      notes:
        - Logs any change in the detected foreground package since the last call.
    """
    global _last_foreground_pkg
    package = _get_foreground_package()
    if package:
        if package != _last_foreground_pkg:
            if _last_foreground_pkg is None:
                log(f"[WATCHDOG] Started — current foreground app: {package}", level="DEBUG")
            else:
                log(f"[WATCHDOG] Foreground changed: {package}", level="DEBUG")
            _last_foreground_pkg = package
        return package.lower() == GAME_PACKAGE.lower()
    else:
        log("[WATCHDOG] Could not determine foreground app", level="WARN")
        return False


def bring_to_foreground():
    """
    spec:
      name: bring_to_foreground
      signature: bring_to_foreground() -> None
      r: null
      s: [adb][log][sleep]
      e: none (uses check=False; best-effort)
      notes:
        - Sends a single monkey LAUNCHER intent for GAME_PACKAGE and waits ~5s.
    """
    adb_shell([
        "monkey", "-p", GAME_PACKAGE,
        "-c", "android.intent.category.LAUNCHER", "1"
    ], check=False)
    log("[WATCHDOG] Sent monkey event to foreground game.", "INFO")
    time.sleep(5)


def restart_game():
    """
    spec:
      name: restart_game
      signature: restart_game() -> None
      r: null
      s: [adb][state][log][sleep]
      e: none (best-effort; uses check=False)
      notes:
        - Force-stops GAME_PACKAGE, relaunches via monkey, then sets AUTOMATION.state=UNKNOWN.
        - Sleeps ~6s after relaunch to allow surface creation.
    """
    log("[WATCHDOG] Restarting game via monkey intent", "INFO")

    # Hard-stop first to avoid stale process/session on emulators
    adb_shell(["am", "force-stop", GAME_PACKAGE], check=False)

    # Launch the game (monkey keeps us activity-agnostic)
    adb_shell([
        "monkey", "-p", GAME_PACKAGE,
        "-c", "android.intent.category.LAUNCHER", "1"
    ], check=False)
    time.sleep(6)

    # Set state to unknown — main loop will detect screen state
    from core.automation_state import AUTOMATION, RunState
    AUTOMATION.state = RunState.UNKNOWN

    log("[WATCHDOG] Game launched — deferring to main loop for state detection", "INFO")


def _pid_running(package: str) -> bool:
    """
    spec:
      name: _pid_running
      signature: _pid_running(package:str) -> bool
      r: True if a process with exact package name is running; else False.
      s: [adb]
      e: none (returns False on any adb failure)
      notes:
        - Uses pidof first; falls back to parsing `ps -A` and matching the final column exactly.
    """
    res = adb_shell(["pidof", package], capture_output=True, check=False)
    if res and res.returncode == 0 and res.stdout.strip():
        return True

    # Fallback: ps scan (avoid false positives by splitting columns)
    res = adb_shell(["ps", "-A"], capture_output=True, check=False)
    if not res or res.returncode != 0 or not res.stdout:
        return False
    for line in res.stdout.splitlines():
        parts = line.split()
        if parts and parts[-1] == package:
            return True
    return False


def watchdog_process_check(interval=30):
    """
    spec:
      name: watchdog_process_check
      signature: watchdog_process_check(interval:int=30) -> None
      r: null (infinite supervisory loop)
      s: [adb][state][log][loop][sleep]
      e:
        - Catches and logs all Exceptions each cycle; continues looping.
      p:
        interval: Seconds between checks (≥1 recommended).
      notes:
        - Ensures the process is running and foregrounded; calls restart_game or bring_to_foreground as needed.
    """
    while True:
        try:
            pid_running = _pid_running(GAME_PACKAGE)
            foregrounded = is_game_foregrounded()

            if not pid_running:
                log("[WATCHDOG] Game process not running. Restarting.", "WARN")
                restart_game()
            elif not foregrounded:
                log("[WATCHDOG] Game is backgrounded. Bringing to foreground.", "WARN")
                bring_to_foreground()

        except Exception as e:
            log(f"[WATCHDOG ERROR] {e}", "ERROR")

        time.sleep(interval)
----------./new/core/label_tapper.py----------------------
./new/core/label_tapper.py
import cv2
import numpy as np
from core.ss_capture import capture_adb_screenshot
from core.clickmap_access import get_clickmap
from core.adb_utils import adb_shell
from utils.logger import log

def resolve_region(entry, clickmap):
    if "match_region" in entry:
        return entry["match_region"]
    elif "region_ref" in entry:
        ref = entry["region_ref"]
        shared = clickmap.get("_shared_match_regions", {})
        if ref not in shared:
            raise ValueError(f"Unknown region_ref '{ref}'")
        return shared[ref]
    else:
        raise ValueError("No match_region or region_ref defined")

def get_label_match(label_key: str, screenshot=None):
    """
    Matches a label using its match_template and match_region or region_ref.
    Returns the top-left (x, y) of the match and the match width/height.
    """
    cm = get_clickmap()
    if label_key not in cm:
        raise ValueError(f"Label key '{label_key}' not found in clickmap")

    entry = cm[label_key]
    template = cv2.imread(f"assets/{entry['match_template']}", cv2.IMREAD_GRAYSCALE)
    if template is None:
        raise FileNotFoundError(f"Template not found: assets/{entry['match_template']}")

    if screenshot is None:
        screenshot = capture_adb_screenshot()
        if screenshot is None:
            raise RuntimeError("Failed to capture screenshot")
        screenshot = cv2.cvtColor(screenshot, cv2.COLOR_BGR2GRAY)

    region = resolve_region(entry, cm)
    region_img = screenshot[
        region["y"]:region["y"] + region["h"],
        region["x"]:region["x"] + region["w"]
    ]

    result = cv2.matchTemplate(region_img, template, cv2.TM_CCOEFF_NORMED)
    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(result)

    if max_val < entry.get("match_threshold", 0.9):
        raise ValueError(f"Match for {label_key} failed threshold: {max_val:.2f}")

    match_x = region["x"] + max_loc[0]
    match_y = region["y"] + max_loc[1]
    h, w = template.shape[:2]
    return (match_x, match_y, w, h)

def tap_label_now(label_key: str):
    """
    Taps a label by matching its position and applying an optional offset.
    """
    x, y, w, h = get_label_match(label_key)
    cm = get_clickmap()
    offset = cm[label_key].get("tap_offset", None)

    if offset:
        tap_x = x + offset["x"]
        tap_y = y + offset["y"]
    else:
        tap_x = x + w // 2
        tap_y = y + h // 2

    log(f"TAP_LABEL_NOW: {label_key} at ({tap_x},{tap_y})", "ACTION")
    adb_shell(["input", "tap", str(tap_x), str(tap_y)])
----------./main.py----------------------
./main.py
#!/usr/bin/env python3
# main.py

import threading
import time
from datetime import datetime
import os
import cv2
import argparse

from core.watchdog import watchdog_process_check
from core.ss_capture import capture_and_save_screenshot
from core.automation_state import AUTOMATION
from core.state_detector import detect_state_and_overlays
from handlers.game_over_handler import handle_game_over
from handlers.home_screen_handler import handle_home_screen
from handlers.ad_gem_handler import handle_ad_gem, stop_blind_gem_tapper
from handlers.daily_gem_handler import handle_daily_gem
from utils.logger import log
from utils.wave_detector import get_wave_number_from_image, set_wave_hint  # <-- added set_wave_hint

SCREENSHOT_PATH = "screenshots/latest.png"

parser = argparse.ArgumentParser()
parser.add_argument("--no-restart", action="store_true", help="Disable auto restart on home screen")
parser.add_argument("--match-trace", action="store_true", help="Emit per-frame match logs from detector")
parser.add_argument("--status-interval", type=int, default=60, help="Seconds between status summaries (0=disable)")
parser.add_argument("--reset-wave-hint", action="store_true",
                    help="Reset the wave OCR monotonic/time-weighted hint at startup")  # <-- new flag
args = parser.parse_args()
AUTO_START_ENABLED = not args.no_restart
STATUS_INTERVAL = max(0, args.status_interval)
log(f"AUTO_START_ENABLED = {AUTO_START_ENABLED}", "DEBUG")

# If requested, clear the wave hint so new runs start fresh (monotonic scorer won't reject small values)
if args.reset_wave_hint:
    set_wave_hint(None)
    log("[WAVE] Reset wave hint at startup", "DEBUG")


def main():
    log("Starting main heartbeat loop.", level="INFO")
    threading.Thread(target=watchdog_process_check, daemon=True).start()

    last_ui_state = None
    last_secondary_states = None  # set[str] (non-menu only)
    last_menu = None              # str|None (mutually exclusive)
    last_overlays = None          # set[str]
    last_status_ts = 0.0
    try:
        while True:
            img = capture_and_save_screenshot(log_capture=False)
            if img is None:
                log("Failed to capture screenshot.", level="FAIL")
                time.sleep(2)
                continue

            # Detect current state from image
            detection = detect_state_and_overlays(img, log_matches=args.match_trace)
            new_state = detection["state"]           # e.g., "GAME_OVER", "HOME_SCREEN"
            menu = detection.get("menu") or None     # 'ATTACK_MENU', etc., or None
            secondary = set(detection.get("secondary_states") or [])  # already excludes menu
            overlays = set(detection.get("overlays") or [])

            # Primary state change
            if new_state != last_ui_state:
                log(f"UI state change: {last_ui_state} → {new_state}", "STATE")
                last_ui_state = new_state

            # Menu change (mutually exclusive)
            if menu != last_menu:
                if menu and not last_menu:
                    log(f"Menu opened: {menu}", "MATCH")
                elif last_menu and not menu:
                    log(f"Menu closed: {last_menu}", "MATCH")
                else:
                    log(f"Menu switched: {last_menu} → {menu}", "MATCH")
                last_menu = menu

            # Secondary state changes (non-menu)
            if last_secondary_states is None:
                if secondary:
                    log(f"Secondary states now: {sorted(secondary)}", "MATCH")
            else:
                sec_added = sorted(secondary - last_secondary_states)
                sec_removed = sorted(last_secondary_states - secondary)
                if sec_added:
                    log(f"Secondary states added: {sec_added}", "MATCH")
                if sec_removed:
                    log(f"Secondary states removed: {sec_removed}", "MATCH")
            last_secondary_states = secondary

            # Overlay changes
            if last_overlays is None:
                if overlays:
                    log(f"Overlays now: {sorted(overlays)}", "MATCH")
            else:
                added = sorted(overlays - last_overlays)
                removed = sorted(last_overlays - overlays)
                if added:
                    log(f"Overlays added: {added}", "MATCH")
                if removed:
                    log(f"Overlays removed: {removed}", "MATCH")
            last_overlays = overlays

            # Periodic status heartbeat (compute wave from the SAME img)
            now = time.time()
            if STATUS_INTERVAL and (now - last_status_ts >= STATUS_INTERVAL):
                wave = None
                if new_state == "RUNNING":
                    wave = get_wave_number_from_image(img)  # reuse current frame
                wave_str = str(wave) if wave is not None else "—"
                menu_str = menu or "—"
                sec_str = ", ".join(sorted(secondary)) if secondary else "—"
                ovl_str = ", ".join(sorted(overlays)) if overlays else "—"
                log(f"[STATUS] State={new_state} | Wave={wave_str} | Menu={menu_str} | Secondary=[{sec_str}] | Overlays=[{ovl_str}]", "INFO")
                last_status_ts = now

            # Handle known states
            if new_state == "GAME_OVER":
                log("Detected GAME_OVER. Executing handler.", "INFO")
                handle_game_over()
            elif new_state == "HOME_SCREEN":
                log("Detected HOME_SCREEN. Executing handler.", "INFO")
                handle_home_screen(restart_enabled=AUTO_START_ENABLED)

            if "AD_GEMS_AVAILABLE" in overlays:
                handle_ad_gem()
            if "DAILY_GEMS_AVAILABLE" in overlays:
                handle_daily_gem()

            time.sleep(5)  # Ctrl+C interrupts here immediately
    except KeyboardInterrupt:
        log("KeyboardInterrupt — shutting down.", "INFO")
    finally:
        stop_blind_gem_tapper()
        log("Exited cleanly.", "INFO")


if __name__ == "__main__":
    main()
----------./utils/logger.py----------------------
./utils/logger.py
# utils/logger.py
from datetime import datetime
import os

def log(msg, level="INFO"):
    """
    Write a timestamped log entry to stdout and append to logs/actions.log.

    Args:
        msg (str): The log message text.
        level (str, optional): Log level label (e.g., "INFO", "ERROR"). Defaults to "INFO".

    Side effects:
        - Prints to stdout.
        - Creates logs/ directory if missing.
        - Appends entry to logs/actions.log.

    Raises:
        OSError: If unable to create logs/ directory or write to the log file.
    """
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    entry = f"[{level} {timestamp}] {msg}"
    print(entry)

    os.makedirs("logs", exist_ok=True)
    with open("logs/actions.log", "a") as f:
        f.write(entry + "\n")
----------./utils/wave_detector.py----------------------
./utils/wave_detector.py
#!/usr/bin/env python3
# utils/wave_detector.py

from typing import Optional, Tuple, List, Dict, Any
import os
import re
import time

import cv2
import numpy as np

from core.ss_capture import capture_adb_screenshot
from core.clickmap_access import resolve_dot_path, get_clickmap
from utils.ocr_utils import ocr_number_with_fallback

# ROIs: digits-only first, full label as fallback
PRIMARY_DOT_PATH = "_shared_match_regions.wave_number_digits"
FALLBACK_DOT_PATH = "_shared_match_regions.wave_number"

# Preferences & limits
# Keep conservative ceiling to avoid selecting spurious large OCR reads
_DEFAULT_MAX_VALUE = 20000         # hard ceiling on accepted wave values
_DEFAULT_RATE_PER_MIN = 10.0       # expected waves per minute
_DEFAULT_TOLERANCE = 20            # ±window around expected

# Module-level hint + timestamp (no main.py change required)
_LAST_WAVE_SEEN: Optional[int] = None
_LAST_WAVE_TS: Optional[float] = None

# ---------------------------- hint helpers ------------------------------------

def set_wave_hint(val: Optional[int], ts: Optional[float] = None) -> None:
    """
    Seed/override the last-wave hint and timestamp used for proximity scoring.
    If ts is None, uses current time.
    """
    global _LAST_WAVE_SEEN, _LAST_WAVE_TS
    _LAST_WAVE_SEEN = val
    _LAST_WAVE_TS = (time.time() if ts is None else float(ts))

def get_wave_hint() -> Optional[int]:
    return _LAST_WAVE_SEEN

# ---------------------------- helpers: OCR debug ------------------------------

def _tess_info() -> str:
    try:
        import pytesseract
        try:
            v = pytesseract.get_tesseract_version()
            return f"pytesseract OK, tesseract {v}"
        except Exception as e:
            return f"pytesseract OK, version check failed: {e!r}"
    except Exception as e:
        return f"pytesseract import FAILED: {e!r}"

def _ocr_probe(gray_or_bin: np.ndarray, *, psm_text: int = 7, psm_digits: int = 7) -> Dict[str, Any]:
    out: Dict[str, Any] = {}
    try:
        import pytesseract
    except Exception as e:
        out["error"] = f"pytesseract import failed: {e!r}"
        return out

    rgb = cv2.cvtColor(gray_or_bin, cv2.COLOR_GRAY2RGB)

    try:
        data_text = pytesseract.image_to_data(rgb, config=f"--psm {psm_text}", output_type=pytesseract.Output.DICT)
        toks = list(zip(data_text.get("text", []), data_text.get("conf", [])))
        out["image_to_data(psm_text)"] = {"n_tokens": len(toks), "tokens": toks[:50]}
    except Exception as e:
        out["image_to_data(psm_text)"] = f"ERROR: {e!r}"

    try:
        plain = pytesseract.image_to_string(rgb, config=f"--psm {psm_text}")
        out["image_to_string(psm_text)"] = plain
    except Exception as e:
        out["image_to_string(psm_text)"] = f"ERROR: {e!r}"

    try:
        data_digits = pytesseract.image_to_data(
            rgb,
            config=f"--psm {psm_digits} -c tessedit_char_whitelist=0123456789",
            output_type=pytesseract.Output.DICT,
        )
        d_toks = list(zip(data_digits.get("text", []), data_digits.get("conf", [])))
        out["image_to_data(digits)"] = {"n_tokens": len(d_toks), "tokens": d_toks[:50]}
    except Exception as e:
        out["image_to_data(digits)"] = f"ERROR: {e!r}"

    subs = []
    try:
        for t, c in toks:
            if not t:
                continue
            for m in re.finditer(r"\d{1,9}", t):
                subs.append((m.group(0), c))
    except Exception:
        pass
    out["numeric_substrings_from_tokens"] = subs[:50]
    return out

# ---------------------------- helpers: ROI / crops ----------------------------

def _get_bbox(dot_path: str) -> Tuple[int, int, int, int]:
    cm = get_clickmap()
    entry = resolve_dot_path(dot_path, cm)
    if not entry or "match_region" not in entry:
        raise KeyError(f"Missing match_region at dot_path: {dot_path}")
    r = entry["match_region"]
    return int(r["x"]), int(r["y"]), int(r["w"]), int(r["h"])

def _crop(img: np.ndarray, bbox: Tuple[int, int, int, int]) -> np.ndarray:
    x, y, w, h = bbox
    H, W = img.shape[:2]
    x2, y2 = min(x + w, W), min(y + h, H)
    x1, y1 = max(0, x), max(0, y)
    if x1 >= x2 or y1 >= y2:
        raise ValueError(f"Invalid crop bbox after clamping: {x1,y1,x2,y2}")
    return img[y1:y2, x1:x2]

def _save_overlay(img_bgr: np.ndarray, dot_path: str, out_path: str) -> None:
    try:
        x, y, w, h = _get_bbox(dot_path)
        vis = img_bgr.copy()
        cv2.rectangle(vis, (x, y), (x + w, y + h), (0, 255, 0), 2)
        cv2.imwrite(out_path, vis)
        print(f"[DEBUG] Saved overlay to {out_path}")
    except Exception as e:
        print(f"[ERROR] Failed to save overlay: {e}")

# ---------------------------- FAST PATH (default) -----------------------------

def _fast_variants_from_crop(crop_bgr: np.ndarray) -> List[Tuple[str, np.ndarray]]:
    """
    Minimal & reliable set:
      - Otsu + small close (2x2) at 1.0x and 1.8x
      - Both polarities
    """
    gray = cv2.cvtColor(crop_bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.convertScaleAbs(gray, alpha=1.6, beta=0)  # contrast boost
    _t, thr = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    k = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 2))
    base = cv2.morphologyEx(thr, cv2.MORPH_CLOSE, k, iterations=1)

    variants: List[Tuple[str, np.ndarray]] = []
    for pol_name, img in (("otsu_close", base), ("otsu_close_inv", cv2.bitwise_not(base))):
        variants.append((f"{pol_name}_x1.0", img))
        up = cv2.resize(img, None, fx=1.8, fy=1.8, interpolation=cv2.INTER_CUBIC)
        variants.append((f"{pol_name}_x1.8", up))
    return variants

def _score(
    val: Optional[int],
    conf: float,
    *,
    last_wave: Optional[int],
    expected: Optional[float],
    tolerance: int,
    max_value: int,
) -> Tuple[int, int, float, float, int]:
    """
    Score candidates for max() selection.

    Returns tuple ordered by importance:
      (valid_flag, proximity_bucket, confidence, proximity_tiebreak, digits_len)

    - Discards decreases: if last_wave is set and val < last_wave -> invalid.
    - valid_flag = 1 if val is not None and val < max_value else 0.
    - proximity_bucket (if expected available):
        2 if |val - expected| <= tolerance
        1 if |val - expected| <= 2*tolerance
        0 otherwise
      Neutral (1) when no expected available.
    - proximity_tiebreak: higher is better; uses -abs(val - expected) (0 if expected is None).
    - digits_len: prefer more digits as a final tie-break to avoid single-digit misreads.
    """
    # Baseline (None) should outrank any invalid candidate but lose to any valid one.
    # Use valid_flag tiers: 2 = valid, 1 = none/baseline, 0 = invalid.
    if val is None:
        return (1, 0, -1.0, -1e9, 0)

    # Monotonic: never go down
    if last_wave is not None and val < last_wave:
        return (0, 0, -1.0, -1e9, 0)

    # Only values strictly below max_value are considered valid.
    valid_flag = 2 if val < max_value else 0

    if expected is None:
        prox_bucket = 1  # neutral
        prox_tb = 0.0
    else:
        delta = abs(val - expected)
        if delta <= tolerance:
            prox_bucket = 2
        elif delta <= 2 * tolerance:
            prox_bucket = 1
        else:
            prox_bucket = 0
        prox_tb = -float(delta)

    digits_len = len(str(val))
    return (valid_flag, prox_bucket, float(conf), prox_tb, digits_len)

def _detect_quick(
    img_bgr: np.ndarray,
    dot_path: str,
    *,
    verbose: bool,
    last_wave: Optional[int],
    expected: Optional[float],
    tolerance: int,
    max_value: int,
) -> Tuple[Optional[int], float, Optional[str], Optional[np.ndarray]]:
    """Try the fast variants on the full ROI only."""
    try:
        bbox = _get_bbox(dot_path)
    except Exception as e:
        if verbose:
            print(f"[DEBUG] resolve bbox failed for {dot_path}: {e}")
        return None, -1.0, None, None

    crop = _crop(img_bgr, bbox)
    best_val, best_conf, best_tag, best_img = None, -1.0, None, None
    best_score = _score(None, -1.0, last_wave=last_wave, expected=expected, tolerance=tolerance, max_value=max_value)

    for tag, var in _fast_variants_from_crop(crop):
        val, conf, _ = ocr_number_with_fallback(var, psm_digits=7, psm_text=7)
        cand_score = _score(val, conf, last_wave=last_wave, expected=expected, tolerance=tolerance, max_value=max_value)
        if verbose:
            h, w = var.shape[:2]
            print(f"[FAST] {dot_path}/{tag}: size={w}x{h} -> val={val} conf={conf} score={cand_score}")
        if cand_score > best_score:
            best_score, best_val, best_conf, best_tag, best_img = cand_score, val, conf, tag, var.copy()

    if verbose:
        print(f"[FAST] best={best_tag} -> value={best_val} conf={best_conf} score={best_score}")
    return best_val, best_conf, best_tag and f"{dot_path}/{best_tag}", best_img

# ----------------------------- HEAVY SWEEP (fallback/debug) -------------------

def _bins_from_crop(crop_bgr: np.ndarray) -> List[Tuple[str, np.ndarray]]:
    """Broader set of binarizations for difficult samples."""
    gray = cv2.cvtColor(crop_bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.convertScaleAbs(gray, alpha=1.6, beta=0)

    bins: List[Tuple[str, np.ndarray]] = []

    # Adaptive MEAN & GAUSSIAN
    for name, method in [("mean", cv2.ADAPTIVE_THRESH_MEAN_C), ("gauss", cv2.ADAPTIVE_THRESH_GAUSSIAN_C)]:
        thr = cv2.adaptiveThreshold(gray, 255, method, cv2.THRESH_BINARY, 31, 5)
        bins.append((f"{name}", thr))
        k = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 2))
        bins.append((f"{name}_close", cv2.morphologyEx(thr, cv2.MORPH_CLOSE, k, iterations=1)))

    # Otsu
    _t, otsu = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    bins.append(("otsu", otsu))
    k = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 2))
    bins.append(("otsu_close", cv2.morphologyEx(otsu, cv2.MORPH_CLOSE, k, iterations=1)))

    # Inversions
    invs = []
    for n, b in bins:
        invs.append((f"{n}_inv", cv2.bitwise_not(b)))
    bins.extend(invs)
    return bins

def _scaled_variants(bin_img: np.ndarray) -> List[Tuple[str, np.ndarray]]:
    out = []
    for s in (1.0, 1.8, 2.2):
        if s == 1.0:
            out.append((f"x{s:.1f}", bin_img))
        else:
            out.append((f"x{s:.1f}", cv2.resize(bin_img, None, fx=s, fy=s, interpolation=cv2.INTER_CUBIC)))
    return out

def _make_crops(full: np.ndarray) -> List[Tuple[str, np.ndarray]]:
    """Full / left-trim / left-trim + right-shave."""
    H, W = full.shape[:2]
    left_trim = int(0.35 * W)
    right_shave = int(0.10 * W)
    c0 = ("full", full)
    c1 = ("left_trim", full[:, left_trim:] if left_trim < W - 1 else full)
    c2 = ("left_trim_right_shave", c1[1][:, : max(1, c1[1].shape[1] - right_shave)] if c1[1].shape[1] > 1 else c1[1])
    return [c0, c1, c2]

def _detect_heavy(
    img_bgr: np.ndarray,
    dot_path: str,
    *,
    verbose: bool,
    dump_dir: Optional[str],
    debug_out: Optional[str],
    last_wave: Optional[int],
    expected: Optional[float],
    tolerance: int,
    max_value: int,
) -> Tuple[Optional[int], float, Optional[str], Optional[np.ndarray]]:
    try:
        bbox = _get_bbox(dot_path)
    except Exception as e:
        if verbose:
            print(f"[DEBUG] resolve bbox failed for {dot_path}: {e}")
        return None, -1.0, None, None

    full = _crop(img_bgr, bbox)
    if verbose:
        print(f"[HEAVY] dot_path={dot_path} bbox={bbox} crop={full.shape[1]}x{full.shape[0]}")

    if dump_dir:
        os.makedirs(dump_dir, exist_ok=True)
        cv2.imwrite(os.path.join(dump_dir, f"{os.path.basename(dot_path)}_full_raw.png"), full)

    best_val, best_conf, best_tag, best_img = None, -1.0, None, None
    best_score = _score(None, -1.0, last_wave=last_wave, expected=expected, tolerance=tolerance, max_value=max_value)

    for cname, crop in _make_crops(full):
        for bname, bimg in _bins_from_crop(crop):
            for sname, simg in _scaled_variants(bimg):
                tag = f"{cname}_{bname}_{sname}"
                val, conf, _ = ocr_number_with_fallback(simg, psm_digits=7, psm_text=7)
                cand_score = _score(val, conf, last_wave=last_wave, expected=expected, tolerance=tolerance, max_value=max_value)

                if verbose:
                    h, w = simg.shape[:2]
                    print(f"[HEAVY] {dot_path}/{tag}: size={w}x{h} -> val={val} conf={conf} score={cand_score}")

                if dump_dir:
                    cv2.imwrite(os.path.join(dump_dir, f"{os.path.basename(dot_path)}_{tag}.png"), simg)
                    probes = _ocr_probe(simg, psm_text=7, psm_digits=7)
                    with open(os.path.join(dump_dir, f"{os.path.basename(dot_path)}_{tag}.txt"), "w", encoding="utf-8") as f:
                        f.write(f"Tesseract: {_tess_info()}\n")
                        f.write(f"Variant: {tag} size={simg.shape[1]}x{simg.shape[0]} val={val} conf={conf} score={cand_score}\n")
                        f.write(repr(probes))

                if cand_score > best_score:
                    best_score, best_val, best_conf, best_tag, best_img = cand_score, val, conf, f"{dot_path}/{tag}", simg.copy()

    if verbose:
        print(f"[HEAVY] best={best_tag} -> value={best_val} conf={best_conf} score={best_score}")
    if debug_out and best_img is not None:
        cv2.imwrite(debug_out, best_img)
    return best_val, best_conf, best_tag, best_img

# ------------------------ PROGRAMMATIC API (with time-based scoring) ----------

def detect_wave_number_from_image(
    img_bgr: np.ndarray,
    *,
    primary_dot_path: str = PRIMARY_DOT_PATH,
    fallback_dot_path: str = FALLBACK_DOT_PATH,
    use_heavy: bool = False,
    verbose: bool = False,
    dump_dir: Optional[str] = None,
    debug_out: Optional[str] = None,
    rate_per_min: float = _DEFAULT_RATE_PER_MIN,
    tolerance: int = _DEFAULT_TOLERANCE,
    max_value: int = _DEFAULT_MAX_VALUE,
) -> Tuple[Optional[int], float]:
    """
    Programmatic entrypoint used by main.py.
    - Monotonic: never accept decreases vs last seen wave.
    - Time-weighted proximity: prefer values near last_wave + rate_per_min * Δt(min) within ±tolerance.
    - Fast path on primary then fallback; heavy sweep if asked or still None.
    Returns (value, confidence). Updates the module hint on success.
    """
    global _LAST_WAVE_SEEN, _LAST_WAVE_TS
    now = time.time()
    last_wave = _LAST_WAVE_SEEN
    expected = None
    if last_wave is not None and _LAST_WAVE_TS is not None:
        dt_min = max(0.0, (now - _LAST_WAVE_TS) / 60.0)
        expected = last_wave + rate_per_min * dt_min

    # Fast: primary
    val, conf, _tag, best_img = _detect_quick(
        img_bgr,
        primary_dot_path,
        verbose=verbose,
        last_wave=last_wave,
        expected=expected,
        tolerance=tolerance,
        max_value=max_value,
    )
    used = primary_dot_path

    # Fast: fallback
    if val is None and fallback_dot_path:
        if verbose:
            print(f"[DEBUG] Primary ROI {primary_dot_path} failed -> trying fallback {fallback_dot_path}")
        val, conf, _tag, best_img = _detect_quick(
            img_bgr,
            fallback_dot_path,
            verbose=verbose,
            last_wave=last_wave,
            expected=expected,
            tolerance=tolerance,
            max_value=max_value,
        )
        if val is not None:
            used = fallback_dot_path

    # Heavy if asked or still None
    if use_heavy or val is None:
        for roi in (primary_dot_path, fallback_dot_path):
            hv_val, hv_conf, _hv_tag, hv_img = _detect_heavy(
                img_bgr,
                roi,
                verbose=verbose,
                dump_dir=dump_dir,
                debug_out=debug_out,
                last_wave=last_wave,
                expected=expected,
                tolerance=tolerance,
                max_value=max_value,
            )
            if _score(hv_val, hv_conf, last_wave=last_wave, expected=expected, tolerance=tolerance, max_value=max_value) > \
               _score(val, conf, last_wave=last_wave, expected=expected, tolerance=tolerance, max_value=max_value):
                val, conf, best_img, used = hv_val, hv_conf, hv_img, roi

    # Save winner image if requested
    if debug_out and best_img is not None:
        cv2.imwrite(debug_out, best_img)

    # Update hint on success (monotonic already enforced in scoring)
    if val is not None:
        _LAST_WAVE_SEEN = val
        _LAST_WAVE_TS = now

    return val, conf

def detect_wave_number(
    *,
    primary_dot_path: str = PRIMARY_DOT_PATH,
    fallback_dot_path: str = FALLBACK_DOT_PATH,
    use_heavy: bool = False,
    verbose: bool = False,
    dump_dir: Optional[str] = None,
    debug_out: Optional[str] = None,
    rate_per_min: float = _DEFAULT_RATE_PER_MIN,
    tolerance: int = _DEFAULT_TOLERANCE,
    max_value: int = _DEFAULT_MAX_VALUE,
) -> Tuple[Optional[int], float]:
    """Capture via ADB and run detection."""
    img = capture_adb_screenshot()
    if img is None:
        raise RuntimeError("Failed to capture screenshot.")
    return detect_wave_number_from_image(
        img,
        primary_dot_path=primary_dot_path,
        fallback_dot_path=fallback_dot_path,
        use_heavy=use_heavy,
        verbose=verbose,
        dump_dir=dump_dir,
        debug_out=debug_out,
        rate_per_min=rate_per_min,
        tolerance=tolerance,
        max_value=max_value,
    )

def get_wave_number(dot_path: str = PRIMARY_DOT_PATH) -> Optional[int]:
    """
    Back-compat convenience: capture screenshot and return just the integer wave (or None).
    The provided dot_path is treated as the primary; fallback remains the default.
    """
    val, _conf = detect_wave_number(primary_dot_path=dot_path, fallback_dot_path=FALLBACK_DOT_PATH)
    return val

def get_wave_number_from_image(img_bgr: np.ndarray, dot_path: str = PRIMARY_DOT_PATH) -> Optional[int]:
    """
    Back-compat convenience: return just the integer wave from a provided image.
    The provided dot_path is treated as the primary; fallback remains the default.
    """
    val, _conf = detect_wave_number_from_image(img_bgr, primary_dot_path=dot_path, fallback_dot_path=FALLBACK_DOT_PATH)
    return val

# ---------------------------------- CLI --------------------------------------

def main():
    """
    Fast path by default:
      - digits ROI (PRIMARY_DOT_PATH): Otsu+close at 1.0x / 1.8x, both polarities.
      - if None, fallback ROI with the same variants.
    Heavy sweep:
      - only if both fast paths fail OR when --dump-candidates is provided.

    Time-based scoring:
      - Monotonic (never decreases).
      - Prefer near last_wave + rate_per_min * Δt(min) within ±tolerance.
    """
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--dot-path", default=PRIMARY_DOT_PATH, help=f"Primary ROI (default {PRIMARY_DOT_PATH})")
    parser.add_argument("--fallback-dot-path", default=FALLBACK_DOT_PATH, help=f"Fallback ROI (default {FALLBACK_DOT_PATH})")
    parser.add_argument("--image", default=None, help="Path to an image to OCR (else capture via ADB)")
    parser.add_argument("--save-input", default=None, help="Save the raw input image here")
    parser.add_argument("--save-overlay", default=None, help="Save overlay for the ROI that produced the result (or primary if none)")
    parser.add_argument("--debug-out", default=None, help="Save winner bin image here")
    parser.add_argument("--verbose", action="store_true", help="Print detailed debug info")
    parser.add_argument("--dump-candidates", default=None, help="Directory to save heavy-sweep variants and OCR probes")
    parser.add_argument("--rate-per-min", type=float, default=_DEFAULT_RATE_PER_MIN, help="Expected waves per minute for time-based scoring")
    parser.add_argument("--tolerance", type=int, default=_DEFAULT_TOLERANCE, help="±window around expected value")
    parser.add_argument("--max-value", type=int, default=_DEFAULT_MAX_VALUE, help="Hard ceiling on accepted wave values")
    args = parser.parse_args()

    # load image
    if args.image:
        img = cv2.imread(args.image)
        if img is None:
            print(f"Failed to read image at: {args.image}")
            return
    else:
        img = capture_adb_screenshot()
        if img is None:
            raise RuntimeError("Failed to capture screenshot.")

    if args.save_input:
        try:
            cv2.imwrite(args.save_input, img)
            print(f"[DEBUG] Saved input image to {args.save_input}")
        except Exception as e:
            print(f"[ERROR] Failed to save input image: {e}")

    if args.verbose:
        print(f"[DEBUG] Tesseract: {_tess_info()}")

    val, conf = detect_wave_number_from_image(
        img,
        primary_dot_path=args.dot_path,
        fallback_dot_path=args.fallback_dot_path,
        use_heavy=(args.dump_candidates is not None),
        verbose=args.verbose,
        dump_dir=args.dump_candidates,
        debug_out=args.debug_out,
        rate_per_min=args.rate_per_min,
        tolerance=args.tolerance,
        max_value=args.max_value,
    )

    if args.save_overlay:
        _save_overlay(img, args.dot_path, args.save_overlay)

    if val is None:
        print("Wave number: <not detected>")
    else:
        print(f"Wave number: {val} (conf={conf:.1f})")

if __name__ == "__main__":
    main()
----------./utils/previous_wave.py----------------------
./utils/previous_wave.py
#!/usr/bin/env python3
# utils/previous_wave.py

import os
import re
import glob
from datetime import datetime
from typing import Optional

import cv2
import numpy as np

from utils.ocr_utils import preprocess_binary, ocr_text

_CUR_LINE_RE = re.compile(r'^\s*Wave\s+(\d{1,6})\b', re.IGNORECASE | re.MULTILINE)
_HI_LINE_RE  = re.compile(r'^\s*Highest\s*Wave[: ]+\s*(\d{1,6})\b', re.IGNORECASE | re.MULTILINE)

# ---------- File selection ----------

_TS_RE = re.compile(r"Game(\d{8})_(\d{4})_game_stats\.png$")  # GameYYYYMMDD_HHMM_game_stats.png

def _parse_ts_from_name(path: str) -> Optional[datetime]:
    m = _TS_RE.search(os.path.basename(path))
    if not m:
        return None
    ymd, hm = m.groups()
    try:
        return datetime.strptime(ymd + hm, "%Y%m%d%H%M")
    except ValueError:
        return None

def _latest_game_stats_image(matches_dir: str = "screenshots/matches") -> Optional[str]:
    candidates = glob.glob(os.path.join(matches_dir, "Game*_game_stats.png"))
    if not candidates:
        return None
    # Prefer filename timestamp; fallback to mtime
    with_ts = [(p, _parse_ts_from_name(p)) for p in candidates]
    with_ts.sort(key=lambda t: (t[1] is None, t[1] or datetime.fromtimestamp(os.path.getmtime(t[0]))), reverse=True)
    return with_ts[0][0]


# ---------- Parsing ----------

def _extract_current_and_highest(text: str):
    cur = None
    hi = None

    m_cur = _CUR_LINE_RE.search(text)
    if m_cur:
        try: cur = int(m_cur.group(1))
        except ValueError: pass

    m_hi = _HI_LINE_RE.search(text)
    if m_hi:
        try: hi = int(m_hi.group(1))
        except ValueError: pass

    return cur, hi


# ---------- Public API ----------

def get_previous_run_wave(matches_dir: str = "screenshots/matches") -> Optional[int]:
    """
    Load the latest 'GameYYYYMMDD_HHMM_game_stats.png' under matches_dir,
    OCR the text, and return the parsed current Wave number (or None on failure).
    """
    path = _latest_game_stats_image(matches_dir)
    if not path:
        return None
    img = cv2.imread(path)
    if img is None:
        return None

    # Mirror the original preprocessing behavior (invert + slightly larger block/C)
    bin_img = preprocess_binary(img, alpha=1.6, block=35, C=7, close=(2, 2), invert=True, choose_best=False)
    text = ocr_text(bin_img, psm=6)

    cur, _hi = _extract_current_and_highest(text)
    return cur


def main():
    """CLI: prints previous run's wave; supports --matches-dir."""
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--matches-dir", default="screenshots/matches", help="Directory containing Game*_game_stats.png")
    args = parser.parse_args()

    val = get_previous_run_wave(matches_dir=args.matches_dir)
    print("Previous run wave:", "<none>" if val is None else val)


if __name__ == "__main__":
    main()
----------./utils/ocr_utils.py----------------------
./utils/ocr_utils.py
# utils/ocr_utils.py
from typing import Optional, Tuple
import cv2
import numpy as np
import re

# Optional OCR backend
try:
    import pytesseract
    _HAS_TESS = True
except Exception:
    _HAS_TESS = False


def _to_rgb(img: np.ndarray) -> np.ndarray:
    """Accept 1-channel (gray/binary) or 3-channel BGR and return RGB."""
    if img is None:
        return None
    if img.ndim == 2:
        return cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)
    return cv2.cvtColor(img, cv2.COLOR_BGR2RGB)


def preprocess_binary(
    img_bgr: np.ndarray,
    *,
    alpha: float = 1.6,
    block: int = 31,
    C: int = 5,
    close: Tuple[int, int] = (2, 2),
    invert: bool = False,
    choose_best: bool = False
) -> np.ndarray:
    """
    Convert BGR to a high-contrast binary image to favor OCR.
    """
    gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)
    gray = cv2.convertScaleAbs(gray, alpha=alpha, beta=0)

    thr = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                cv2.THRESH_BINARY, block, C)
    thr_inv = cv2.bitwise_not(thr)

    if choose_best:
        use_inv = (np.count_nonzero(thr_inv == 0) > np.count_nonzero(thr == 0))
        bin_img = thr_inv if use_inv else thr
    else:
        bin_img = thr_inv if invert else thr

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, close)
    bin_img = cv2.morphologyEx(bin_img, cv2.MORPH_CLOSE, kernel, iterations=1)
    return bin_img


def ocr_text(bin_img: np.ndarray, *, psm: int = 6) -> str:
    """
    OCR arbitrary text from a binary/gray/BGR image. Returns empty string if Tesseract not available.
    """
    if not _HAS_TESS:
        return ""
    rgb = _to_rgb(bin_img)
    cfg = f"--psm {psm}"
    return pytesseract.image_to_string(rgb, config=cfg)


def ocr_text_and_conf(bin_img: np.ndarray, *, psm: int = 7) -> Tuple[str, float]:
    """
    OCR text and return (joined_text, avg_conf). avg_conf=-1.0 if unavailable.
    """
    if not _HAS_TESS:
        return "", -1.0
    rgb = _to_rgb(bin_img)
    data = pytesseract.image_to_data(rgb, config=f"--psm {psm}", output_type=pytesseract.Output.DICT)
    toks = data.get("text", [])
    confs = data.get("conf", [])
    kept, kconf = [], []
    for t, c in zip(toks, confs):
        if not t:
            continue
        kept.append(t)
        try:
            fc = float(c)
            if fc >= 0:
                kconf.append(fc)
        except Exception:
            pass
    txt = " ".join(kept).strip()
    avg_conf = float(np.mean(kconf)) if kconf else -1.0
    return txt, avg_conf


def ocr_digits(
    bin_img: np.ndarray, *,
    psm: int = 7,
    whitelist: str = "0123456789",
    combine: str = "concat"  # "concat" (legacy) or "best"
) -> Tuple[Optional[int], float, str]:
    """
    OCR digits from a binary image.

    Returns:
        (value:int|None, avg_conf:float, raw_text:str)
        avg_conf = -1.0 when unavailable.

    combine:
        - "concat": concatenate all numeric tokens (legacy behavior).
        - "best": choose the single best numeric token (prefer longer, then higher confidence).
    """
    if not _HAS_TESS:
        return None, -1.0, ""

    rgb = _to_rgb(bin_img)
    config = f"--psm {psm} -c tessedit_char_whitelist={whitelist}"
    data = pytesseract.image_to_data(rgb, config=config, output_type=pytesseract.Output.DICT)

    tokens = []
    confs = []
    for txt, conf in zip(data.get("text", []), data.get("conf", [])):
        if txt and re.fullmatch(r"\d+", txt):
            tokens.append(txt)
            try:
                c = float(conf)
                if c >= 0:
                    confs.append(c)
            except Exception:
                pass

    if not tokens:
        return None, -1.0, ""

    if combine == "best":
        # Prefer longer tokens; tie-break by confidence
        pairs = []
        # align confs length if missing
        conf_iter = iter(confs + [-1.0] * (len(tokens) - len(confs)))
        for t in tokens:
            try:
                c = next(conf_iter)
            except StopIteration:
                c = -1.0
            pairs.append((t, c))
        pairs.sort(key=lambda p: (len(p[0]), p[1]))
        best_txt, best_conf = pairs[-1]
        try:
            return int(best_txt), float(best_conf), best_txt
        except ValueError:
            return None, -1.0, best_txt

    # Legacy: concatenate all digit tokens
    raw_text = "".join(tokens)
    try:
        value = int(raw_text)
    except ValueError:
        return None, -1.0, raw_text
    avg_conf = float(np.mean(confs)) if confs else -1.0
    return value, avg_conf, raw_text


def ocr_number_with_fallback(
    bin_img: np.ndarray, *, psm_digits: int = 7, psm_text: int = 7
) -> Tuple[Optional[int], float, str]:
    """
    Robust integer OCR:
      A) Scan generic word boxes for any numeric substring (handles merged tokens like 'Wave24')
      B) If none, try digits-only OCR (single best token)
      C) If still none, run plain text OCR and regex the first integer

    Returns (value, conf, raw_text). conf=-1.0 on C) fallback.
    """
    if _HAS_TESS:
        # A) generic token scan
        rgb = _to_rgb(bin_img)
        data = pytesseract.image_to_data(rgb, config=f"--psm {psm_text}", output_type=pytesseract.Output.DICT)
        best_val, best_len, best_conf, best_raw = None, -1, -1.0, ""
        for txt, conf in zip(data.get("text", []) or [], data.get("conf", []) or []):
            if not txt:
                continue
            for m in re.finditer(r"\d{1,9}", txt):
                s = m.group(0)
                try:
                    v = int(s)
                except Exception:
                    continue
                # prefer longer numbers; tie-break on confidence
                c = -1.0
                try:
                    c = float(conf)
                except Exception:
                    pass
                if len(s) > best_len or (len(s) == best_len and c > best_conf):
                    best_val, best_len, best_conf, best_raw = v, len(s), c, txt
        if best_val is not None:
            return best_val, best_conf, best_raw

    # B) digits-only, best token
    val, conf, raw_digits = ocr_digits(bin_img, psm=psm_digits, combine="best")
    if val is not None:
        return val, conf, raw_digits

    # C) plain text OCR, regex first integer
    txt = ocr_text(bin_img, psm=psm_text) or ""
    m = re.search(r"(\d{1,9})", txt)
    if m:
        try:
            return int(m.group(1)), -1.0, txt
        except Exception:
            return None, -1.0, txt
    return None, -1.0, txt
----------./utils/coin_detector.py----------------------
./utils/coin_detector.py
#!/usr/bin/env python3
# utils/coin_detector.py

from __future__ import annotations
from typing import Optional, Tuple
from decimal import Decimal, getcontext
import re

import cv2
import numpy as np

from core.clickmap_access import resolve_dot_path, get_clickmap
from utils.ocr_utils import preprocess_binary

# Use enough precision for big idle numbers
getcontext().prec = 28

# Compact suffix multipliers (case-insensitive)
_SUFFIX = {
    "K": Decimal("1e3"),
    "M": Decimal("1e6"),
    "B": Decimal("1e9"),
    "T": Decimal("1e12"),
    "q": Decimal("1e15"),   # some UIs use 'q' or 'Q' for quadrillion
    "Q": Decimal("1e15"),
    # Add more if the game goes beyond (e.g., 's' for sextillion, etc.)
}

_ALLOWED_CHARS_RE = re.compile(r"[0-9\.\,\s\$\w]+")

def _get_bbox(dot_path: str) -> Tuple[int, int, int, int]:
    cm = get_clickmap()
    entry = resolve_dot_path(dot_path, cm)
    if not entry or "match_region" not in entry:
        raise KeyError(f"Missing match_region at dot_path: {dot_path}")
    r = entry["match_region"]
    return int(r["x"]), int(r["y"]), int(r["w"]), int(r["h"])

def _crop(img, bbox):
    x, y, w, h = bbox
    H, W = img.shape[:2]
    return img[max(0,y):min(y+h,H), max(0,x):min(x+w,W)]

def parse_compact_number(text: str) -> Optional[Decimal]:
    """
    Parse strings like: "$862.28M", "862.28M", "862,280,000", "3.43T", "3.43 Q"
    Returns Decimal or None if parse fails.
    """
    if not text:
        return None

    # Keep only allowed characters, normalize spaces/commas
    s = "".join(ch for ch in text if _ALLOWED_CHARS_RE.match(ch))
    s = s.replace(",", "").replace("$", "").strip()

    # Extract number and optional suffix
    # Examples: "862.28M", "3.43 T", "203.43T"
    m = re.search(r"([0-9]+(?:\.[0-9]+)?)\s*([A-Za-z])?$", s)
    if not m:
        return None

    num_s = m.group(1)
    suf = m.group(2) if m.group(2) is not None else ""
    try:
        base = Decimal(num_s)
    except Exception:
        return None

    if not suf:
        return base
    mult = _SUFFIX.get(suf, None)
    if mult is None:
        # Unknown suffix -> treat as plain number
        return base
    return base * mult

def format_compact_decimal(value: Decimal) -> str:
    """
    Format a Decimal back into a compact string with suffix.
    """
    if value is None:
        return "—"
    abs_val = value.copy_abs()
    for suf, mult in [("Q", Decimal("1e15")), ("T", Decimal("1e12")), ("B", Decimal("1e9")), ("M", Decimal("1e6")), ("K", Decimal("1e3"))]:
        if abs_val >= mult:
            out = (value / mult).quantize(Decimal("0.01"))
            return f"${out}{suf}"
    out = value.quantize(Decimal("0.01"))
    return f"${out}"

def _ocr_coins_bin(bin_img) -> Tuple[Optional[Decimal], float, str]:
    """
    Use Tesseract word boxes to get a reasonable confidence and join tokens.
    We avoid strict whitelists so unit letters (M/B/T) survive.
    """
    try:
        import pytesseract
    except Exception:
        return None, -1.0, ""

    rgb = cv2.cvtColor(bin_img, cv2.COLOR_GRAY2RGB)
    data = pytesseract.image_to_data(rgb, config="--psm 7", output_type=pytesseract.Output.DICT)

    toks = data.get("text", [])
    confs = data.get("conf", [])
    # Keep tokens that contain allowed chars (digits, letters for suffix)
    kept = []
    kept_conf = []
    for t, c in zip(toks, confs):
        if not t:
            continue
        if _ALLOWED_CHARS_RE.fullmatch(t):
            kept.append(t)
            try:
                fc = float(c)
                if fc >= 0:
                    kept_conf.append(fc)
            except Exception:
                pass

    raw = " ".join(kept).strip()
    value = parse_compact_number(raw)
    avg_conf = float(np.mean(kept_conf)) if kept_conf else -1.0
    return value, avg_conf, raw

def get_coins_from_image(img_bgr,
                         dot_path: str = "_shared_match_regions.coins_text",
                         debug_out: Optional[str] = None) -> Tuple[Optional[Decimal], float]:
    """
    Crop the coin region from the given image and OCR it into a Decimal.
    Returns (value, avg_conf). avg_conf = -1.0 if unavailable.
    """
    bbox = _get_bbox(dot_path)
    crop = _crop(img_bgr, bbox)

    # Reuse your OCR preprocessing
    bin_img = preprocess_binary(crop, alpha=1.6, block=31, C=5, close=(2, 2), invert=False, choose_best=True)

    if debug_out:
        cv2.imwrite(debug_out, bin_img)

    val, conf, _raw = _ocr_coins_bin(bin_img)
    return val, conf
----------./utils/template_matcher.py----------------------
./utils/template_matcher.py
# utils/template_matcher.py
# DEPRECATED SHIM — use core.matcher instead.
# Kept to avoid breaking existing imports; safe to remove once callers are updated.

from core.matcher import _match_entry as match_region, detect_floating_gem_square  # re-export

__all__ = ["match_region", "detect_floating_gem_square"]
----------./handlers/game_over_handler_no_ss.py----------------------
./handlers/game_over_handler_no_ss.py
# handlers/game_over_handler.py
from utils.logger import log
from core.ss_capture import capture_adb_screenshot
from core.automation_state import AUTOMATION, ExecMode
from core.clickmap_access import tap_now, swipe_now
from core.label_tapper import tap_label_now
import time
import os
import cv2

def handle_game_over():
    """
    Handle the GAME OVER flow: capture stats, close stats, and retry or pause.

    Workflow:
      1) Save initial game-over stats screenshot.
      2) Tap "More Stats"; if it fails, abort handler.
      3) Swipe to top, save screenshot; swipe to page 2, save; swipe to bottom, save.
      4) Close "More Stats"; if it fails, abort handler.
      5) Based on AUTOMATION.mode:
         - WAIT: loop until mode changes.
         - HOME: log and exit (not implemented beyond logging).
         - else: tap "Retry"; if it fails, abort handler.

    Returns:
        None — mission/handler side-effects only.

    Side effects:
        [adb] Captures screenshots.
        [cv2] Writes images to disk.
        [fs] Creates directories and files.
        [tap][swipe] Sends UI input.
        [log] Emits structured logs.
        [loop] May wait/sleep and/or loop while in WAIT mode.

    Defaults:
        Uses several sleeps between actions (≈1.2–1.5s), and a final 2s sleep.

    Errors:
        Tap failures cause an early abort via _abort_handler(), which sets AUTOMATION.mode=WAIT.
    """
    session_id = _make_session_id()
    log(f"Handling GAME OVER — Session: {session_id}", "INFO")

    if not tap_label_now("buttons.retry:game_over"):
        return _abort_handler("Retry Game", session_id)

    time.sleep(2)

def _make_session_id():
    """
    Build a session identifier for captured artifacts.

    Returns:
        str: "GameYYYYMMDD_%H%M"
    """
    return "Game" + time.strftime("%Y%m%d_%H%M")

def save_image(img, tag):
    """
    Persist a screenshot to the matches directory with a descriptive tag.

    Args:
        img (ndarray | None): BGR image to write (cv2). If None, skip with a warning.
        tag (str): Filename tag (without extension).

    Returns:
        None

    Side effects:
        [fs] Ensures parent directories exist and writes a PNG file.
        [cv2] Uses cv2.imwrite to serialize the image.
        [log] Logs path and warns if img is None.
    """
    if img is None:
        log(f"[CAPTURE] No image to save for tag '{tag}' (img=None). Skipping.", "WARN")
        return
    path = os.path.join("screenshots", "matches", f"{tag}.png")
    os.makedirs(os.path.dirname(path), exist_ok=True)
    cv2.imwrite(path, img)
    log(f"[CAPTURE] Saved screenshot: {path}", "INFO")

def _abort_handler(step, session_id):
    """
    Abort helper for the GAME OVER handler.

    Logs an error, captures a debug screenshot, writes it to disk, and forces
    AUTOMATION.mode to WAIT so the system pauses for manual intervention.

    Args:
        step (str): Human-readable step name that failed.
        session_id (str): Session identifier used for artifact naming.

    Returns:
        None

    Side effects:
        [adb][cv2][fs][log] Capture & persist debug screenshot; emit error.
        [state] Sets AUTOMATION.mode = ExecMode.WAIT to pause automation.
    """
    log(f"[ABORT] Game Over handler failed at: {step}", "ERROR")
    debug_img = capture_adb_screenshot()
    save_image(debug_img, f"{session_id}_ABORT_{step.replace(' ', '_')}")
    AUTOMATION.mode = ExecMode.WAIT
    return
----------./handlers/ad_gem_handler.py----------------------
./handlers/ad_gem_handler.py
# handlers/ad_gem_handler.py

import threading
import time
from core.tap_dispatcher import tap
from core.clickmap_access import get_click
from core.label_tapper import tap_label_now
from utils.logger import log

_blind_tapper_active = threading.Event()
_blind_tapper_stop = threading.Event()  # cooperative cancel


def _blind_floating_gem_tapper(duration=20, interval=1, stop_event=None):
    """
    Blindly tap in the floating gem region for a specified duration.

    Args:
        duration (int | float, optional):
            Number of seconds to continue tapping. Default is 20.
        interval (int | float, optional):
            Delay between taps in seconds. Default is 1.
        stop_event (threading.Event | None, optional):
            When set, exits early.

    Returns:
        None

    Side effects:
        [tap] Sends tap events to the device.
        [log] Emits warnings and action logs.
        [loop] Runs until duration expires or interrupted.

    Notes:
        - Clamps interval to 0.1s minimum if <= 0.
        - Exits early if no floating gem tap location is defined.
        - Always clears the `_blind_tapper_active` flag on exit.
    """
    if stop_event is None:
        stop_event = _blind_tapper_stop

    if duration <= 0:
        log("[WARN] Blind floating gem tapper called with non-positive duration; skipping", "WARN")
        _blind_tapper_active.clear()
        return
    if interval <= 0:
        log("[WARN] Interval <= 0; clamping to 0.1s", "WARN")
        interval = 0.1

    coords = get_click("gesture_targets.floating_gem_blind_tap")
    if not coords:
        log("[WARN] No blind tap location defined for floating gem", "WARN")
        _blind_tapper_active.clear()
        return

    x, y = coords
    label = "floating_gem_blind_tap"

    start_ts = time.time()
    taps = 0
    log(f"Floating gem tapping initiated (duration={duration}s, interval={interval}s)", "ACTION")

    end_time = time.time() + duration
    try:
        while time.time() < end_time and not stop_event.is_set():
            try:
                # Quiet path: suppress per-tap logging at the dispatcher
                tap(x, y, label=label, log_it=False)
                taps += 1
            except Exception as e:
                log(f"[ERROR] Blind gem tapper tap() failed: {e!r}", "ERROR")
                break
            # Sleep in small chunks to respond quickly to stop_event
            target = time.time() + interval
            while not stop_event.is_set() and time.time() < target:
                time.sleep(min(0.05, target - time.time()))
    finally:
        elapsed = int(time.time() - start_ts)
        log(f"Floating gem tapping finished (taps={taps}, elapsed≈{elapsed}s)", "ACTION")
        _blind_tapper_active.clear()
        stop_event.clear()


def start_blind_gem_tapper(duration=20, interval=1, blocking=False):
    """
    Start the blind floating gem tapper for a given duration and interval.

    Args:
        duration (int | float, optional):
            Number of seconds to run. Must be > 0. Default is 20.
        interval (int | float, optional):
            Delay between taps in seconds. Must be > 0. Default is 1.
        blocking (bool, optional):
            If True, runs in the current thread until complete.
            If False (default), runs in a background thread and returns immediately.

    Returns:
        None

    Side effects:
        [tap] Sends repeated tap events to the device.
        [log] Emits structured logs.
        [loop] May run until duration expires.

    Notes:
        - Non-reentrant: will not start if another instance is active.
        - The active state is tracked via `_blind_tapper_active`.
    """
    if duration <= 0:
        log("[WARN] duration must be > 0; aborting request", "WARN")
        return
    if interval <= 0:
        log("[WARN] interval must be > 0; aborting request", "WARN")
        return

    if _blind_tapper_active.is_set():
        log("[INFO] Blind tapper already active; not starting another", "INFO")
        return

    coords = get_click("gesture_targets.floating_gem_blind_tap")
    if not coords:
        log("[WARN] No blind tap location defined for floating gem; not starting", "WARN")
        return

    _blind_tapper_stop.clear()
    _blind_tapper_active.set()

    if blocking:
        log(f"[ACTION] Starting blind gem tapper (blocking) for {duration}s @ {interval}s", "ACTION")
        try:
            _blind_floating_gem_tapper(duration=duration, interval=interval, stop_event=_blind_tapper_stop)
        finally:
            pass
    else:
        log(f"[ACTION] Starting blind gem tapper (background) for {duration}s @ {interval}s", "ACTION")
        threading.Thread(
            target=_blind_floating_gem_tapper,
            kwargs={"duration": duration, "interval": interval, "stop_event": _blind_tapper_stop},
            daemon=False  # keep alive inside the process
        ).start()


def stop_blind_gem_tapper():
    """
    Request the running blind tapper to stop early (cooperative cancel).
    Returns True if a running tapper was signaled, else False.
    """
    if _blind_tapper_active.is_set():
        _blind_tapper_stop.set()
        return True
    return False


def handle_ad_gem():
    """
    Handle the 'AD_GEMS_AVAILABLE' overlay event.

    Workflow:
      1. Start a blind floating gem tapper (background) if one is not already running.
      2. Tap the ad gem overlay to collect it.
      3. Wait 1 second before returning.

    Returns:
        None

    Side effects:
        [tap] Sends tap events to the device.
        [log] Emits action/info logs.
        [loop] Starts background tapping thread.

    Notes:
        - Blind tapper runs for 20s with 1s interval.
        - Uses non-reentrant guard to prevent multiple simultaneous tappers.
    """
    log("Handling AD_GEMS_AVAILABLE overlay", "ACTION")
    start_blind_gem_tapper(duration=20, interval=1, blocking=False)
    tap_label_now("overlays.ad_gem")
    time.sleep(1)
----------./handlers/game_over_handler.py----------------------
./handlers/game_over_handler.py
# handlers/game_over_handler.py
from utils.logger import log
from core.ss_capture import capture_adb_screenshot
from core.automation_state import AUTOMATION, ExecMode
from core.clickmap_access import tap_now, swipe_now
from core.label_tapper import tap_label_now
import time
import os
import cv2

def handle_game_over():
    """
    Handle the GAME OVER flow: capture stats, close stats, and retry or pause.

    Workflow:
      1) Save initial game-over stats screenshot.
      2) Tap "More Stats"; if it fails, abort handler.
      3) Swipe to top, save screenshot; swipe to page 2, save; swipe to bottom, save.
      4) Close "More Stats"; if it fails, abort handler.
      5) Based on AUTOMATION.mode:
         - WAIT: loop until mode changes.
         - HOME: log and exit (not implemented beyond logging).
         - else: tap "Retry"; if it fails, abort handler.

    Returns:
        None — mission/handler side-effects only.

    Side effects:
        [adb] Captures screenshots.
        [cv2] Writes images to disk.
        [fs] Creates directories and files.
        [tap][swipe] Sends UI input.
        [log] Emits structured logs.
        [loop] May wait/sleep and/or loop while in WAIT mode.

    Defaults:
        Uses several sleeps between actions (≈1.2–1.5s), and a final 2s sleep.

    Errors:
        Tap failures cause an early abort via _abort_handler(), which sets AUTOMATION.mode=WAIT.
    """
    session_id = _make_session_id()
    log(f"Handling GAME OVER — Session: {session_id}", "INFO")

    # Save first screen
    img_game_stats = capture_adb_screenshot()
    save_image(img_game_stats, f"{session_id}_game_stats")

    # Step 1: Tap "More Stats"
    if not tap_label_now("buttons.more_stats:game_over"):
        return _abort_handler("Tap More Stats", session_id)

    time.sleep(1.5)

    # Step 2: Swipe to top and capture
    swipe_now("gesture_targets.goto_top:more_stats")
    time.sleep(1.5)
    save_image(capture_adb_screenshot(), f"{session_id}_more_stats_1")

    # Step 3: Swipe to page 2 and capture
    swipe_now("gesture_targets.goto_pg2:more_stats")
    time.sleep(1.2)
    save_image(capture_adb_screenshot(), f"{session_id}_more_stats_2")

    # Step 4: Swipe to bottom and capture
    swipe_now("gesture_targets.goto_bottom:more_stats")
    time.sleep(1.2)
    save_image(capture_adb_screenshot(), f"{session_id}_more_stats_3")

    # Step 5: Close More Stats
    if not tap_label_now("buttons.close:more_stats"):
        return _abort_handler("Close More Stats", session_id)

    time.sleep(1.2)

    # Step 6: Decide next action based on mode
    mode = AUTOMATION.mode
    if mode == ExecMode.WAIT:
        log("Pausing on Game Over — waiting for user signal.", "INFO")
        while AUTOMATION.mode is ExecMode.WAIT:
            time.sleep(1)
    elif mode == ExecMode.HOME:
        log("Mode = HOME (not implemented yet)", "INFO")
        return  # Exit cleanly
    else:
        if not tap_label_now("buttons.retry:game_over"):
            return _abort_handler("Retry Game", session_id)

    time.sleep(2)

def _make_session_id():
    """
    Build a session identifier for captured artifacts.

    Returns:
        str: "GameYYYYMMDD_%H%M"
    """
    return "Game" + time.strftime("%Y%m%d_%H%M")

def save_image(img, tag):
    """
    Persist a screenshot to the matches directory with a descriptive tag.

    Args:
        img (ndarray | None): BGR image to write (cv2). If None, skip with a warning.
        tag (str): Filename tag (without extension).

    Returns:
        None

    Side effects:
        [fs] Ensures parent directories exist and writes a PNG file.
        [cv2] Uses cv2.imwrite to serialize the image.
        [log] Logs path and warns if img is None.
    """
    if img is None:
        log(f"[CAPTURE] No image to save for tag '{tag}' (img=None). Skipping.", "WARN")
        return
    path = os.path.join("screenshots", "matches", f"{tag}.png")
    os.makedirs(os.path.dirname(path), exist_ok=True)
    cv2.imwrite(path, img)
    log(f"[CAPTURE] Saved screenshot: {path}", "INFO")

def _abort_handler(step, session_id):
    """
    Abort helper for the GAME OVER handler.

    Logs an error, captures a debug screenshot, writes it to disk, and forces
    AUTOMATION.mode to WAIT so the system pauses for manual intervention.

    Args:
        step (str): Human-readable step name that failed.
        session_id (str): Session identifier used for artifact naming.

    Returns:
        None

    Side effects:
        [adb][cv2][fs][log] Capture & persist debug screenshot; emit error.
        [state] Sets AUTOMATION.mode = ExecMode.WAIT to pause automation.
    """
    log(f"[ABORT] Game Over handler failed at: {step}", "ERROR")
    debug_img = capture_adb_screenshot()
    save_image(debug_img, f"{session_id}_ABORT_{step.replace(' ', '_')}")
    AUTOMATION.mode = ExecMode.WAIT
    return
----------./handlers/home_screen_handler.py----------------------
./handlers/home_screen_handler.py
# handlers/home_screen_handler.py

import time
from utils.logger import log
from core.clickmap_access import tap_now
from core.label_tapper import tap_label_now


def handle_home_screen(restart_enabled=True):
    """
    Handle the HOME_SCREEN state by optionally starting a battle.

    Args:
        restart_enabled (bool, optional):
            When True (default), taps the 'Battle' button to auto-start gameplay.
            When False, does nothing beyond logging (awaits manual start).

    Returns:
        None — handler effects only.

    Side effects:
        [tap] Taps the Battle button when restart_enabled=True.
        [log] Emits INFO logs.
        (Also sleeps ≈2s after tapping to allow UI to transition.)

    Defaults:
        restart_enabled=True; adds a ~2s pause after tapping when enabled.

    Errors:
        None material; tap failures (if any) are not explicitly handled here.
    """
    log("[HOME] Handling HOME_SCREEN state", "INFO")

    if restart_enabled:
        log("[HOME] Auto-start enabled — tapping 'Battle' button", "INFO")
        if not tap_label_now("buttons.battle:home"):
            tap_label_now("buttons.resume_battle:home")
        time.sleep(2)
    else:
        log("[HOME] Auto-start disabled — waiting for manual start.", "INFO")
----------./handlers/mission_nuke.py----------------------
./handlers/mission_nuke.py
# handlers/mission_demon_nuke.py

"""
Mission: Demon Mode → Nuke → End Round → Retry.

This module runs a mission sequence intended for testing or scripted play:
1) Wait until the game is in RUNNING state.
2) Wait for and tap the Demon Mode floating button.
3) Wait a fixed duration to benefit from Demon Mode.
4) Wait for and tap the Nuke floating button.
5) Open the menu if needed, tap End Round, confirm, and tap Retry.

Notes
- Blocking loops: waits poll the screen until conditions are met; there are no timeouts.
- Side effects: ADB screenshots, OpenCV detection, on-device taps, and logging.
- Errors: Tap attempts inside the end-game sequence are guarded; failures are logged and the flow continues.
"""

import time
from core.ss_capture import capture_and_save_screenshot
from core.clickmap_access import tap_now
from core.floating_button_detector import detect_floating_buttons, tap_floating_button
from core.state_detector import detect_state_and_overlays
from core.label_tapper import tap_label_now
from utils.logger import log


def run_nuke_strategy():
    """
    Run the Demon-Mode-then-Nuke mission sequence and attempt an immediate restart.

    Flow
    - Poll for RUNNING state (2s interval).
    - Poll for Demon Mode button, tap it (1s interval), then wait 10s.
    - Poll for Nuke button, tap it (1s interval), then wait 5s.
    - Ensure menu is open, tap End Round, confirm Yes, then tap Retry.

    Returns
    - None. Action-oriented procedure; logs progress and issues.

    Side Effects
    - [adb][cv2][fs][state][tap][log][loop]
    """
    log("[MISSION] Starting Nuke -> Restart mission", "ACTION")

    # Step 1: Wait for RUNNING state
    while True:
        screen = capture_and_save_screenshot()
        result = detect_state_and_overlays(screen)
        if result["state"] == "RUNNING":
            log("[MISSION] Game is in RUNNING state", "INFO")
            break
        log("[MISSION] Waiting for RUNNING state...", "DEBUG")
        time.sleep(2)

    time.sleep(20)

    # Step 4: Wait for Nuke button
    while True:
        screen = capture_and_save_screenshot()
        buttons = detect_floating_buttons(screen)
        if any(b["name"] == "floating_buttons.nuke" for b in buttons):
            log("[MISSION] Nuke button detected!", "INFO")
            tap_floating_button("floating_buttons.nuke", buttons)
            break
        log("[MISSION] Waiting for Nuke button...", "DEBUG")
        time.sleep(1)

    # Step 5: Wait a bit more
    log("[MISSION] Nuke launched. Waiting 5s before restart...", "INFO")
    time.sleep(5)

    # Step 6: End game sequence
    screen = capture_and_save_screenshot()
    result = detect_state_and_overlays(screen)
    if "MENU_OPEN" not in result["overlays"]:
        log("[MISSION] Menu is closed — opening it", "DEBUG")
        tap_now("overlays.toggle_menu")
        time.sleep(1)

    try:
        tap_label_now("overlays.end_round")
    except Exception as e:
        log(f"[MISSION] Failed to tap End Round: {e}", "WARN")
    time.sleep(1)

    try:
        screen = capture_and_save_screenshot()
        tap_label_now("buttons.yes:end_round")
    except Exception as e:
        log(f"[MISSION] Confirm Yes not visible: {e}", "WARN")
    time.sleep(1)

    try:
        screen = capture_and_save_screenshot()
        tap_label_now("buttons.retry:game_over")
    except Exception as e:
        log(f"[MISSION] Retry button not visible: {e}", "WARN")

    log("[MISSION] Demon-Nuke strategy complete", "SUCCESS")
----------./handlers/mission_demon_nuke.py----------------------
./handlers/mission_demon_nuke.py
# handlers/mission_demon_nuke.py

"""
Mission: Demon Mode → Nuke → End Round → Retry.

This module runs a mission sequence intended for testing or scripted play:
1) Wait until the game is in RUNNING state.
2) Wait for and tap the Demon Mode floating button.
3) Wait a fixed duration to benefit from Demon Mode.
4) Wait for and tap the Nuke floating button.
5) Open the menu if needed, tap End Round, confirm, and tap Retry.

Notes
- Blocking loops: waits poll the screen until conditions are met; there are no timeouts.
- Side effects: ADB screenshots, OpenCV detection, on-device taps, and logging.
- Errors: Tap attempts inside the end-game sequence are guarded; failures are logged and the flow continues.
"""

import time
from core.ss_capture import capture_and_save_screenshot
from core.clickmap_access import tap_now
from core.floating_button_detector import detect_floating_buttons, tap_floating_button
from core.state_detector import detect_state_and_overlays
from core.label_tapper import tap_label_now
from utils.logger import log


def run_demon_nuke_strategy():
    """
    Run the Demon-Mode-then-Nuke mission sequence and attempt an immediate restart.

    Flow
    - Poll for RUNNING state (2s interval).
    - Poll for Demon Mode button, tap it (1s interval), then wait 10s.
    - Poll for Nuke button, tap it (1s interval), then wait 5s.
    - Ensure menu is open, tap End Round, confirm Yes, then tap Retry.

    Returns
    - None. Action-oriented procedure; logs progress and issues.

    Side Effects
    - [adb][cv2][fs][state][tap][log][loop]
    """
    log("[MISSION] Starting Demon Mode -> Nuke -> Restart mission", "ACTION")

    # Step 1: Wait for RUNNING state
    while True:
        screen = capture_and_save_screenshot()
        result = detect_state_and_overlays(screen)
        if result["state"] == "RUNNING":
            log("[MISSION] Game is in RUNNING state", "INFO")
            break
        log("[MISSION] Waiting for RUNNING state...", "DEBUG")
        time.sleep(2)

    # Step 2: Wait for demon_mode button
    while True:
        screen = capture_and_save_screenshot()
        buttons = detect_floating_buttons(screen)
        if any(b["name"] == "floating_buttons.demon_mode" for b in buttons):
            log("[MISSION] Demon Mode button detected!", "INFO")
            tap_floating_button("floating_buttons.demon_mode", buttons)
            break
        log("[MISSION] Waiting for Demon Mode button...", "DEBUG")
        time.sleep(1)

    # Step 3: Wait ~10 seconds
    log("[MISSION] Demon Mode activated. Waiting 10s...", "INFO")
    time.sleep(10)

    # Step 4: Wait for Nuke button
    while True:
        screen = capture_and_save_screenshot()
        buttons = detect_floating_buttons(screen)
        if any(b["name"] == "floating_buttons.nuke" for b in buttons):
            log("[MISSION] Nuke button detected!", "INFO")
            tap_floating_button("floating_buttons.nuke", buttons)
            break
        log("[MISSION] Waiting for Nuke button...", "DEBUG")
        time.sleep(1)

    # Step 5: Wait a bit more
    log("[MISSION] Nuke launched. Waiting 5s before restart...", "INFO")
    time.sleep(5)

    # Step 6: End game sequence
    screen = capture_and_save_screenshot()
    result = detect_state_and_overlays(screen)
    if "MENU_OPEN" not in result["overlays"]:
        log("[MISSION] Menu is closed — opening it", "DEBUG")
        tap_now("overlays.toggle_menu")
        time.sleep(1)

    try:
        tap_label_now("overlays.end_round")
    except Exception as e:
        log(f"[MISSION] Failed to tap End Round: {e}", "WARN")
    time.sleep(1)

    try:
        screen = capture_and_save_screenshot()
        tap_label_now("buttons.yes:end_round")
    except Exception as e:
        log(f"[MISSION] Confirm Yes not visible: {e}", "WARN")
    time.sleep(1)

    try:
        screen = capture_and_save_screenshot()
        tap_label_now("buttons.retry:game_over")
    except Exception as e:
        log(f"[MISSION] Retry button not visible: {e}", "WARN")

    log("[MISSION] Demon-Nuke strategy complete", "SUCCESS")
----------./handlers/mission_demon_mode.py----------------------
./handlers/mission_demon_mode.py
# handlers/mission_demon_mode.py

"""
Mission: Demon Mode → End Round → Retry.

This module provides:
1) A single bounded round runner: `run_demon_mode_strategy(...)`
   - Waits for RUNNING
   - Waits for Demon Mode button and taps it
   - Waits a configured duration (post_demon_wait)
   - Opens menu (if closed), taps End Round → Yes → Retry
   - Uses per-phase timeouts to avoid hanging; returns a structured MissionResult

2) A campaign orchestrator: `run_demon_mode_campaign(...)`
   - Repeats the strategy round until a stop condition (max runs, duration, stopfile,
     user interrupt, or a custom `until(progress)` predicate fed by `progress_detector`)
   - Aggregates outcomes and timing

3) Back-compat wrapper: `run_demon_mode(wait_seconds=75)`
   - Preserves the original API; delegates to `run_demon_mode_strategy` and returns None.

Notes
- Side effects: ADB screenshots, OpenCV detection, on-device taps, file I/O for screenshots, and logging.
- Error policy: normal UI/detection issues are reflected in the result; programmer errors still raise.
"""

from __future__ import annotations

import os
import time
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Callable, Dict, Any, Optional

from core.ss_capture import capture_and_save_screenshot
from core.clickmap_access import tap_now
from core.floating_button_detector import detect_floating_buttons, tap_floating_button
from core.state_detector import detect_state_and_overlays
from core.label_tapper import tap_label_now
from utils.logger import log


# ===== Mission types =====

class MissionOutcome(Enum):
    SUCCESS = auto()
    TIMEOUT_WAITING_FOR_RUNNING = auto()
    TIMEOUT_WAITING_FOR_DEMON = auto()
    UI_FLOW_FAILURE = auto()
    ABORTED_BY_USER = auto()


@dataclass
class MissionResult:
    outcome: MissionOutcome
    details: str = ""
    elapsed_s: float = 0.0
    phases: Dict[str, float] = field(default_factory=dict)  # phase_name -> seconds
    errors: list[str] = field(default_factory=list)


@dataclass
class MissionConfig:
    # Poll intervals
    poll_running_interval_s: float = 2.0
    poll_buttons_interval_s: float = 1.0

    # Post-activation wait (match legacy default 75s)
    post_demon_wait_s: float = 75.0

    # Timeouts per phase and overall per-round deadline
    timeout_running_s: float = 60.0
    timeout_demon_s: float = 45.0
    overall_deadline_s: float = 240.0

    # Verification & retries for taps that should change UI
    verify_tap: bool = True
    max_tap_retries: int = 2


@dataclass
class CampaignResult:
    runs: int
    successes: int
    timeouts_running: int
    timeouts_demon: int
    ui_failures: int
    aborted: bool
    total_elapsed_s: float
    last_result: Optional[MissionResult] = None
    progress: Dict[str, Any] | None = None


# ===== Strategy (single bounded round) =====

def run_demon_mode_strategy(
    config: MissionConfig | None = None,
    *,
    dry_run: bool = False,
    on_event: Callable[[str, Dict[str, Any]], None] | None = None,
) -> MissionResult:
    """
    Run one bounded Demon→End Round→Retry round and return a MissionResult.

    Flow
    - Wait for RUNNING (≤ timeout_running_s), poll every poll_running_interval_s
    - Wait for Demon Mode button (≤ timeout_demon_s), tap; wait post_demon_wait_s
    - Ensure menu open; tap End Round → Yes → Retry (best-effort with logging)

    Returns
    - MissionResult(outcome, details, elapsed, per-phase durations, errors)

    Side Effects
    - [adb][cv2][fs][state][tap][log]
    """
    cfg = config or MissionConfig()
    t0 = time.monotonic()
    deadline = t0 + cfg.overall_deadline_s
    phases: Dict[str, float] = {}
    errors: list[str] = []

    def emit(event: str, data: Dict[str, Any]):
        if on_event:
            try:
                on_event(event, data)
            except Exception as e:
                # Don’t let callbacks break mission flow
                log(f"[MISSION] on_event error @ {event}: {e}", "WARN")

    def _now() -> float:
        return time.monotonic()

    def _before_deadline() -> bool:
        return _now() < deadline

    def _phase(name: str, fn: Callable[[], MissionOutcome | None]) -> MissionOutcome | None:
        p0 = _now()
        try:
            emit("PHASE_START", {"name": name})
            return fn()
        finally:
            phases[name] = _now() - p0
            emit("PHASE_END", {"name": name, "duration_s": phases[name]})

    def _wait_for_state_running() -> MissionOutcome | None:
        end_by = _now() + cfg.timeout_running_s
        while _now() < end_by and _before_deadline():
            if dry_run:
                return None
            screen = capture_and_save_screenshot()
            result = detect_state_and_overlays(screen)
            if result.get("state") == "RUNNING":
                log("[MISSION] Game is in RUNNING state", "INFO")
                return None
            log("[MISSION] Waiting for RUNNING state...", "DEBUG")
            time.sleep(cfg.poll_running_interval_s)
        return MissionOutcome.TIMEOUT_WAITING_FOR_RUNNING

    def _tap_floating_button_with_verify(button_key: str) -> bool:
        """
        Tap a floating button (already detected via polling) and verify it no longer appears,
        retrying up to cfg.max_tap_retries. Returns True on verified success (or dry_run).
        """
        attempts = 0
        while True:
            attempts += 1
            if not dry_run:
                screen = capture_and_save_screenshot()
                buttons = detect_floating_buttons(screen)
                if any(b["name"] == button_key for b in buttons):
                    tap_floating_button(button_key, buttons)
                else:
                    if not cfg.verify_tap:
                        return True

            if not cfg.verify_tap or dry_run:
                return True

            # Verify disappearance (or state change) by re-detecting
            screen = capture_and_save_screenshot()
            buttons = detect_floating_buttons(screen)
            gone = not any(b["name"] == button_key for b in buttons)
            if gone:
                return True
            if attempts > cfg.max_tap_retries:
                return False
            log(f"[MISSION] '{button_key}' still visible — retrying tap ({attempts}/{cfg.max_tap_retries})", "WARN")
            time.sleep(cfg.poll_buttons_interval_s)

    def _wait_for_and_tap(button_key: str, timeout_s: float) -> MissionOutcome | None:
        end_by = _now() + timeout_s
        while _now() < end_by and _before_deadline():
            if dry_run:
                return None
            screen = capture_and_save_screenshot()
            buttons = detect_floating_buttons(screen)
            if any(b["name"] == button_key for b in buttons):
                log(f"[MISSION] {button_key.split('.')[-1].title()} button detected!", "INFO")
                ok = _tap_floating_button_with_verify(button_key)
                if not ok:
                    errors.append(f"Verify failed for {button_key}")
                    return MissionOutcome.UI_FLOW_FAILURE
                return None
            log(f"[MISSION] Waiting for {button_key}...", "DEBUG")
            time.sleep(cfg.poll_buttons_interval_s)
        return MissionOutcome.TIMEOUT_WAITING_FOR_DEMON

    try:
        log("[MISSION] Starting Demon Mode -> End Round -> Retry mission", "ACTION")

        # Phase: WAIT_RUNNING
        outcome = _phase("WAIT_RUNNING", _wait_for_state_running)
        if outcome:
            return MissionResult(
                outcome=outcome,
                details="RUNNING state not reached within timeout",
                elapsed_s=time.monotonic() - t0,
                phases=phases,
                errors=errors,
            )

        # Phase: WAIT_TAP_DEMON
        outcome = _phase("WAIT_TAP_DEMON", lambda: _wait_for_and_tap("floating_buttons.demon_mode", cfg.timeout_demon_s))
        if outcome:
            return MissionResult(
                outcome=outcome,
                details="Demon Mode button not available (or verify failed)",
                elapsed_s=time.monotonic() - t0,
                phases=phases,
                errors=errors,
            )

        # Phase: POST_DEMON_WAIT (preserve legacy countdown print)
        def _post_demon() -> MissionOutcome | None:
            wait_seconds = int(cfg.post_demon_wait_s)
            log(f"[MISSION] Demon Mode activated. Waiting {wait_seconds}s...", "INFO")
            if not dry_run:
                for remaining in range(wait_seconds, 0, -1):
                    print(f"\r[WAIT] {remaining} seconds remaining...", end="", flush=True)
                    time.sleep(1)
                print("\r[WAIT] Done.                                                  ")
            return None

        _phase("POST_DEMON_WAIT", _post_demon)

        # Phase: END_GAME_SEQUENCE
        def _end_game() -> MissionOutcome | None:
            if dry_run:
                return None

            screen = capture_and_save_screenshot()
            result = detect_state_and_overlays(screen)
            if "MENU_OPEN" not in result.get("overlays", []):
                log("[MISSION] Menu is closed — opening it", "DEBUG")
                tap_now("overlays.toggle_menu")
                time.sleep(1)

            try:
                tap_label_now("overlays.end_round")
            except Exception as e:
                msg = f"Failed to tap End Round: {e}"
                log(f"[MISSION] {msg}", "WARN")
                errors.append(msg)
            time.sleep(1)

            try:
                screen = capture_and_save_screenshot()
                tap_label_now("buttons.yes:end_round")
            except Exception as e:
                msg = f"Confirm Yes not visible: {e}"
                log(f"[MISSION] {msg}", "WARN")
                errors.append(msg)
            time.sleep(1)

            try:
                screen = capture_and_save_screenshot()
                tap_label_now("buttons.retry:game_over")
            except Exception as e:
                msg = f"Retry button not visible: {e}"
                log(f"[MISSION] {msg}", "WARN")
                errors.append(msg)

            return None

        _phase("END_GAME_SEQUENCE", _end_game)

        log("[MISSION] Demon-Mode strategy complete", "SUCCESS")
        return MissionResult(
            outcome=MissionOutcome.SUCCESS,
            details="Round completed",
            elapsed_s=time.monotonic() - t0,
            phases=phases,
            errors=errors,
        )

    except KeyboardInterrupt:
        log("[MISSION] Aborted by user", "WARN")
        return MissionResult(
            outcome=MissionOutcome.ABORTED_BY_USER,
            details="User interrupted",
            elapsed_s=time.monotonic() - t0,
            phases=phases,
            errors=errors,
        )


# ===== Campaign (repeat rounds until stop) =====

def run_demon_mode_campaign(
    config: MissionConfig | None = None,
    *,
    max_runs: int | None = None,
    max_duration_s: float | None = None,
    sleep_between_runs_s: float = 2.0,
    stopfile: str | None = None,
    progress_detector: Callable[[Any | None], Dict[str, Any]] | None = None,
    until: Callable[[Dict[str, Any]], bool] | None = None,
    on_event: Callable[[str, Dict[str, Any]], None] | None = None,
    dry_run: bool = False,
) -> CampaignResult:
    """
    Orchestrate repeated Demon→End Round→Retry rounds until a stop condition.

    Stop conditions (any):
    - max_runs reached
    - max_duration_s exceeded
    - stopfile exists
    - until(progress) returns True (if progress_detector supplied)
    - KeyboardInterrupt (returns aborted=True)

    Returns
    - CampaignResult with aggregates, last MissionResult, and last progress (if any)

    Side Effects
    - [adb][cv2][fs][state][tap][log][loop]
    """
    cfg = config or MissionConfig()
    t0 = time.monotonic()
    runs = successes = to_run = to_demon = ui_fail = 0
    aborted = False
    last_result: Optional[MissionResult] = None
    last_progress: Dict[str, Any] | None = None

    def emit(event: str, data: Dict[str, Any]):
        if on_event:
            try:
                on_event(event, data)
            except Exception as e:
                log(f"[CAMPAIGN] on_event error @ {event}: {e}", "WARN")

    try:
        emit("CAMPAIGN_START", {"max_runs": max_runs, "max_duration_s": max_duration_s})
        while True:
            # Check duration bound
            if max_duration_s is not None and (time.monotonic() - t0) >= max_duration_s:
                log("[CAMPAIGN] Max duration reached", "INFO")
                break
            # Check run bound
            if max_runs is not None and runs >= max_runs:
                log("[CAMPAIGN] Max runs reached", "INFO")
                break
            # Check stopfile
            if stopfile and os.path.exists(stopfile):
                log(f"[CAMPAIGN] Stopfile detected at {stopfile}", "INFO")
                break

            emit("ROUND_START", {"round_index": runs + 1})
            last_result = run_demon_mode_strategy(cfg, dry_run=dry_run, on_event=on_event)
            emit("ROUND_END", {"round_index": runs + 1, "outcome": last_result.outcome.name})
            runs += 1

            # Aggregate outcomes
            oc = last_result.outcome
            if oc == MissionOutcome.SUCCESS:
                successes += 1
            elif oc == MissionOutcome.TIMEOUT_WAITING_FOR_RUNNING:
                to_run += 1
            elif oc == MissionOutcome.TIMEOUT_WAITING_FOR_DEMON:
                to_demon += 1
            elif oc == MissionOutcome.UI_FLOW_FAILURE:
                ui_fail += 1
            elif oc == MissionOutcome.ABORTED_BY_USER:
                aborted = True
                break

            # Optional progress detection + termination predicate
            if progress_detector:
                try:
                    screen = None if dry_run else capture_and_save_screenshot()
                    last_progress = progress_detector(screen)
                    emit("PROGRESS", {"round_index": runs, "progress": last_progress})
                    if until and until(last_progress):
                        log("[CAMPAIGN] Until-condition satisfied", "INFO")
                        break
                except Exception as e:
                    log(f"[CAMPAIGN] progress_detector error: {e}", "WARN")

            # Inter-round pause & re-check stopfile
            if sleep_between_runs_s > 0:
                time.sleep(sleep_between_runs_s)
            if stopfile and os.path.exists(stopfile):
                log(f"[CAMPAIGN] Stopfile detected at {stopfile}", "INFO")
                break

        return CampaignResult(
            runs=runs,
            successes=successes,
            timeouts_running=to_run,
            timeouts_demon=to_demon,
            ui_failures=ui_fail,
            aborted=aborted,
            total_elapsed_s=time.monotonic() - t0,
            last_result=last_result,
            progress=last_progress,
        )

    except KeyboardInterrupt:
        log("[CAMPAIGN] Aborted by user", "WARN")
        return CampaignResult(
            runs=runs,
            successes=successes,
            timeouts_running=to_run,
            timeouts_demon=to_demon,
            ui_failures=ui_fail,
            aborted=True,
            total_elapsed_s=time.monotonic() - t0,
            last_result=last_result,
            progress=last_progress,
        )


# ===== Legacy wrapper (backward compatibility) =====

def run_demon_mode(wait_seconds: int = 75) -> None:
    """
    Backward-compatible wrapper for the original API.

    Args:
        wait_seconds: how long to wait after activating Demon Mode before ending the round.

    Returns:
        None — delegates to run_demon_mode_strategy and discards the MissionResult.
    """
    cfg = MissionConfig(post_demon_wait_s=float(wait_seconds))
    _ = run_demon_mode_strategy(cfg)
    return None
----------./handlers/daily_gem_handler.py----------------------
./handlers/daily_gem_handler.py
from utils.logger import log
from core.ss_capture import capture_adb_screenshot
from core.automation_state import AUTOMATION
from core.clickmap_access import tap_now, swipe_now
from core.label_tapper import tap_label_now
import time
import os
import cv2

def handle_daily_gem():
    print("Handling")
    session_id = _make_session_id()
    log(f"Handling DAILY AD GEM — Session: {session_id}", "INFO")

    # Tap into Store
    if not tap_label_now("navigation.goto_store"):
        return _abort_handler("Goto Store", session_id)
    time.sleep(1.2)

    # Goto Top of Store
    swipe_now("gesture_targets.goto_top:store")
    time.sleep(1.5)

    # Save first screen
    img_game_stats = capture_adb_screenshot()
    save_image(img_game_stats, f"{session_id}_store_top")

    # Goto Claim Daily Gems`
    # Swipe and capture 
    swipe_now("gesture_targets.goto_claim_daily_gems:store")
    time.sleep(3)
    save_image(capture_adb_screenshot(), f"{session_id}claim_daily_gems")

    # Claim Daily Gem
    if not tap_label_now("buttons.claim_daily_gems"):
        return _abort_handler("Claim_daily_gems", session_id)
    time.sleep(1.2)

    # Skip
    if not tap_label_now("buttons.skip:claim_daily_gems"):
        return _abort_handler("Skip Claim_daily_gems", session_id)
    time.sleep(1.2)

    # Return to Game
    if not tap_label_now("buttons.return_to_game"):
        return _abort_handler("Return to Game", session_id)
    time.sleep(1.2)

def _make_session_id():
    return "Game" + time.strftime("%Y%m%d_%H%M")

def save_image(img, tag):
    path = os.path.join("screenshots", "matches", f"{tag}.png")
    os.makedirs(os.path.dirname(path), exist_ok=True)
    cv2.imwrite(path, img)
    log(f"[CAPTURE] Saved screenshot: {path}", "INFO")

def _abort_handler(step, session_id):
    """
    Logs error, saves screenshot, and aborts handler.
    """
    log(f"[ABORT]  Daily Gem handler failed at: {step}", "ERROR")
    debug_img = capture_adb_screenshot()
    save_image(debug_img, f"{session_id}_ABORT_{step.replace(' ', '_')}")
    return


----------./old/run_crop_expanded.py----------------------
./old/run_crop_expanded.py
#!/usr/bin/env python3

import subprocess
import re
import signal
import atexit
import sys

# Target framebuffer height
EXPANDED_HEIGHT = 3600

def get_current_resolution():
    output = subprocess.check_output(["xrandr"]).decode()
    match = re.search(r"current (\d+) x (\d+)", output)
    if match:
        return int(match.group(1)), int(match.group(2))
    raise RuntimeError("Failed to detect current resolution.")

def set_framebuffer(width, height):
    subprocess.run(["xrandr", "--fb", f"{width}x{height}"], check=True)

def run_crop_region():
    subprocess.run(["python3", "tools/crop_region.py"])

def main():
    width, height = get_current_resolution()
    print(f"[INFO] Current resolution: {width}x{height}")

    def restore_resolution():
        print(f"[INFO] Restoring resolution to {width}x{height}")
        set_framebuffer(width, height)

    atexit.register(restore_resolution)
    signal.signal(signal.SIGINT, lambda sig, frame: sys.exit(0))
    signal.signal(signal.SIGTERM, lambda sig, frame: sys.exit(0))

    try:
        print(f"[INFO] Expanding framebuffer to {width}x{EXPANDED_HEIGHT}")
        set_framebuffer(width, EXPANDED_HEIGHT)
        run_crop_region()
    except Exception as e:
        print(f"[ERROR] {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
----------./old/log_meminfo.py----------------------
./old/log_meminfo.py
#!/usr/bin/env python3
# log_meminfo.py
import subprocess
import time
import re
from datetime import datetime
from pathlib import Path

PACKAGE = "com.TechTreeGames.TheTower"
INTERVAL = 600  # 10 minutes
LOGFILE = "logs/meminfo.log"

Path("logs").mkdir(exist_ok=True)

THERMAL_LOG = "logs/thermal.log"

def get_thermal_snapshot():
    try:
        result = subprocess.run(
            ["adb", "shell", "dumpsys", "thermalservice"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        temps = {}
        recording = False
        for line in result.stdout.splitlines():
            if "Current temperatures from HAL:" in line:
                recording = True
                continue
            if recording:
                if not line.strip():
                    break  # end of section
                match = re.search(r'Temperature\{mValue=([\d.]+), .*?mName=([a-zA-Z0-9\-_:]+),', line)
                if match:
                    temp = float(match.group(1))
                    label = match.group(2)
                    temps[label] = temp
        return temps
    except Exception as e:
        return {"error": str(e)}

def dump_logcat(ts_label):
    filename = f"logs/logcat_{ts_label}.txt"
    try:
        with open(filename, "w") as f:
            subprocess.run(
                ["adb", "logcat", "-b", "all", "-v", "time", "-d"],
                stdout=f, stderr=subprocess.DEVNULL, timeout=10
            )
        return filename
    except Exception as e:
        return f"FAILED_LOGCAT: {e}"

def get_meminfo():
    try:
        result = subprocess.run(
            ["adb", "shell", "dumpsys", "meminfo", PACKAGE],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        lines = result.stdout.splitlines()
        summary = {}
        for line in lines:
            if "TOTAL PSS" in line:
                match = re.search(r'TOTAL PSS:\s+(\d+)', line)
                if match:
                    summary["TOTAL_PSS"] = int(match.group(1))
            elif "Private Other:" in line:
                match = re.search(r'Private Other:\s+(\d+)', line)
                if match:
                    summary["Private_Other"] = int(match.group(1))
            elif "Graphics:" in line:
                match = re.search(r'Graphics:\s+(\d+)', line)
                if match:
                    summary["Graphics"] = int(match.group(1))
            elif "Java Heap:" in line:
                match = re.search(r'Java Heap:\s+(\d+)', line)
                if match:
                    summary["Java_Heap"] = int(match.group(1))
            elif "Native Heap:" in line:
                match = re.search(r'Native Heap:\s+(\d+)', line)
                if match:
                    summary["Native_Heap"] = int(match.group(1))
        return summary
    except Exception as e:
        return {"error": str(e)}

def get_sys_meminfo():
    try:
        result = subprocess.run(
            ["adb", "shell", "cat", "/proc/meminfo"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        sysinfo = {}
        for line in result.stdout.splitlines():
            match = re.match(r"(\w+):\s+(\d+)", line)
            if match:
                sysinfo[match.group(1)] = int(match.group(2))  # kB
        return {
            "MemFree": sysinfo.get("MemFree"),
            "MemAvailable": sysinfo.get("MemAvailable"),
            "SwapTotal": sysinfo.get("SwapTotal"),
            "SwapFree": sysinfo.get("SwapFree")
        }
    except Exception as e:
        return {"sys_error": str(e)}

def get_uptime():
    try:
        result = subprocess.run(
            ["adb", "shell", "cat", "/proc/uptime"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        parts = result.stdout.strip().split()
        if len(parts) >= 1:
            uptime_sec = float(parts[0])
            return int(uptime_sec)
    except:
        pass
    return -1

def get_boot_completed():
    try:
        result = subprocess.run(
            ["adb", "shell", "getprop", "sys.boot_completed"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        return result.stdout.strip()
    except:
        return "?"

def get_max_temp():
    try:
        result = subprocess.run(
            ["adb", "shell", "cat", "/sys/class/thermal/thermal_zone*/temp"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
        )
        temps = [int(t.strip()) for t in result.stdout.splitlines() if t.strip().isdigit()]
        if temps:
            return max(temps) / 1000.0  # most devices report in millidegrees
    except:
        pass
    return -1

def main():
    print("[INFO] Starting meminfo logger.")
    last_uptime = None
    with open(LOGFILE, "a") as f:
        while True:
            ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            ts_label = ts.replace(":", "-").replace(" ", "_")

            data = get_meminfo()
            sys = get_sys_meminfo()
            uptime = get_uptime()
            boot = get_boot_completed()

            logcat_triggered = False
            line = f"[{ts}]"

            thermal_data = get_thermal_snapshot()
            if "error" in thermal_data:
                max_temp = -1.0
                thermal_line = f"[{ts}] ERROR: {thermal_data['error']}"
            else:
                max_temp = max(thermal_data.values()) if thermal_data else -1.0
                thermal_line = f"[{ts}] " + " ".join([f"{k}={v:.1f}°C" for k, v in thermal_data.items()])
            
            # Write separate thermal log
            with open(THERMAL_LOG, "a") as tf:
                tf.write(thermal_line + "\n")
            
            line += f" | MaxTemp={max_temp:.1f}°C"

            # Trigger if adb meminfo failed
            if "error" in data:
                line += f" ERROR: {data['error']}"
                logcat_triggered = True
            else:
                line += (
                    f" PSS={data.get('TOTAL_PSS')} PrivateOther={data.get('Private_Other')}"
                    f" Graphics={data.get('Graphics')} JavaHeap={data.get('Java_Heap')} NativeHeap={data.get('Native_Heap')}"
                )

            if "sys_error" in sys:
                line += f" | SYS ERROR: {sys['sys_error']}"
                logcat_triggered = True
            else:
                line += (
                    f" | MemFree={sys.get('MemFree')}kB MemAvailable={sys.get('MemAvailable')}kB"
                    f" SwapFree={sys.get('SwapFree')}kB SwapTotal={sys.get('SwapTotal')}kB"
                )

            line += f" | Uptime={uptime}s BootCompleted={boot}"

            # Check for uptime reset (possible crash)
            if last_uptime is not None and uptime != -1 and uptime < last_uptime:
                line += " | DETECTED: Reboot (uptime decreased)"
                logcat_triggered = True

            if logcat_triggered:
                logcat_file = dump_logcat(ts_label)
                line += f" | LogcatDumped={logcat_file}"

            print(line)
            f.write(line + "\n")
            f.flush()
            last_uptime = uptime
            time.sleep(INTERVAL)


if __name__ == "__main__":
    main()

----------./old/old/click_logger.py----------------------
./old/old/click_logger.py
#!/usr/bin/env python3

import subprocess
import time
import re
import json
import os
from pynput import mouse

CLICKMAP_FILE = os.path.join(os.path.dirname(__file__), "clickmap.json")

def get_android_screen_size():
    output = subprocess.check_output(['adb', 'shell', 'wm', 'size']).decode()
    print(f"[DEBUG] adb wm size output:\n{output}")
    override_match = re.search(r'Override size:\s*(\d+)x(\d+)', output)
    if override_match:
        size = tuple(map(int, override_match.groups()))
        print(f"[DEBUG] Android override size: {size}")
        return size
    physical_match = re.search(r'Physical size:\s*(\d+)x(\d+)', output)
    if physical_match:
        size = tuple(map(int, physical_match.groups()))
        print(f"[DEBUG] Android physical size (fallback): {size}")
        return size
    raise RuntimeError("Could not determine Android screen size")


def get_scrcpy_window_rect():
    try:
        win_id = subprocess.check_output(['xdotool', 'search', '--name', 'scrcpy-bridge']).decode().strip().splitlines()[0]
    except subprocess.CalledProcessError:
        raise RuntimeError("Could not find scrcpy window")

    geo = subprocess.check_output(['xwininfo', '-id', win_id]).decode()
    x = int(re.search(r"Absolute upper-left X:\s+(\d+)", geo).group(1))
    y = int(re.search(r"Absolute upper-left Y:\s+(\d+)", geo).group(1))
    width = int(re.search(r"Width:\s+(\d+)", geo).group(1))
    height = int(re.search(r"Height:\s+(\d+)", geo).group(1))

    print(f"[DEBUG] scrcpy window rect: ({x}, {y}, {width}, {height})")
    return (x, y, width, height)


def map_to_android(x, y, window_rect, android_size):
    win_x, win_y, win_w, win_h = window_rect
    android_w, android_h = android_size

    android_aspect = android_w / android_h
    window_aspect = win_w / win_h

    if window_aspect > android_aspect:
        scale = win_h / android_h
        effective_w = android_w * scale
        margin_x = (win_w - effective_w) / 2
        rel_x = (x - win_x - margin_x) / effective_w
        rel_y = (y - win_y) / win_h
    else:
        scale = win_w / android_w
        effective_h = android_h * scale
        margin_y = (win_h - effective_h) / 2
        rel_x = (x - win_x) / win_w
        rel_y = (y - win_y - margin_y) / effective_h

    rel_x_clamped = max(0, min(1, rel_x))
    rel_y_clamped = max(0, min(1, rel_y))

    mapped_x = int(rel_x_clamped * android_w)
    mapped_y = int(rel_y_clamped * android_h)
    print(f"[DEBUG] Mouse clicked at: {x}, {y}")
    print(f"[DEBUG] Final Android tap: {mapped_x}, {mapped_y}")
    return mapped_x, mapped_y


def send_tap(x, y):
    print(f"[ADB] tap {x}, {y}")
    subprocess.run(["adb", "shell", "input", "tap", str(x), str(y)])


def load_clickmap():
    if os.path.exists(CLICKMAP_FILE):
        with open(CLICKMAP_FILE, "r") as f:
            return json.load(f)
    return {}


def save_clickmap(clickmap):
    with open(CLICKMAP_FILE, "w") as f:
        json.dump(clickmap, f, indent=2)


def start_click_logger(window_rect, android_size):
    clickmap = load_clickmap()

    def on_click(x, y, button, pressed):
        if not pressed:
            win_x, win_y, win_w, win_h = window_rect
            if not (win_x <= x <= win_x + win_w and win_y <= y <= win_y + win_h):
                print(f"[DEBUG] Ignoring click outside scrcpy window: {x}, {y}")
                return

            mapped_x, mapped_y = map_to_android(x, y, window_rect, android_size)
            send_tap(mapped_x, mapped_y)

            try:
                name = input("Enter name for this click (leave blank to skip): ").strip()
                if not name:
                    return
                if name in clickmap:
                    confirm = input(f"'{name}' already exists. Overwrite? (y/N): ").lower()
                    if confirm != 'y':
                        return
                clickmap[name] = {"x": mapped_x, "y": mapped_y}
                save_clickmap(clickmap)
                print(f"[INFO] Saved: {name} -> ({mapped_x}, {mapped_y})")
            except KeyboardInterrupt:
                print("\n[INFO] Interrupted, not saving this click.")

    listener = mouse.Listener(on_click=on_click)
    listener.start()


def launch_scrcpy():
    subprocess.Popen(["scrcpy", "--no-control", "--window-title", "scrcpy-bridge"])
    time.sleep(2)


def main():
    launch_scrcpy()
    android_size = get_android_screen_size()
    window_rect = get_scrcpy_window_rect()
    print("Click logger running. Ctrl+C to stop.")
    start_click_logger(window_rect, android_size)
    while True:
        time.sleep(1)


if __name__ == "__main__":
    main()
----------./old/old/scrcpy_adb_input_bridge.py----------------------
./old/old/scrcpy_adb_input_bridge.py
#!/usr/bin/env python3

import subprocess
import time
import re
from pynput import mouse
import cv2
import numpy as np

def get_android_screen_size():
    output = subprocess.check_output(['adb', 'shell', 'wm', 'size']).decode()
    print(f"[DEBUG] adb wm size output:\n{output}")
    override_match = re.search(r'Override size:\s*(\d+)x(\d+)', output)
    if override_match:
        size = tuple(map(int, override_match.groups()))
        print(f"[DEBUG] Android override size: {size}")
        return size
    physical_match = re.search(r'Physical size:\s*(\d+)x(\d+)', output)
    if physical_match:
        size = tuple(map(int, physical_match.groups()))
        print(f"[DEBUG] Android physical size (fallback): {size}")
        return size
    raise RuntimeError("Could not determine Android screen size")

def get_scrcpy_window_rect():
    import time

    try:
        win_id = subprocess.check_output(['xdotool', 'search', '--name', 'scrcpy-bridge']).decode().strip().splitlines()[0]
    except subprocess.CalledProcessError:
        raise RuntimeError("Could not find scrcpy window")

    tree = subprocess.check_output(['xwininfo', '-tree', '-id', win_id]).decode()
    print(f"[DEBUG] xwininfo -tree:\n{tree}")

    # Look for child window named "N/A"
    child_match = re.search(r'(0x[0-9a-f]+)\s+"N/A"', tree, re.IGNORECASE)
    if child_match:
        drawable_id = "0x" + child_match.group(1)
        width = int(child_match.group(2))
        height = int(child_match.group(3))
        x = int(child_match.group(4))
        y = int(child_match.group(5))
    else:
        print("[DEBUG] No child drawable window found; falling back to top-level window")

        fallback_match = re.search(r'Window id: (0x[0-9a-f]+) "scrcpy-bridge"', tree)
        if not fallback_match:
            raise RuntimeError("Could not find scrcpy window at all")
        drawable_id = fallback_match.group(1)

        # Loop until the geometry becomes stable
        max_wait = 5
        interval = 0.25
        min_width = 500
        min_height = 500
        attempts = int(max_wait / interval)

        for i in range(attempts):
            geo = subprocess.check_output(['xwininfo', '-id', drawable_id]).decode()
            width = int(re.search(r"Width:\s+(\d+)", geo).group(1))
            height = int(re.search(r"Height:\s+(\d+)", geo).group(1))
            x = int(re.search(r"Absolute upper-left X:\s+(\d+)", geo).group(1))
            y = int(re.search(r"Absolute upper-left Y:\s+(\d+)", geo).group(1))

            if width > min_width and height > min_height:
                print(f"[DEBUG] Window geometry stabilized after {i*interval:.1f}s")
                break
            else:
                print(f"[DEBUG] Waiting for window resize: {width}x{height} too small")
                time.sleep(interval)
        else:
            raise RuntimeError("scrcpy window did not reach expected size in time")

    print(f"[DEBUG] Drawable bounds: ({x}, {y}, {width}, {height})")
    return (x, y, width, height)


def map_to_android(x, y, window_rect, android_size):
    win_x, win_y, win_w, win_h = window_rect
    android_w, android_h = android_size

    android_aspect = android_w / android_h
    window_aspect = win_w / win_h

    print(f"[DEBUG] Mouse clicked at: {x}, {y}")
    print(f"[DEBUG] Window size: {win_w}x{win_h}, Android size: {android_w}x{android_h}")
    print(f"[DEBUG] Aspect ratio: win={window_aspect:.3f}, android={android_aspect:.3f}")

    if window_aspect > android_aspect:
        scale = win_h / android_h
        effective_w = android_w * scale
        margin_x = (win_w - effective_w) / 2
        rel_x = (x - win_x - margin_x) / effective_w
        rel_y = (y - win_y) / win_h
        print(f"[DEBUG] Letterboxing L/R: scale={scale:.4f}, margin_x={margin_x:.2f}")
    else:
        scale = win_w / android_w
        effective_h = android_h * scale
        margin_y = (win_h - effective_h) / 2
        rel_x = (x - win_x) / win_w
        rel_y = (y - win_y - margin_y) / effective_h
        print(f"[DEBUG] Letterboxing T/B: scale={scale:.4f}, margin_y={margin_y:.2f}")

    rel_x_clamped = max(0, min(1, rel_x))
    rel_y_clamped = max(0, min(1, rel_y))
    print(f"[DEBUG] Relative position unclamped: ({rel_x:.3f}, {rel_y:.3f})")
    print(f"[DEBUG] Relative position clamped: ({rel_x_clamped:.3f}, {rel_y_clamped:.3f})")

    mapped_x = int(rel_x_clamped * android_w)
    mapped_y = int(rel_y_clamped * android_h)
    print(f"[DEBUG] Final Android tap: {mapped_x}, {mapped_y}")
    return mapped_x, mapped_y

def send_tap(x, y):
    print(f"[ADB] tap {x}, {y}")
    subprocess.run(["adb", "shell", "input", "tap", str(x), str(y)])

def send_swipe(x1, y1, x2, y2, duration_ms):
    print(f"[ADB] swipe {x1},{y1} -> {x2},{y2} ({duration_ms}ms)")
    subprocess.run([
        "adb", "shell", "input", "swipe",
        str(x1), str(y1), str(x2), str(y2), str(duration_ms)
    ])

def get_pixel_color_at_android_coords(x, y):
    try:
        result = subprocess.run(
            ["adb", "exec-out", "screencap", "-p"],
            capture_output=True,
            check=True
        )
        image_bytes = result.stdout
        image_array = np.asarray(bytearray(image_bytes), dtype=np.uint8)
        img = cv2.imdecode(image_array, cv2.IMREAD_COLOR)
        b, g, r = img[y, x]
        return (r, g, b)
    except Exception as e:
        print(f"[ERROR] Failed to get pixel color at ({x}, {y}): {e}")
        return None

def start_mouse_listener(window_rect, android_size):
    press_pos = None
    press_time = None

    def on_click(x, y, button, pressed):
        nonlocal press_pos, press_time
    
        win_x, win_y, win_w, win_h = window_rect
        inside = (win_x <= x <= win_x + win_w and win_y <= y <= win_y + win_h)
    
        if not inside:
            if pressed:
                print(f"[DEBUG] Ignoring press outside scrcpy window: {x}, {y}")
            return
    
        if pressed:
            press_pos = (x, y)
            press_time = time.time()
            print(f"[DEBUG] Mouse down at: {x}, {y}")
        else:
            release_time = time.time()
            duration = int((release_time - press_time) * 1000)
            print(f"[DEBUG] Mouse up at: {x}, {y} (duration: {duration}ms)")
    
            if button == mouse.Button.left:
                start_x, start_y = map_to_android(*press_pos, window_rect, android_size)
                end_x, end_y = map_to_android(x, y, window_rect, android_size)
                if (start_x, start_y) == (end_x, end_y):
                    send_tap(start_x, start_y)
                    color = get_pixel_color_at_android_coords(start_x, start_y)
                    if color:
                        print(f"[DEBUG] Pixel color at ({start_x}, {start_y}) is RGB {color}")
                else:
                    send_swipe(start_x, start_y, end_x, end_y, duration)
    
            elif button == mouse.Button.right:
                print("[DEBUG] Sending BACK keyevent")
                subprocess.run(["adb", "shell", "input", "keyevent", "4"])
            elif button == mouse.Button.middle:
                print("[DEBUG] Sending HOME keyevent")
                subprocess.run(["adb", "shell", "input", "keyevent", "3"])

    listener = mouse.Listener(on_click=on_click)
    listener.start()

def launch_scrcpy():
    subprocess.Popen(["scrcpy", "--no-control", "--window-title", "scrcpy-bridge"])
    time.sleep(2)

def main():
    launch_scrcpy()
    android_size = get_android_screen_size()
    window_rect = get_scrcpy_window_rect()
    print(f"[INFO] Android screen size: {android_size}")
    print(f"[INFO] scrcpy drawable window: {window_rect}")
    start_mouse_listener(window_rect, android_size)
    print("Listening for clicks... Ctrl+C to quit.")
    while True:
        time.sleep(1)

if __name__ == "__main__":
    main()


----------./old/mission_demon_mode.py----------------------
./old/mission_demon_mode.py
# handlers/mission_demon_mode.py

import time
from core.ss_capture import capture_and_save_screenshot
from core.clickmap_access import tap_now
from core.floating_button_detector import detect_floating_buttons, tap_floating_button
from core.state_detector import detect_state_and_overlays
from core.label_tapper import tap_label_now
from utils.logger import log


def run_demon_mode(wait_seconds: int = 75):
    """
    Execute the 'Demon Mode -> Nuke -> Restart mission' sequence.

    Workflow:
      1. Wait for the game to be in the RUNNING state.
      2. Detect and tap the Demon Mode floating button when it appears.
      3. Wait for a configured duration (default: 75s) to allow Demon Mode effects.
      4. Open the menu (if closed) and tap 'End Round'.
      5. Confirm the end round by tapping 'Yes'.
      6. Tap 'Retry' on the game over screen to restart.

    Args:
        wait_seconds (int, optional):
            How long to wait after activating Demon Mode before ending the round.
            Default is 75 seconds.

    Returns:
        None — mission lifecycle only; no return value.

    Side effects:
        [adb] Captures device screenshots.
        [cv2] Processes images for state detection.
        [state] Reads game state from screen content.
        [tap] Sends tap commands to the device.
        [log] Emits structured logs.
        [loop] Waits in polling loops for game states/buttons.

    Errors:
        - KeyboardInterrupt stops loops immediately.
        - Tap-related exceptions are caught and logged without raising.
    """
    log("[MISSION] Starting Demon Mode -> Nuke -> Restart mission", "ACTION")

    # Step 1: Wait for RUNNING state
    while True:
        screen = capture_and_save_screenshot()
        result = detect_state_and_overlays(screen)
        if result["state"] == "RUNNING":
            log("[MISSION] Game is in RUNNING state", "INFO")
            break
        log("[MISSION] Waiting for RUNNING state...", "DEBUG")
        time.sleep(2)

    # Step 2: Wait for demon_mode button
    while True:
        screen = capture_and_save_screenshot()
        buttons = detect_floating_buttons(screen)
        if any(b["name"] == "floating_buttons.demon_mode" for b in buttons):
            log("[MISSION] Demon Mode button detected!", "INFO")
            tap_floating_button("floating_buttons.demon_mode", buttons)
            break
        log("[MISSION] Waiting for Demon Mode button...", "DEBUG")
        time.sleep(1)

    # Step 3: Wait for configured duration
    log(f"[MISSION] Demon Mode activated. Waiting {wait_seconds}s...", "INFO")
    for remaining in range(wait_seconds, 0, -1):
        print(f"\r[WAIT] {remaining} seconds remaining...", end="", flush=True)
        time.sleep(1)
    print("\r[WAIT] Done.                                                  ")

    # Step 4: End game sequence
    screen = capture_and_save_screenshot()
    result = detect_state_and_overlays(screen)
    if "MENU_OPEN" not in result["overlays"]:
        log("[MISSION] Menu is closed — opening it", "DEBUG")
        tap_now("overlays.toggle_menu")
        time.sleep(1)

    try:
        tap_label_now("overlays.end_round")
    except Exception as e:
        log(f"[MISSION] Failed to tap End Round: {e}", "WARN")
    time.sleep(1)

    try:
        screen = capture_and_save_screenshot()
        tap_label_now("buttons.yes:end_round")
    except Exception as e:
        log(f"[MISSION] Confirm Yes not visible: {e}", "WARN")
    time.sleep(1)

    try:
        screen = capture_and_save_screenshot()
        tap_label_now("buttons.retry:game_over")
    except Exception as e:
        log(f"[MISSION] Retry button not visible: {e}", "WARN")

    log("[MISSION] Demon-Mode strategy complete", "SUCCESS")
----------./old/automation/floating_gem.py----------------------
./old/automation/floating_gem.py
----------./old/automation/ad_gem.py----------------------
./old/automation/ad_gem.py
#!/usr/bin/env python3

import subprocess
import time
import threading
from core import tap_dispatcher
from utils.logger import log

from datetime import datetime

# --- Tap configuration ---
# "Ad gem" – taps every 10 seconds
AD_GEM_X = 148
AD_GEM_Y = 1143 
AD_GEM_INTERVAL = 10  # seconds

# "Floating gem" – taps every 1 second
FLOATING_GEM_X = 547
FLOATING_GEM_Y = 948
FLOATING_GEM_INTERVAL = 10  # seconds

def timestamp():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def tap(x, y, name):
    tap_dispatcher.tap(x, y, label=name)

def tap_loop(x, y, interval, name):
    log(f"Starting '{name}' loop at ({x}, {y}) every {interval}s", "INFO")
    while True:
        tap(x, y, name)
        time.sleep(interval)

def main():
    # Start tap loop for "Floating gem"
    thread_floating_gem = threading.Thread(
        target=tap_loop, args=(FLOATING_GEM_X, FLOATING_GEM_Y, FLOATING_GEM_INTERVAL, "Floating gem"), daemon=True)

    thread_floating_gem.start()

    log(f"Both tap loops running. Ctrl+C to stop.", "INFO")
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        log(f"Stopping tap loops.", "INFO")

if __name__ == "__main__":
    main()

----------./tools/tune_gesture.py----------------------
./tools/tune_gesture.py
#!/usr/bin/env python3

import os
import time
import json
import subprocess
import keyboard
from core.clickmap_access import tap_now, get_clickmap, save_clickmap
from core.adb_utils import adb_shell


def load_clickmap():
    """Return the current in-memory clickmap dict from core.clickmap_access."""
    return get_clickmap()


def run_adb_swipe(x1, y1, x2, y2, duration):
    """Inject a swipe via centralized adb_shell."""
    adb_shell(["input", "swipe", str(x1), str(y1), str(x2), str(y2), str(duration)])


def choose_gesture(clickmap):
    """Interactively select a gesture entry (tap/swipe) from the clickmap."""
    print("Available gestures:")
    entries = list(clickmap.items())
    for idx, (key, val) in enumerate(entries, 1):
        gtype = "swipe" if "swipe" in val else ("tap" if "tap" in val else "unknown")
        print(f"[{idx}] {key:20} ({gtype})")
    while True:
        try:
            i = int(input("Enter gesture number: ")) - 1
            if 0 <= i < len(entries):
                return entries[i][0], entries[i][1]
        except ValueError:
            continue


def edit_swipe(name, swipe_entry):
    """Keyboard UI to tweak x2/y2/duration for a swipe, replay, and save/back."""
    print(f"\nEditing: {name}")
    print_controls()
    while True:
        os.system('clear' if os.name == 'posix' else 'cls')
        print(f"\nEditing: {name}")
        print(f"Start:   (x1={swipe_entry['x1']}, y1={swipe_entry['y1']})")
        print(f"End:     (x2={swipe_entry['x2']}, y2={swipe_entry['y2']})")
        print(f"Duration: {swipe_entry['duration_ms']} ms\n")
        print_controls()

        event = keyboard.read_event()
        if event.event_type != keyboard.KEY_DOWN:
            continue
        key = event.name

        if key == "left": swipe_entry["x2"] -= 10
        elif key == "right": swipe_entry["x2"] += 10
        elif key == "up": swipe_entry["y2"] -= 10
        elif key == "down": swipe_entry["y2"] += 10
        elif key in ("+", "="):
            swipe_entry["duration_ms"] += 100
        elif key in ("-", "\u2212", "minus"):
            swipe_entry["duration_ms"] = max(50, swipe_entry["duration_ms"] - 100)
        elif key == "r":
            run_adb_swipe(
                swipe_entry["x1"], swipe_entry["y1"],
                swipe_entry["x2"], swipe_entry["y2"],
                swipe_entry["duration_ms"]
            )
        elif key == "s":
            return swipe_entry  # save and exit
        elif key == "b":
            print("[INFO] Going back to gesture list.")
            return None  # sentinel for back
        elif key == "q":
            print("[INFO] Discarding changes and exiting.")
            exit()


def run_tap(name):
    """Small loop to replay a tap gesture by name or return/quit."""
    print(f"\nReady to tap: {name}")
    print("[r] Replay | [b] Back to gesture list | [q] Quit")
    while True:
        key = keyboard.read_event()
        if key.event_type != keyboard.KEY_DOWN:
            continue
        k = key.name
        if k == "r":
            tap_now(name)
        elif k == "b":
            return
        elif k == "q":
            exit()


def print_controls():
    """Print keyboard controls for swipe tuning."""
    print("[←/→]: Adjust x2 | [↑/↓]: Adjust y2")
    print("[+/-]: Adjust duration (ms)")
    print("[r]: Replay gesture")
    print("[s]: Save and exit")
    print("[q]: Quit without saving\n")


def main():
    """Interactive gesture tuner: choose entries, tweak swipes, replay taps, save."""
    clickmap = load_clickmap()

    while True:
        name, entry = choose_gesture(clickmap)
        if "swipe" in entry:
            updated = edit_swipe(name, entry["swipe"].copy())
            if updated is not None:
                entry["swipe"] = updated
                clickmap[name] = entry
                save_clickmap(clickmap)
        elif "tap" in entry:
            run_tap(name)


if __name__ == "__main__":
    main()
----------./tools/gesture_logger.py----------------------
./tools/gesture_logger.py
#!/usr/bin/env python3

import argparse
import json
import select
import subprocess
import time
from pathlib import Path

from core.clickmap_access import (
    get_clickmap,
    save_clickmap,
    resolve_dot_path,
    interactive_get_dot_path,
)
from core.adb_utils import adb_shell


JSON_PREFIX = "__GESTURE_JSON__"

# -------------------- Bridge Manager (no globals) --------------------

class ScrcpyBridge:
    """Owns the scrcpy worker process and its stdout stream (JSON gestures)."""

    def __init__(self):
        self.proc = None
        self._script = str((Path(__file__).parent / "scrcpy_adb_input_bridge.py").resolve())

    def start(self):
        if self.proc and self.proc.poll() is None:
            return
        print("[INFO] Launching scrcpy_adb_input_bridge.py with --json-stream")
        self.proc = subprocess.Popen(
            ["python3", self._script, "--json-stream"],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,   # we filter by prefix anyway
            text=True,
            bufsize=1,
            encoding="utf-8",
        )

    def ensure_running(self):
        if not self.proc or self.proc.poll() is not None:
            self.start()

    def stop(self):
        if not self.proc:
            return
        print("[INFO] Stopping scrcpy bridge...")
        self.proc.terminate()
        try:
            self.proc.wait(timeout=5)
        except subprocess.TimeoutExpired:
            self.proc.kill()
        self.proc = None

    def __enter__(self):
        self.ensure_running()
        # small settle to let scrcpy window come up; avoid accidental early reads
        time.sleep(2)
        return self

    def __exit__(self, exc_type, exc, tb):
        self.stop()

    def flush_old(self):
        """Discard any buffered gesture JSON lines already emitted by the bridge."""
        if not self.proc or not self.proc.stdout:
            return
        fd = self.proc.stdout.fileno()
        while True:
            ready, _, _ = select.select([fd], [], [], 0)
            if not ready:
                break
            line = self.proc.stdout.readline()
            if not line:
                break  # EOF
            if line.startswith(JSON_PREFIX):
                # discard stale gesture line
                continue

    def read_gesture(self):
        """Block until a fresh gesture JSON line arrives; return parsed dict."""
        if not self.proc or not self.proc.stdout:
            raise RuntimeError("Bridge not running or stdout unavailable.")
        for line in self.proc.stdout:
            if not line:
                break  # EOF
            line = line.strip()
            if not line.startswith(JSON_PREFIX):
                continue
            payload = line[len(JSON_PREFIX):]
            try:
                return json.loads(payload)
            except json.JSONDecodeError as e:
                print(f"[ERROR] Failed to parse JSON gesture: {e}")
                continue
        raise RuntimeError("Bridge exited before producing gesture")


# -------------------- Utility actions --------------------

def replay_gesture(gesture):
    """
    Inject a captured gesture via centralized ADB helper.

    Args:
        gesture (dict): {"type":"tap","x","y"} or
                        {"type":"swipe","x1","y1","x2","y2","duration_ms"?}

    Returns:
        action result (side effects only)

    Errors:
        CalledProcessError when ADB command fails (via adb_shell).
    """
    t = gesture.get("type")
    if t == "tap":
        x, y = gesture["x"], gesture["y"]
        print(f"[REPLAY] tap {x}, {y}")
        adb_shell(["input", "tap", str(x), str(y)])
    elif t == "swipe":
        x1, y1 = gesture["x1"], gesture["y1"]
        x2, y2 = gesture["x2"], gesture["y2"]
        duration = gesture.get("duration_ms", 300)
        print(f"[REPLAY] swipe {x1},{y1} -> {x2},{y2} ({duration}ms)")
        adb_shell(["input", "swipe", str(x1), str(y1), str(x2), str(y2), str(duration)])
    else:
        print(f"[REPLAY] Unsupported gesture type: {t}")


# -------------------- Deduped capture/save helpers --------------------

def ensure_entry(dot_path):
    """
    Confirm the clickmap entry exists or interactively create it.
    Returns (clickmap, entry) or (None, None) if user declines.
    """
    clickmap = get_clickmap()
    entry = resolve_dot_path(dot_path)
    if entry is None:
        print(f"[WARN] Entry '{dot_path}' does not exist.")
        confirm = input(f"Create new gesture entry at '{dot_path}'? (y/N): ").strip().lower()
        if confirm != 'y':
            return None, None
        group, key = dot_path.split(".", 1)
        clickmap.setdefault(group, {})[key] = {"roles": ["gesture"]}
        entry = clickmap[group][key]
    return clickmap, entry


def record_and_save(bridge: ScrcpyBridge, dot_path: str):
    """
    Common flow: ensure entry, flush, capture one gesture, validate, save, optional replay.
    """
    clickmap, entry = ensure_entry(dot_path)
    if not entry:
        print("[INFO] Gesture not saved.")
        return

    print(f"[INFO] Recording gesture for '{dot_path}' — perform the gesture now.")
    bridge.flush_old()
    gesture = bridge.read_gesture()

    t = gesture.get("type")
    if t not in ("tap", "swipe"):
        print(f"[ERROR] Unsupported gesture type: {t}")
        return

    entry[t] = gesture
    save_clickmap(clickmap)
    print(f"[INFO] Gesture saved under '{dot_path}'")

    replay = input("Replay this gesture? (Y/n): ").strip().lower()
    if replay in ("", "y", "yes"):
        replay_gesture(gesture)


# -------------------- Main --------------------

def main():
    """
    CLI entrypoint for recording gestures into the clickmap.

    Flags:
        --name <dot_path>  Save exactly one gesture under the given dot_path and exit.
                           Without --name, runs interactive selection loop until Ctrl+C.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("--name", help="dot_path to save gesture under")
    args = parser.parse_args()

    with ScrcpyBridge() as bridge:
        try:
            if args.name:
                record_and_save(bridge, args.name)
            else:
                print("[INFO] Interactive mode. Press Ctrl+C to exit.")
                while True:
                    dot_path = interactive_get_dot_path(get_clickmap())
                    if not dot_path:
                        print("[INFO] No path selected. Exiting.")
                        break
                    record_and_save(bridge, dot_path)

        except KeyboardInterrupt:
            print("\n[INFO] Exiting gesture logger.")

if __name__ == "__main__":
    main()
----------./tools/split_specs.py----------------------
./tools/split_specs.py
#!/usr/bin/env python3
# Split a combined specs file into individual .py.md files.
# Sections are separated by a line that is exactly '---------------'.
# For each section, the FIRST NON-EMPTY LINE is the module path like 'core/foo.py'.
# We write the whole section verbatim to '<out>/<core/foo.py>.md'.

import argparse, sys
from pathlib import Path

DELIM = "---------------"

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--in", dest="infile", required=True, help="Combined specs file")
    ap.add_argument("--out", dest="outdir", required=True, help="Output directory")
    args = ap.parse_args()

    combined = Path(args.infile).read_text(encoding="utf-8").splitlines()
    outroot = Path(args.outdir)

    # Split by delimiter lines (exact match after strip)
    blocks, cur = [], []
    for line in combined:
        if line.strip() == DELIM:
            if cur:
                blocks.append(cur); cur = []
            continue
        cur.append(line)
    if any(s.strip() for s in cur):
        blocks.append(cur)

    if not blocks:
        print("No sections found. Ensure sections are separated by a line '---------------'.", file=sys.stderr)
        sys.exit(1)

    outroot.mkdir(parents=True, exist_ok=True)
    written = 0
    for block in blocks:
        # Trim leading/trailing blank lines in the block (but keep internal spacing)
        while block and block[0].strip() == "":
            block.pop(0)
        while block and block[-1].strip() == "":
            block.pop()

        if not block:
            continue

        # First non-empty line is the module path (e.g., 'core/foo.py')
        module_line = block[0].strip()
        if not module_line.endswith(".py"):
            print(f"Skipping block (first line not a .py path): {module_line}", file=sys.stderr)
            continue

        out_path = outroot / (module_line + ".md")
        out_path.parent.mkdir(parents=True, exist_ok=True)
        text = "\n".join(block).rstrip() + "\n"
        out_path.write_text(text, encoding="utf-8")
        print(f"Wrote {out_path}")
        written += 1

    print(f"Done. Sections written: {written}")

if __name__ == "__main__":
    main()
----------./tools/crop_region.py----------------------
./tools/crop_region.py
#!/usr/bin/env python3
# tools/crop_region.py

import os
import cv2
import json
import time
import subprocess

from core.ss_capture import capture_and_save_screenshot
from core.clickmap_access import (
    get_clickmap,
    save_clickmap,
    interactive_get_dot_path,
    prompt_roles,
    set_dot_path,
)

# Constants
SOURCE_PATH = "screenshots/latest.png"
TEMPLATE_DIR = "assets/match_templates"
GESTURE_LOGGER_PATH = "tools/gesture_logger.py"
SCRCPY_TITLE = "scrcpy-bridge"
WINDOW_NAME = "Crop Tool"
DEFAULT_THRESHOLD = 0.9
SCROLL_STEP = 60

# Globals
clickmap = get_clickmap()
cropping = False
start_point = None
end_point = None
scroll_offset = 0
viewport_height = 0  # set in main()
viewport_width = 0   # set in main()

# Regions that are coordinates-only (no template image saved)
COORDS_ONLY_GROUPS = {"_shared_match_regions"}   # e.g., shared helpers for region_ref consumers
COORDS_ONLY_PREFIXES = set()  # e.g., {"util.scroll_areas"} if needed later

# Detect screen size
try:
    import tkinter as tk
    root = tk.Tk()
    root.withdraw()
    screen_height = root.winfo_screenheight()
    screen_width = root.winfo_screenwidth()
    root.destroy()
except Exception as e:
    print("[WARN] Could not detect screen size. Defaulting to 1920x1080")
    screen_width, screen_height = 1920, 1080

def reload_image():
    """Capture a fresh screenshot, initialize globals (image/clone/img_w/h), reset scroll, and focus the window.

    Inputs: none (uses ADB via capture_and_save_screenshot()).
    Writes: updates globals image, clone, img_height, img_width; resets scroll_offset; saves screenshots/latest.png on disk.
    Prompts: none (silent, except printed INFO).
    """
    global image, clone, img_height, img_width, scroll_offset
    image = capture_and_save_screenshot()
    if image is None:
        raise RuntimeError("[ERROR] Could not capture screenshot.")
    clone = image.copy()
    img_height, img_width = image.shape[:2]
    scroll_offset = 0
    print("[INFO] Screenshot updated.")
    subprocess.run(["xdotool", "search", "--name", WINDOW_NAME, "windowactivate"],
                   stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    print("[INFO] Click and drag to select region.")
    print("[INFO] Scroll with mouse wheel or ↑/↓ arrow keys. Press 'q' or ESC to quit.")
    print("[INFO] Press 'r' to reload screenshot at any time.")

def is_coords_only(dot_path: str) -> bool:
    """Return True if the dot_path belongs to a coords-only group or prefix (no template to save)."""
    parts = dot_path.split(".")
    if not parts:
        return False
    if parts[0] in COORDS_ONLY_GROUPS:
        return True
    return any(dot_path == p or dot_path.startswith(p + ".") for p in COORDS_ONLY_PREFIXES)

def _dot_path_exists(root: dict, dot_path: str) -> bool:
    """Internal: check whether dot_path already exists in the clickmap dict."""
    cur = root
    for part in dot_path.split("."):
        if not isinstance(cur, dict) or part not in cur:
            return False
        cur = cur[part]
    return True

def save_template_crop_and_entry(x1, y1, x2, y2):
    """Persist a cropped region to disk and clickmap; optionally launch gesture logger.

    Inputs: crop box (x1,y1,x2,y2) in screenshot coordinates.
    Writes:
      - For coords-only: stores match_region under the chosen dot_path in clickmap.json.
      - For template-backed: writes PNG under assets/match_templates/<...>, and stores match_template/match_region/match_threshold[/roles].
    Prompts:
      - Dot-path selection.
      - Overwrite confirmation if the key exists.
      - For template-backed: threshold (default 0.90), roles, and optional gesture capture.
    """
    global clickmap

    w, h = x2 - x1, y2 - y1
    crop = clone[y1:y2, x1:x2]
    if crop.size == 0:
        print("[WARN] Empty crop. Try again.")
        return

    dot_path = interactive_get_dot_path(clickmap)
    if dot_path is None:
        return

    parts = dot_path.split(".")
    if len(parts) < 2:
        print(f"[ERROR] Invalid dot-path key: '{dot_path}'")
        return

    group = parts[0]
    key = parts[-1]
    subdir_parts = parts[1:-1]

    coordinate_only = is_coords_only(dot_path)

    # Overwrite confirmation
    if _dot_path_exists(clickmap, dot_path):
        resp = input(f"[WARN] '{dot_path}' exists. Overwrite? (y/N): ").strip().lower()
        if resp not in ("y", "yes"):
            print("[INFO] Skipping save (user declined overwrite).")
            reload_image()
            return

    if coordinate_only:
        entry = {
            "match_region": {"x": x1, "y": y1, "w": w, "h": h}
        }
        set_dot_path(dot_path, entry, allow_overwrite=True)
        save_clickmap(clickmap)
        print(f"[INFO] (coords-only) Region saved for '{dot_path}' (no image/threshold/roles)")
        # Skip gesture prompt for coords-only
        reload_image()
        return

    if subdir_parts:
        template_subdir = os.path.join(*subdir_parts)
        template_dir = os.path.join(TEMPLATE_DIR, group, template_subdir)
        match_template = f"{group}/{template_subdir}/{key}.png"
    else:
        template_dir = os.path.join(TEMPLATE_DIR, group)
        match_template = f"{group}/{key}.png"

    # Save template image
    os.makedirs(template_dir, exist_ok=True)
    template_path = os.path.join(template_dir, f"{key}.png")
    cv2.imwrite(template_path, crop)

    print(f"[INFO] Template saved: {template_path}")

    threshold_input = input(f"Enter match threshold (default {DEFAULT_THRESHOLD:.2f}): ").strip()
    threshold = float(threshold_input) if threshold_input else DEFAULT_THRESHOLD

    roles = prompt_roles(group, key)
    entry = {
        "match_template": match_template,
        "match_region": {"x": x1, "y": y1, "w": w, "h": h},
        "match_threshold": threshold,
        "roles": roles
    }

    set_dot_path(dot_path, entry, allow_overwrite=True)
    save_clickmap(clickmap)
    print(f"[INFO] Clickmap entry saved for '{dot_path}'")

    ask_gesture = input("Define a gesture for this region now? (Y/n): ").strip().lower()
    if ask_gesture in ("", "y", "yes"):
        subprocess.run(["python3", GESTURE_LOGGER_PATH, "--name", dot_path])

    reload_image()

def handle_mouse(event, x, y, flags, param):
    """Mouse callback: manages scroll with wheel, drag-selects a box, and triggers save on release.

    Inputs: cv2 mouse event args.
    Writes: may update globals (start_point, end_point, cropping, scroll_offset); may persist template/region on mouse up.
    Prompts: as per save_template_crop_and_entry().
    """
    global cropping, start_point, end_point, scroll_offset, image, viewport_height
    adjusted_y = y + scroll_offset

    if event == cv2.EVENT_MOUSEWHEEL:
        direction = 1 if flags > 0 else -1
        # Bound within [0, img_height - viewport_height]
        max_scroll = max(0, img_height - viewport_height)
        scroll_offset = min(max(0, scroll_offset - direction * SCROLL_STEP), max_scroll)
        return

    if event == cv2.EVENT_LBUTTONDOWN:
        start_point = (x, adjusted_y)
        cropping = True
        end_point = None

    elif event == cv2.EVENT_MOUSEMOVE and cropping:
        end_point = (x, adjusted_y)

    elif event == cv2.EVENT_LBUTTONUP:
        end_point = (x, adjusted_y)
        cropping = False
        x1, y1 = min(start_point[0], end_point[0]), min(start_point[1], end_point[1])
        x2, y2 = max(start_point[0], end_point[0]), max(start_point[1], end_point[1])
        save_template_crop_and_entry(x1, y1, x2, y2)

def main():
    global scroll_offset, viewport_height, viewport_width
    # --- Main Loop ---
    reload_image()
    viewport_width = min(img_width, screen_width)
    viewport_height = min(img_height, screen_height - 100)

    cv2.namedWindow(WINDOW_NAME, cv2.WINDOW_NORMAL)
    cv2.resizeWindow(WINDOW_NAME, viewport_width, viewport_height)
    cv2.setMouseCallback(WINDOW_NAME, handle_mouse)

    print("[INFO] Click and drag to select region.")
    print("[INFO] Scroll with mouse wheel or ↑/↓ arrow keys. Press 'q' or ESC to quit.")
    print("[INFO] Press 'r' to reload screenshot at any time.")

    while True:
        top = scroll_offset
        bottom = min(scroll_offset + viewport_height, img_height)
        display = image[top:bottom].copy()

        if cropping and start_point and end_point:
            sp = (start_point[0], start_point[1] - scroll_offset)
            ep = (end_point[0], end_point[1] - scroll_offset)
            cv2.rectangle(display, sp, ep, (0, 255, 0), 2)

        cv2.imshow(WINDOW_NAME, display)
        key = cv2.waitKey(20) & 0xFF

        if key == 27 or key == ord("q"):
            break
        elif key == 82:  # Up arrow
            scroll_offset = max(0, scroll_offset - SCROLL_STEP)
        elif key == 84:  # Down arrow
            scroll_offset = min(scroll_offset + SCROLL_STEP, max(0, img_height - viewport_height))
        elif key == ord("r"):
            reload_image()

    cv2.destroyAllWindows()

if __name__ == "__main__":
    main()


----------./tools/auto_label_upgrades.py----------------------
./tools/auto_label_upgrades.py
#!/usr/bin/env python3
# tools/auto_label_upgrades.py
#
# Auto-generate upgrade label templates and clickmap entries by scanning the
# scrollable upgrades list. Template = FULL LEFT TILE up to—but not including—
# the small value panel on the right. Color-agnostic, adaptive scroll, review dump.

import os
import re
import time
import argparse
import json
from datetime import datetime
from pathlib import Path
from typing import Tuple, List, Dict, Optional

import cv2
import numpy as np

from utils.logger import log
from utils.ocr_utils import ocr_text, preprocess_binary
from core.ss_capture import capture_adb_screenshot
from core.clickmap_access import resolve_dot_path, set_dot_path, save_clickmap, get_clickmap
from core.label_tapper import page_column  # adaptive scroll

# ------------------------- TUNABLES -------------------------------------------

LEFT_SHARED_KEY  = "_shared_match_regions.upgrades_left"
RIGHT_SHARED_KEY = "_shared_match_regions.upgrades_right"

POST_SWIPE_SLEEP = 0.35  # UI settle time after swipe (s)

# Expand detection ROI so rows near the edges aren't truncated
DETECT_PAD_PX = 24

# Cyan-ish border threshold (rows). Row borders are consistently neon/teal.
ROW_BORDER_HSV_LOWER = np.array([75,  80, 120], dtype=np.uint8)
ROW_BORDER_HSV_UPPER = np.array([110, 255, 255], dtype=np.uint8)

# Row filtering relative to column ROI size
MIN_ROW_AREA_FRAC = 0.06
MIN_ROW_ASPECT    = 1.6
MAX_ROW_ASPECT    = 6.0

# Right-panel detection (contours) — color-agnostic (edge-based); then
# fallback split-line (vertical gradient) if panel contour not found.
RIGHT_MIN_X_FRAC       = 0.52              # must be right half
RIGHT_AREA_FRAC_MINMAX = (0.03, 0.60)      # fraction of row area
RIGHT_ASPECT_MINMAX    = (0.30, 2.20)      # w/h, tall-ish rectangle

# Split-line search zone (relative to row width)
SPLIT_SEARCH_FRAC      = (0.50, 0.92)      # only look in right half
SPLIT_BOX_SMOOTH_PX    = 9                 # 1D smoothing window for energy
SPLIT_MIN_STD_MULT     = 0.6               # require peak > mean + k*std

# Insets & gap (pixels)
ROW_INSET_PX  = 10    # shave borders inside the row to avoid glow
LABEL_GAP_PX  = 6     # space between label crop and right panel / split

# Fallback label crop if neither panel nor split-line found
FALLBACK_LABEL_WIDTH_FRAC = 0.64

DEFAULT_THRESHOLD = 0.90
DEFAULT_ROLES     = ["upgrade_label"]
SIM_MATCH_THRESHOLD = 0.72  # fallback name inference via template similarity (tuned)

# Edge detection when paging
EDGE_EPSILON = 0.004
Y_SEEN_DELTA = 12  # px tolerance to de-dup rows across pages by Y position

# Only keep rows fully visible inside the ORIGINAL column ROI
VISIBLE_MARGIN_PX = 0
MIN_HEIGHT_FRAC_OF_MEDIAN = 0.82  # drop short rows (likely clipped)

# -----------------------------------------------------------------------------


def _slugify(text: str) -> str:
    text = text.strip().lower()
    text = re.sub(r"[^a-z0-9]+", "_", text)
    text = re.sub(r"_+", "_", text).strip("_")
    return text or "unknown"

def _all_known_slugs_for_category(category: str) -> List[str]:
    """Collect existing label slugs for a category from assets folders.
    This helps name new crops when OCR is noisy.
    """
    base = Path("assets/match_templates/upgrades") / category
    slugs: set = set()
    for side in ("left", "right"):
        d = base / side
        if d.is_dir():
            for p in d.glob("*.png"):
                slugs.add(p.stem.lower())
    return sorted(slugs)

def _infer_slug_by_similarity(label_img: np.ndarray, category: str) -> Optional[str]:
    """Try to infer a canonical slug by comparing the crop to existing templates.
    Returns slug or None if no sufficiently strong match is found.
    """
    known = _all_known_slugs_for_category(category)
    if not known:
        return None

    # Prepare candidate list of (slug, template_img)
    candidates: List[Tuple[str, np.ndarray]] = []
    base = Path("assets/match_templates/upgrades") / category
    for side in ("left", "right"):
        d = base / side
        for slug in known:
            p = d / f"{slug}.png"
            if p.exists():
                tpl = cv2.imread(str(p), cv2.IMREAD_GRAYSCALE)
                if tpl is not None:
                    candidates.append((slug, tpl))

    if not candidates:
        return None

    # Ensure working grayscale for crop
    crop = label_img
    if crop.ndim == 3:
        crop = cv2.cvtColor(crop, cv2.COLOR_BGR2GRAY)

    best_slug: Optional[str] = None
    best_score: float = -1.0
    for slug, tpl in candidates:
        h, w = tpl.shape[:2]
        # Resize crop to template size for direct similarity
        resized = cv2.resize(crop, (w, h), interpolation=cv2.INTER_AREA)
        res = cv2.matchTemplate(resized, tpl, cv2.TM_CCOEFF_NORMED)
        _minv, maxv, _minl, _maxl = cv2.minMaxLoc(res)
        if maxv > best_score:
            best_score = maxv
            best_slug = slug

    if best_score >= SIM_MATCH_THRESHOLD:
        return best_slug
    return None

def _canonical_slug_from_keywords(raw: str, category: str) -> Optional[str]:
    """Map noisy OCR text to a canonical slug using keyword rules."""
    t = raw.lower()
    letters = re.sub(r"[^a-z]+", " ", t)
    # Helpers
    has = lambda *ws: all(w in letters for w in ws)

    if category == "attack":
        # Left column
        if has("bounce", "range"): return "bounce_shot_range"
        if has("bounce", "chance"): return "bounce_shot_chance"
        if has("rapid", "chance"):  return "rapid_fire_chance"
        if has("multi", "chance"):  return "multishot_chance"
        if has("critical", "chance"):return "critical_chance"
        if has("rend", "armor") and ("mult" in letters or "multi" in letters): return "rend_armor_mult"
        if has("damage") and "per" not in letters: return "damage"
        if has("range") and "bounce" not in letters: return "range"
        # Right column
        if has("attack", "speed"): return "attack_speed"
        if has("critical", "factor"): return "critical_factor"
        if has("damage", "per", "meter"): return "damage_per_meter"
        if has("multi", "targets"): return "multishot_targets"
        if has("rapid", "duration"): return "rapid_fire_duration"
        if has("bounce", "targets"): return "bounce_shot_targets"
        if has("super", "crit", "chance"): return "super_crit_chance"
        if has("super", "crit") and ("mult" in letters or "multiplier" in letters): return "super_crit_mult"
        if has("rend", "armor", "chance"): return "rend_armor_chance"
    return None

def _read_shared_region(dot_key: str) -> Tuple[int, int, int, int]:
    entry = resolve_dot_path(dot_key)
    if not entry or "match_region" not in entry:
        raise RuntimeError(f"Missing shared region: {dot_key}")
    r = entry["match_region"]
    return int(r["x"]), int(r["y"]), int(r["w"]), int(r["h"])

def _crop(img: np.ndarray, rect: Tuple[int,int,int,int]) -> np.ndarray:
    x,y,w,h = rect
    return img[y:y+h, x:x+w].copy()

def _roi_change_ratio(a: np.ndarray, b: np.ndarray) -> float:
    if a.shape != b.shape:
        h = min(a.shape[0], b.shape[0])
        w = min(a.shape[1], b.shape[1])
        a = cv2.resize(a, (w, h))
        b = cv2.resize(b, (w, h))
    a_g = cv2.cvtColor(a, cv2.COLOR_BGR2GRAY)
    b_g = cv2.cvtColor(b, cv2.COLOR_BGR2GRAY)
    diff = cv2.absdiff(a_g, b_g)
    return float(diff.mean()) / 255.0

def _visible_row_tops(img: np.ndarray, side: str) -> List[int]:
    """Return Y positions of fully visible rows inside the shared upgrades column."""
    x0,y0,w0,h0 = _read_shared_region(LEFT_SHARED_KEY if side=="left" else RIGHT_SHARED_KEY)
    Hs, Ws = img.shape[:2]
    x = x0
    y = max(0, y0 - DETECT_PAD_PX)
    w = w0
    h = min(h0 + 2*DETECT_PAD_PX, Hs - y)
    col_roi_ext = _crop(img, (x,y,w,h))
    rows_local = _detect_row_rects(col_roi_ext)
    rows_full = [(x+rx, y+ry, rw, rh) for (rx,ry,rw,rh) in rows_local]
    def _fully_visible(r):
        rx, ry, rw, rh = r
        return (ry >= y0 + VISIBLE_MARGIN_PX) and (ry + rh <= y0 + h0 - VISIBLE_MARGIN_PX)
    rows_full = [r for r in rows_full if _fully_visible(r)]
    if rows_full:
        med_h = float(np.median([rh for (_,_,_,rh) in rows_full]))
        rows_full = [r for r in rows_full if r[3] >= MIN_HEIGHT_FRAC_OF_MEDIAN * med_h]
    return [r[1] for r in rows_full]

def scroll_to_edge(column: str, to_top: bool, max_swipes: int = 16) -> bool:
    rect = _read_shared_region(LEFT_SHARED_KEY if column=="left" else RIGHT_SHARED_KEY)
    img = capture_adb_screenshot()
    if img is None:
        raise RuntimeError("No screenshot from device.")
    prev = _crop(img, rect)
    for _ in range(max_swipes):
        page_column(column, "up" if to_top else "down", strength="page")
        time.sleep(POST_SWIPE_SLEEP)
        img2 = capture_adb_screenshot()
        if img2 is None:
            continue
        roi = _crop(img2, rect)
        change = _roi_change_ratio(prev, roi)
        if change < EDGE_EPSILON:
            return True
        prev = roi
    return False

# --- Row and panel/split detection -------------------------------------------

def _detect_row_rects(col_roi: np.ndarray) -> List[Tuple[int,int,int,int]]:
    """Find row rectangles via teal border (no visibility filtering here)."""
    hsv = cv2.cvtColor(col_roi, cv2.COLOR_BGR2HSV)
    mask = cv2.inRange(hsv, ROW_BORDER_HSV_LOWER, ROW_BORDER_HSV_UPPER)
    kernel = np.ones((5,5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=2)
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    H, W = col_roi.shape[:2]
    min_area = MIN_ROW_AREA_FRAC * (H*W)
    rects: List[Tuple[int,int,int,int]] = []
    for c in contours:
        x,y,w,h = cv2.boundingRect(c)
        area = w*h
        if area < min_area:
            continue
        ar = w / float(h + 1e-6)
        if not (MIN_ROW_ASPECT <= ar <= MAX_ROW_ASPECT):
            continue
        # clip and keep
        x = max(0, x); y = max(0, y)
        w = min(W - x, w); h = min(H - y, h)
        rects.append((x,y,w,h))

    rects.sort(key=lambda r: r[1])
    # de-dup by Y proximity
    deduped: List[Tuple[int,int,int,int]] = []
    last_y = -10**9
    for r in rects:
        if not deduped or abs(r[1] - last_y) > 10:
            deduped.append(r)
            last_y = r[1]
    return deduped

def _find_right_panel_by_contours(row_img: np.ndarray) -> Optional[Tuple[int,int,int,int]]:
    """Color-agnostic right-panel via edges + contours in right-half."""
    H, W = row_img.shape[:2]
    gray = cv2.cvtColor(row_img, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (5,5), 0)
    edges = cv2.Canny(gray, 40, 110)
    kernel = np.ones((3,3), np.uint8)
    edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel, iterations=2)

    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    row_area = float(W * H)
    cand = None
    cand_score = -1.0

    for c in contours:
        x,y,w,h = cv2.boundingRect(c)
        # ignore huge outer row or tiny fragments
        area_frac = (w*h) / row_area
        if not (RIGHT_AREA_FRAC_MINMAX[0] <= area_frac <= RIGHT_AREA_FRAC_MINMAX[1]):
            continue
        if (x + w/2.0) / W < RIGHT_MIN_X_FRAC:
            continue
        ar = w / float(h + 1e-6)
        if not (RIGHT_ASPECT_MINMAX[0] <= ar <= RIGHT_ASPECT_MINMAX[1]):
            continue
        score = (x + w) + 0.1 * (w*h)  # prefer further right & slightly larger
        if score > cand_score:
            cand = (x,y,w,h)
            cand_score = score

    return cand

def _find_split_line_x(row_img: np.ndarray) -> Optional[int]:
    """Find vertical split by gradient energy; robust to color (works for gold/blue)."""
    H, W = row_img.shape[:2]
    gray = cv2.cvtColor(row_img, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (3,3), 0)
    gx = cv2.Sobel(gray, cv2.CV_32F, 1, 0, ksize=3)
    energy = np.abs(gx).sum(axis=0)
    L = int(SPLIT_SEARCH_FRAC[0] * W)
    R = int(SPLIT_SEARCH_FRAC[1] * W)
    if R <= L + 5:
        return None
    seg = energy[L:R].astype(np.float32)
    k = max(1, int(SPLIT_BOX_SMOOTH_PX))
    seg = cv2.blur(seg.reshape(1, -1), (1, k)).flatten()
    idx = int(seg.argmax())
    peak = float(seg[idx])
    mean, std = float(seg.mean()), float(seg.std() + 1e-6)
    if peak < mean + SPLIT_MIN_STD_MULT * std:
        return None
    return L + idx

def _compute_label_and_panel(row_rect: Tuple[int,int,int,int], img: np.ndarray):
    """
    Given full-screen row_rect, compute:
      - label_rect: full left tile up to (but not including) the right panel/split
      - panel_rect: right panel rect if detected (else None)
      - split_x_abs: absolute split x if used (else None)
    """
    rx, ry, rw, rh = row_rect
    row_img = img[ry:ry+rh, rx:rx+rw]

    # 1) Try panel by contours (edge-based)
    panel_local = _find_right_panel_by_contours(row_img)
    split_x_local = None

    # 2) If not found, try split-line
    if panel_local is None:
        sx = _find_split_line_x(row_img)
        if sx is not None:
            split_x_local = sx

    inset = ROW_INSET_PX
    lx = rx + inset
    ly = ry + inset
    lh = max(1, rh - 2*inset)

    if panel_local is not None:
        px, py, pw, ph = panel_local
        panel_left_abs = rx + px
        lw = max(1, panel_left_abs - LABEL_GAP_PX - lx)
        label_rect = (lx, ly, lw, lh)
        panel_rect = (rx + px, ry + py, pw, ph)
        return label_rect, panel_rect, None

    if split_x_local is not None:
        cut_abs = rx + split_x_local
        lw = max(1, cut_abs - LABEL_GAP_PX - lx)
        label_rect = (lx, ly, lw, lh)
        return label_rect, None, cut_abs

    # 3) Fallback: fixed fraction
    lw = int(rw * FALLBACK_LABEL_WIDTH_FRAC) - inset
    lw = max(1, lw)
    label_rect = (lx, ly, lw, lh)
    return label_rect, None, None

# --- Review dump helpers ------------------------------------------------------

def _init_review_dir(base: Optional[str], category: str, side: str) -> Path:
    if base:
        p = Path(base)
    else:
        ts = datetime.now().strftime("%Y%m%d-%H%M%S")
        p = Path(f"screenshots/label_review/{category}_{side}_{ts}")
    p.mkdir(parents=True, exist_ok=True)
    return p

def _manifest_write(fp, rec: Dict[str, object]) -> None:
    fp.write(json.dumps(rec, ensure_ascii=False) + "\n")
    fp.flush()

def _save_img(path: Path, img: np.ndarray) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    cv2.imwrite(str(path), img)

def _ahash64(img: np.ndarray) -> int:
    """Average-hash (8x8 -> 64-bit) robust to small crop/lighting changes."""
    g = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) if img.ndim == 3 else img
    small = cv2.resize(g, (8, 8), interpolation=cv2.INTER_AREA)
    mean = float(small.mean())
    bits = (small > mean).astype(np.uint8).flatten()
    val = 0
    for b in bits:
        val = (val << 1) | int(b)
    return val

def _hamming(a: int, b: int) -> int:
    return (a ^ b).bit_count()

def _write_clickmap_entry(category: str, side: str, slug: str, template_rel: str) -> None:
    dot_path = f"upgrades.{category}.{side}.{slug}"
    entry = {
        "match_template": template_rel,
        "region_ref": f"upgrades_{side}",
        "match_threshold": DEFAULT_THRESHOLD,
        "roles": DEFAULT_ROLES
    }
    set_dot_path(dot_path, entry, allow_overwrite=True)

# --- Per-page processing ------------------------------------------------------

def process_visible_page(img: np.ndarray, column: str, category: str,
                         seen_slugs: set, write: bool,
                         page_idx: int, review_dir: Path,
                         save_overlay_img: Optional[np.ndarray],
                         order_list: Optional[List[str]] = None,
                         seq_idx: int = 0,
                         seen_rows_y: Optional[List[int]] = None,
                         seen_hashes: Optional[List[int]] = None) -> Tuple[int, int]:
    """Process current visible rows; returns number of new labels written."""
    # Original column ROI (used for visibility test)
    x0,y0,w0,h0 = _read_shared_region(LEFT_SHARED_KEY if column=="left" else RIGHT_SHARED_KEY)

    # Detection ROI expanded vertically to avoid truncation at edges
    Hs, Ws = img.shape[:2]
    x = x0
    y = max(0, y0 - DETECT_PAD_PX)
    w = w0
    h = min(h0 + 2*DETECT_PAD_PX, Hs - y)

    col_roi_ext = _crop(img, (x,y,w,h))
    rows_local = _detect_row_rects(col_roi_ext)
    # convert local rects (within EXTENDED ROI) to full-screen rects
    rows_full = [(x+rx, y+ry, rw, rh) for (rx,ry,rw,rh) in rows_local]

    # keep only rows fully inside the ORIGINAL ROI with a tiny margin
    def _fully_visible(r):
        rx, ry, rw, rh = r
        return (ry >= y0 + VISIBLE_MARGIN_PX) and (ry + rh <= y0 + h0 - VISIBLE_MARGIN_PX)

    rows_full = [r for r in rows_full if _fully_visible(r)]

    # median-height guard to drop clipped rows
    if rows_full:
        med_h = float(np.median([rh for (_,_,_,rh) in rows_full]))
        rows_full = [r for r in rows_full if r[3] >= MIN_HEIGHT_FRAC_OF_MEDIAN * med_h]

    new_count = 0
    if seen_rows_y is None:
        seen_rows_y = []
    if seen_hashes is None:
        seen_hashes = []
    manifest_path = review_dir / "manifest.jsonl"
    with open(manifest_path, "a", encoding="utf-8") as mf:
        for r_idx, row_full in enumerate(rows_full):
            # De-dup rows by Y across pages: skip if a row at similar Y was seen
            ry_global = row_full[1]
            if any(abs(ry_global - y0) <= Y_SEEN_DELTA for y0 in seen_rows_y):
                continue
            label_rect, panel_rect, split_x_abs = _compute_label_and_panel(row_full, img)

            row_img   = _crop(img, row_full)
            label_img = _crop(img, label_rect)
            panel_img = _crop(img, panel_rect) if panel_rect else None

            if order_list and seq_idx < len(order_list):
                slug = order_list[seq_idx]
                raw = "<order>"
            else:
                pre = preprocess_binary(label_img)
                raw = (ocr_text(pre) or "").strip()
                slug = _slugify(raw)
                # Trim common OCR noise suffixes like trailing _e/_ee/_eee, _el
                slug = re.sub(r"_(e|l){1,8}$", "", slug)
                # Heuristics: try keyword mapping first, then template similarity
                if slug == "unknown" or len(re.sub(r"[^a-z]", "", slug)) < 3 or re.fullmatch(r"e+", slug) or slug.endswith("_eeeeeeee"):
                    kw = _canonical_slug_from_keywords(raw, category)
                    if kw:
                        slug = kw
                    else:
                        inferred = _infer_slug_by_similarity(label_img, category)
                        if inferred:
                            slug = inferred
            pretty_slug = slug if re.search(r"[a-z0-9]", slug) else "unknown"

            y_hint = row_full[1]
            base_name = f"p{page_idx:02d}_r{r_idx:02d}_{pretty_slug}_y{y_hint}"

            # --- review artifacts ---
            _save_img(review_dir / "labels" / f"{base_name}.png", label_img)
            _save_img(review_dir / "rows" / f"{base_name}.png", row_img)
            if panel_img is not None:
                _save_img(review_dir / "panels" / f"{base_name}.png", panel_img)

            # overlay
            if save_overlay_img is not None:
                rx, ry, rw, rh = row_full
                cv2.rectangle(save_overlay_img, (rx, ry), (rx+rw, ry+rh), (0,255,0), 2)      # row
                if panel_rect is not None:
                    px, py, pw, ph = panel_rect
                    cv2.rectangle(save_overlay_img, (px, py), (px+pw, py+ph), (0,0,255), 2)  # panel
                if split_x_abs is not None:
                    cv2.line(save_overlay_img, (split_x_abs, ry+4), (split_x_abs, ry+rh-4), (255,255,0), 2)
                lx, ly, lw_, lh_ = label_rect
                cv2.rectangle(save_overlay_img, (lx, ly), (lx+lw_, ly+lh_), (255,0,0), 2)    # label

            template_rel = f"upgrades/{category}/{column}/{slug or 'unknown'}.png"

            rec = {
                "category": category,
                "side": column,
                "page": page_idx,
                "row_index": r_idx,
                "raw_text": raw,
                "slug": slug,
                "row_rect":   {"x": row_full[0],  "y": row_full[1],  "w": row_full[2],  "h": row_full[3]},
                "panel_rect": {"x": panel_rect[0], "y": panel_rect[1], "w": panel_rect[2], "h": panel_rect[3]} if panel_rect else None,
                "split_x_abs": split_x_abs,
                "label_rect": {"x": label_rect[0], "y": label_rect[1], "w": label_rect[2], "h": label_rect[3]},
                "template_rel": template_rel,
                "status": "dry-run" if not write else "committed"
            }
            _manifest_write(mf, rec)

            # If still not confident about naming, do not commit a bad filename.
            if (not order_list) and (not slug or slug == "unknown" or len(re.sub(r"[^a-z]", "", slug)) < 3):
                log(f"[SKIP] Unreliable slug -> {template_rel}. Leaving as review-only.", "WARN"); new_count += 1
                continue
            if slug in seen_slugs and write:
                log(f"Duplicate slug in run, skipping write: {slug}", "WARN")
                if order_list and seq_idx < len(order_list):
                    seq_idx += 1
                continue

            # Content-level dedup across pages to avoid overlap repeats
            sig = _ahash64(label_img)
            # Duplicate if sufficiently similar to any previous (Hamming <= 6)
            if any(_hamming(sig, prev) <= 6 for prev in seen_hashes):
                continue

            if write:
                template_abs = Path("assets/match_templates") / template_rel
                _save_img(template_abs, label_img)
                _write_clickmap_entry(category, column, slug, template_rel)
                new_count += 1
                log(f"Wrote template+entry: {template_rel}", "INFO")
            else:
                log(f"[DRY-RUN] Would write {template_rel}", "INFO")

            seen_slugs.add(slug)
            seen_rows_y.append(ry_global)
            seen_hashes.append(sig)
            if order_list and seq_idx < len(order_list):
                seq_idx += 1
            # In order mode, capture one per iteration to maintain alignment
            if order_list:
                break

    return new_count, seq_idx

# --- Main ---------------------------------------------------------------------

def main():
    ap = argparse.ArgumentParser(description="Auto-generate upgrade label templates and clickmap entries.")
    ap.add_argument("--category", choices=["attack","defense","utility"], default="attack")
    ap.add_argument("--side", choices=["left","right"], required=True)
    ap.add_argument("--commit", action="store_true", help="Write templates and clickmap (default dry-run).")
    ap.add_argument("--pages", type=int, default=40, help="Max pages to scan.")
    ap.add_argument("--step", choices=["micro","page"], default="micro", help="Swipe strength between scans (default: micro)")
    ap.add_argument("--order", default=None,
                    help="Comma-separated list of canonical slugs to assign in order (skips OCR). Example: 'bounce_shot_range,bounce_shot_chance,...'")
    ap.add_argument("--order-file", default=None,
                    help="Path to JSON file with {\"attack\":{\"left\":[..],\"right\":[..]}, ...}. When provided, overrides --order.")
    ap.add_argument("--from-top", action="store_true", help="Scroll to top before scanning.")
    ap.add_argument("--debug", action="store_true", help="Also save page overlay images with rectangles.")
    ap.add_argument("--review-dir", default=None, help="Directory to dump review images & manifest.")
    args = ap.parse_args()

    side = args.side
    category = args.category
    write = args.commit
    # Determine optional order-based naming list
    order_list = None
    if args.order_file:
        try:
            import json as _json
            with open(args.order_file, "r", encoding="utf-8") as f:
                mapping = _json.load(f)
            order_list = (mapping.get(category, {}) or {}).get(side)
        except Exception as e:
            log(f"[WARN] Failed to read --order-file: {e}", "WARN")
            order_list = None
    elif args.order:
        order_list = [s.strip() for s in args.order.split(',') if s.strip()]

    review_dir = _init_review_dir(args.review_dir, category, side)
    log(f"Review dump → {review_dir}", "INFO")

    if args.from_top:
        ok = scroll_to_edge(side, to_top=True, max_swipes=16)
        log(f"scroll_to_top({side}) -> {ok}", "INFO")

    seen: set = set()
    total_new = 0
    seq_idx = 0  # next index into order_list when provided
    seen_rows_y: List[int] = []  # track processed row Y positions across pages
    seen_hashes: set = set()     # track label content across pages

    for page_idx in range(args.pages):
        img = capture_adb_screenshot()
        if img is None:
            log("Failed to capture screenshot; retrying after swipe.", "WARN")
            page_column(side, "down", strength="micro" if page_idx == 0 else "page")
            time.sleep(POST_SWIPE_SLEEP)
            continue

        overlay = img.copy() if args.debug else None
        wrote, seq_idx = process_visible_page(img, side, category, seen, write, page_idx, review_dir, overlay, order_list, seq_idx, seen_rows_y, seen_hashes)
        total_new += wrote

        if order_list and seq_idx >= len(order_list):
            log("Completed order list; stopping early.", "INFO")
            break

        if args.debug:
            out = review_dir / f"page_overlay_p{page_idx:02d}.png"
            _save_img(out, overlay)
            log(f"Saved page overlay: {out}", "INFO")

        # After processing, keep swiping until a truly new row appears (order mode)
        rect = _read_shared_region(LEFT_SHARED_KEY if side=="left" else RIGHT_SHARED_KEY)
        before_img = _crop(img, rect)
        before_tops = _visible_row_tops(img, side)
        attempts = 0
        max_attempts = 6 if order_list else 1
        while attempts < max_attempts:
            page_column(side, "down", strength=args.step)
            time.sleep(POST_SWIPE_SLEEP)
            probe = capture_adb_screenshot()
            if probe is None:
                attempts += 1
                continue
            after_img = _crop(probe, rect)
            # If content changed and at least one new row Y appeared, break
            changed = _roi_change_ratio(before_img, after_img) >= EDGE_EPSILON
            tops = _visible_row_tops(probe, side)
            has_new = any(all(abs(t - y0) > Y_SEEN_DELTA for y0 in seen_rows_y) for t in tops)
            if changed and (not order_list or has_new):
                img = probe
                break
            attempts += 1
        else:
            # Fallback: one page-sized swipe if micro didn’t move content
            if args.step == "micro":
                page_column(side, "down", strength="page")
                time.sleep(POST_SWIPE_SLEEP)
        after_frame = capture_adb_screenshot()
        if after_frame is None:
            continue
        after_crop = _crop(after_frame, rect)
        if _roi_change_ratio(before_img, after_crop) < EDGE_EPSILON:
            log("Reached bottom of list.", "INFO")
            break

    if write:
        save_clickmap(get_clickmap())
        log(f"Done. New labels written: {total_new}", "INFO")
    else:
        log(f"Dry run complete. Would write {total_new} templates. Re-run with --commit.", "INFO")

if __name__ == "__main__":
    main()
----------./tools/run_blind_gem_tapper.py----------------------
./tools/run_blind_gem_tapper.py
#!/usr/bin/env python3
# tools/run_blind_gem_tapper.py
"""
CLI tool to manually start the blind floating gem tapper for testing.

Example:
  python tools/run_blind_gem_tapper.py --duration 15 --interval 0.5
"""

import argparse
from utils.logger import log
from handlers.ad_gem_handler import start_blind_gem_tapper, stop_blind_gem_tapper


def main():
    parser = argparse.ArgumentParser(description="Manually start the blind floating gem tapper for testing.")
    parser.add_argument("--duration", type=float, default=20.0, help="Seconds to run (default: 20)")
    parser.add_argument("--interval", type=float, default=1.0, help="Seconds between taps (default: 1.0)")
    args = parser.parse_args()

    log(f"[ACTION] Starting blind gem tapper for {args.duration}s @ {args.interval}s (blocking)", "ACTION")
    try:
        start_blind_gem_tapper(duration=args.duration, interval=args.interval, blocking=True)
    except KeyboardInterrupt:
        log("KeyboardInterrupt — stopping tapper.", "INFO")
    finally:
        stop_blind_gem_tapper()
        log("Tester exited cleanly.", "INFO")


if __name__ == "__main__":
    main()
----------./tools/scrcpy_adb_input_bridge.py----------------------
./tools/scrcpy_adb_input_bridge.py
#!/usr/bin/env python3

import argparse
import json
import signal
import atexit
import subprocess
import time
import re
from pynput import mouse
import cv2
import numpy as np

from core.adb_utils import adb_shell
from core.ss_capture import capture_adb_screenshot

# Global State Variables
SCRCPY_WIN_ID = None
SCRCPY_WIN_RECT = None

# Global for cleanup
SCRCPY_PROC = None

# -------------------- Window lookup helpers --------------------

def _lookup_scrcpy_window_id():
    """
    Find a visible window titled exactly 'scrcpy-bridge'.
    Returns the last (most recent) id when multiple are found.
    """
    try:
        out = subprocess.check_output(
            ["xdotool", "search", "--onlyvisible", "--name", "^scrcpy-bridge$"]
        ).decode().strip()
        ids = [line for line in out.splitlines() if line]
        return ids[-1] if ids else None
    except subprocess.CalledProcessError:
        return None


def _xwininfo_rect(win_id):
    """
    Query geometry for a window id via xwininfo.
    Returns (x, y, width, height).
    """
    geo = subprocess.check_output(["xwininfo", "-id", win_id]).decode()
    width = int(re.search(r"Width:\s+(\d+)", geo).group(1))
    height = int(re.search(r"Height:\s+(\d+)", geo).group(1))
    x = int(re.search(r"Absolute upper-left X:\s+(\d+)", geo).group(1))
    y = int(re.search(r"Absolute upper-left Y:\s+(\d+)", geo).group(1))
    return (x, y, width, height)


def _largest_child_rect(win_id):
    """
    Parse xwininfo -tree for child windows and return the largest child's rect.
    Returns (x, y, w, h) or None if no child rect obtained.
    """
    tree = subprocess.check_output(['xwininfo', '-tree', '-id', win_id]).decode()
    # Extract potential child window ids (hex ids appear at line starts or after spaces)
    child_ids = []
    for line in tree.splitlines():
        m = re.search(r"\b(0x[0-9a-fA-F]+)\b", line)
        if m:
            cid = m.group(1)
            if cid.lower() != win_id.lower():
                child_ids.append(cid)
    best = None
    best_area = -1
    for cid in child_ids:
        try:
            rect = _xwininfo_rect(cid)
        except subprocess.CalledProcessError:
            continue
        _, _, w, h = rect
        if w > 0 and h > 0:
            area = w * h
            if area > best_area:
                best, best_area = rect, area
    return best


# -------------------- Public APIs --------------------

def ensure_scrcpy_window_rect(rect_source='top', diagnose=False, android_size=None):
    """
    Ensure and cache the current scrcpy window rect based on selection policy.

    rect_source: 'top' (default), 'child', or 'auto'
    diagnose: print comparison details without altering defaults
    android_size: (aw, ah) for AR checks when using 'auto' or diagnostics
    """
    global SCRCPY_WIN_ID, SCRCPY_WIN_RECT

    def _ensure_id():
        # Use module-level binding; this is not an enclosing-function local.
        global SCRCPY_WIN_ID
        if SCRCPY_WIN_ID is None:
            SCRCPY_WIN_ID = _lookup_scrcpy_window_id()
            if SCRCPY_WIN_ID is None:
                raise RuntimeError("Could not find scrcpy window")
        return SCRCPY_WIN_ID

    def _stabilized_top_rect(win_id, max_wait=5, interval=0.25, min_w=500, min_h=500):
        attempts = int(max_wait / interval)
        last = None
        for _ in range(attempts):
            try:
                rect = _xwininfo_rect(win_id)
            except subprocess.CalledProcessError:
                # refresh id and retry once
                win_id = _lookup_scrcpy_window_id()
                if not win_id:
                    break
                rect = _xwininfo_rect(win_id)
            x, y, w, h = rect
            last = rect
            if w >= min_w and h >= min_h:
                return rect
            time.sleep(interval)
        if last is None:
            raise RuntimeError("scrcpy window not available")
        return last

    win_id = _ensure_id()

    # Candidates
    top_rect = _stabilized_top_rect(win_id)
    child_rect = None
    try:
        child_rect = _largest_child_rect(win_id)
    except subprocess.CalledProcessError:
        child_rect = None

    # Optional diagnostics
    if diagnose:
        print(f"[DIAG] top rect:   {top_rect}")
        if child_rect:
            print(f"[DIAG] child rect: {child_rect}")
        else:
            print(f"[DIAG] child rect: <none>")
        if android_size:
            aw, ah = android_size
            aar = aw / ah
            def _ar(r): return (r[2] / r[3]) if r and r[3] != 0 else 0.0
            top_ar = _ar(top_rect)
            child_ar = _ar(child_rect) if child_rect else 0.0
            print(f"[DIAG] AR android={aar:.4f} top={top_ar:.4f} child={child_ar:.4f}")
        # Diagnostics do not change selection

    # Selection
    chosen = top_rect  # default preserves existing behavior
    if rect_source == 'child':
        if child_rect:
            chosen = child_rect
        # else fallback to top
    elif rect_source == 'auto':
        # Prefer rect that best matches android AR and exceeds a minimum size
        if android_size:
            aw, ah = android_size
            aar = aw / ah
            def _ok(r):
                if not r: return False
                _, _, w, h = r
                if w < 500 or h < 500: return False
                r_ar = w / h if h else 0.0
                return abs(r_ar - aar) <= 0.08  # ±8%
            def _ardelta(r):
                if not r: return float('inf')
                _, _, w, h = r
                if h == 0: return float('inf')
                return abs((w / h) - aar)
            if _ok(child_rect) and not _ok(top_rect):
                chosen = child_rect
            elif _ok(child_rect) and _ok(top_rect):
                chosen = child_rect if _ardelta(child_rect) < _ardelta(top_rect) else top_rect
            else:
                chosen = top_rect  # fallback
        else:
            # Without android_size, fall back to top unless child exists and is clearly larger
            if child_rect:
                _, _, tw, th = top_rect
                _, _, cw, ch = child_rect
                chosen = child_rect if (cw * ch) > (tw * th) else top_rect

    if SCRCPY_WIN_RECT != chosen:
        print(f"[INFO] Detected scrcpy window change: {SCRCPY_WIN_RECT} -> {chosen}")
        SCRCPY_WIN_RECT = chosen

    return SCRCPY_WIN_RECT


def get_android_screen_size():
    """
    Returns (width, height) of the current Android framebuffer.
    Uses centralized capture to avoid duplication and device drift.
    """
    img = capture_adb_screenshot()
    if img is None:
        raise RuntimeError("Failed to capture Android screen")
    h, w = img.shape[:2]
    return (w, h)


def get_scrcpy_window_rect(rect_source='top', diagnose=False, android_size=None):
    """
    Returns (x, y, w, h) of the drawable area based on selection policy.
    Default behavior matches prior implementation ('top').
    """
    win_rect = ensure_scrcpy_window_rect(rect_source=rect_source, diagnose=diagnose, android_size=android_size)
    return win_rect


def map_to_android(x, y, window_rect, android_size):
    win_x, win_y, win_w, win_h = window_rect
    android_w, android_h = android_size

    android_aspect = android_w / android_h
    window_aspect = win_w / win_h

    if window_aspect > android_aspect:
        scale = win_h / android_h
        effective_w = android_w * scale
        margin_x = (win_w - effective_w) / 2
        rel_x = (x - win_x - margin_x) / effective_w
        rel_y = (y - win_y) / win_h
    else:
        scale = win_w / android_w
        effective_h = android_h * scale
        margin_y = (win_h - effective_h) / 2
        rel_x = (x - win_x) / win_w
        rel_y = (y - win_y - margin_y) / effective_h

    rel_x_clamped = max(0, min(1, rel_x))
    rel_y_clamped = max(0, min(1, rel_y))

    mapped_x = int(rel_x_clamped * android_w)
    mapped_y = int(rel_y_clamped * android_h)
    return mapped_x, mapped_y


def send_tap(x, y):
    print(f"[ADB] tap {x}, {y}")
    adb_shell(["input", "tap", str(x), str(y)])


def send_swipe(x1, y1, x2, y2, duration_ms):
    print(f"[ADB] swipe {x1},{y1} -> {x2},{y2} ({duration_ms}ms)")
    adb_shell(["input", "swipe", str(x1), str(y1), str(x2), str(y2), str(duration_ms)])


def get_pixel_color_at_android_coords(x, y):
    try:
        img = capture_adb_screenshot()
        if img is None:
            raise RuntimeError("ADB screenshot decode failed")
        b, g, r = img[y, x]
        return (r, g, b)
    except Exception as e:
        print(f"[ERROR] Failed to get pixel color at ({x}, {y}): {e}")
        return None


def start_mouse_listener(android_size, args):
    press_pos = None
    press_time = None

    def on_click(x, y, button, pressed):
        nonlocal press_pos, press_time

        try:
            window_rect = ensure_scrcpy_window_rect(
                rect_source=args.rect_source,
                diagnose=args.rect_diagnose,
                android_size=android_size
            )
        except RuntimeError as e:
            print(f"[ERROR] Could not resolve scrcpy window: {e}")
            return

        win_x, win_y, win_w, win_h = window_rect
        inside = (win_x <= x <= win_x + win_w and win_y <= y <= win_y + win_h)

        if not inside:
            if pressed:
                pass
            return

        if pressed:
            press_pos = (x, y)
            press_time = time.time()
            return  # don't proceed further on press

        if press_time is None:
            print("[WARN] Mouse release detected but press_time is None — ignoring.")
            return

        release_time = time.time()
        duration = int((release_time - press_time) * 1000)

        if button == mouse.Button.left:
            start_x, start_y = map_to_android(*press_pos, window_rect, android_size)
            end_x, end_y = map_to_android(x, y, window_rect, android_size)

            if (start_x, start_y) == (end_x, end_y):
                send_tap(start_x, start_y)
                gesture_data = {
                    "type": "tap",
                    "x": start_x,
                    "y": start_y
                }
            else:
                send_swipe(start_x, start_y, end_x, end_y, duration)
                gesture_data = {
                    "type": "swipe",
                    "x1": start_x,
                    "y1": start_y,
                    "x2": end_x,
                    "y2": end_y,
                    "duration_ms": duration
                }

            if args.json_stream:
                print("__GESTURE_JSON__" + json.dumps(gesture_data), flush=True)

        elif button == mouse.Button.right:
            adb_shell(["input", "keyevent", "4"])  # BACK

        elif button == mouse.Button.middle:
            adb_shell(["input", "keyevent", "3"])  # HOME

    listener = mouse.Listener(on_click=on_click)
    listener.start()


def launch_scrcpy():
    global SCRCPY_PROC
    SCRCPY_PROC = subprocess.Popen(["scrcpy", "--no-control", "--window-title", "scrcpy-bridge"])
    time.sleep(2)


def cleanup_and_exit(signum=None, frame=None):
    global SCRCPY_PROC
    if SCRCPY_PROC and SCRCPY_PROC.poll() is None:
        print("[INFO] Cleaning up scrcpy subprocess...")
        SCRCPY_PROC.terminate()
        try:
            SCRCPY_PROC.wait(timeout=3)
        except subprocess.TimeoutExpired:
            print("[WARN] scrcpy did not terminate in time — killing")
            SCRCPY_PROC.kill()
    exit(0)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--json-stream", action="store_true",
                        help="Emit gestures as JSON to stdout and keep running")
    parser.add_argument("--rect-source", choices=["top", "child", "auto"], default="top",
                        help="Window rect selection policy (default: top)")
    parser.add_argument("--rect-diagnose", action="store_true",
                        help="Print diagnostic info about rect candidates and AR deltas")
    args = parser.parse_args()

    launch_scrcpy()
    atexit.register(cleanup_and_exit)
    signal.signal(signal.SIGINT, cleanup_and_exit)
    signal.signal(signal.SIGTERM, cleanup_and_exit)

    android_size = get_android_screen_size()
    window_rect = get_scrcpy_window_rect(rect_source=args.rect_source,
                                         diagnose=args.rect_diagnose,
                                         android_size=android_size)
    print(f"[INFO] Android screen size: {android_size}")
    print(f"[INFO] scrcpy drawable window: {window_rect}")
    start_mouse_listener(android_size, args)
    print("Listening for clicks... Ctrl+C to quit.")
    while True:
        time.sleep(1)


if __name__ == "__main__":
    main()
----------./tools/combine_specs.py----------------------
./tools/combine_specs.py
#!/usr/bin/env python3
# Combine all *.py.md files under a root into one file.
# Each section is written verbatim, separated by a single line '---------------'.
# Optional: include SPEC_LEGEND.md first if present.

import argparse
from pathlib import Path

DELIM = "---------------"

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--root", required=True, help="Directory containing *.py.md files")
    ap.add_argument("--out", required=True, help="Output combined file")
    ap.add_argument("--include-legend", action="store_true", help="If SPEC_LEGEND.md exists, include it as the first section")
    args = ap.parse_args()

    root = Path(args.root)
    out = Path(args.out)

    parts = []

    # Legend first (verbatim)
    legend = root / "SPEC_LEGEND.md"
    if args.include_legend and legend.exists():
        parts.append(legend.read_text(encoding="utf-8").rstrip() + "\n")
        parts.append(DELIM + "\n")

    # Deterministic order
    files = sorted(root.rglob("*.py.md"))

    for md in files:
        if md.name == "SPEC_LEGEND.md":
            continue
        body = md.read_text(encoding="utf-8").rstrip() + "\n"
        parts.append(body)
        parts.append(DELIM + "\n")

    # Remove trailing delimiter
    if parts and parts[-1].strip() == DELIM:
        parts.pop()

    out.parent.mkdir(parents=True, exist_ok=True)
    out.write_text("".join(parts), encoding="utf-8")
    print(f"Wrote combined file: {out} ({len(files)} module sections{' + legend' if args.include_legend and legend.exists() else ''})")

if __name__ == "__main__":
    main()
----------./automation/run_nuke.py----------------------
./automation/run_nuke.py
#!/usr/bin/env python3
# automation/run_demon_nuke.py

import sys
import os
import time

# Add project root to sys.path
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.abspath(os.path.join(SCRIPT_DIR, ".."))
sys.path.insert(0, PROJECT_ROOT)

from handlers.mission_nuke import run_nuke_strategy
from utils.logger import log


def main():
    """Entrypoint: persistent Demon-Nuke mission loop until interrupted."""
    log("[MISSION] Starting persistent Demon-Nuke loop. Ctrl+C to stop.", "INFO")
    while True:
        try:
            run_nuke_strategy()
            time.sleep(2)
        except KeyboardInterrupt:
            log("[MISSION] Stopping loop due to user interrupt.", "INFO")
            break
        except Exception as e:
            log(f"[MISSION] Unhandled error during mission: {e}", "FAIL")
            time.sleep(2)


if __name__ == "__main__":
    main()
----------./automation/run_demon_mode.py----------------------
./automation/run_demon_mode.py
#!/usr/bin/env python3
# automation/run_demon_mode.py

import sys
import os
import time
import argparse
from utils.logger import log

# Add project root to sys.path
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.abspath(os.path.join(SCRIPT_DIR, ".."))
sys.path.insert(0, PROJECT_ROOT)

from handlers.mission_demon_mode import run_demon_mode


def main(delay: int = 2, once: bool = False):
    """
    Run the Demon-Mode mission loop.
    - delay: seconds to sleep between iterations
    - once: if True, run a single iteration and exit
    """
    log("[MISSION] Starting Demon-Mode loop. Ctrl+C to stop.", "INFO")
    while True:
        try:
            run_demon_mode()
            if once:
                log("[MISSION] Completed single iteration (--once). Exiting.", "INFO")
                break
            time.sleep(delay)
        except KeyboardInterrupt:
            log("[MISSION] Stopping loop due to user interrupt.", "INFO")
            break
        except Exception as e:
            log(f"[MISSION] Unhandled error during mission: {e}", "FAIL")
            time.sleep(delay)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Run Demon-Mode mission loop.")
    parser.add_argument("--delay", type=int, default=2, help="Seconds to sleep between iterations (default: 2)")
    parser.add_argument("--once", action="store_true", help="Run a single iteration then exit")
    args = parser.parse_args()

    main(delay=args.delay, once=args.once)


----------./automation/run_demon_nuke.py----------------------
./automation/run_demon_nuke.py
#!/usr/bin/env python3
# automation/run_demon_nuke.py

import sys
import os
import time

# Add project root to sys.path
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.abspath(os.path.join(SCRIPT_DIR, ".."))
sys.path.insert(0, PROJECT_ROOT)

from handlers.mission_demon_nuke import run_demon_nuke_strategy
from utils.logger import log


def main():
    """Entrypoint: persistent Demon-Nuke mission loop until interrupted."""
    log("[MISSION] Starting persistent Demon-Nuke loop. Ctrl+C to stop.", "INFO")
    while True:
        try:
            run_demon_nuke_strategy()
            time.sleep(2)
        except KeyboardInterrupt:
            log("[MISSION] Stopping loop due to user interrupt.", "INFO")
            break
        except Exception as e:
            log(f"[MISSION] Unhandled error during mission: {e}", "FAIL")
            time.sleep(2)


if __name__ == "__main__":
    main()
----------./state_change_logger.py----------------------
./state_change_logger.py
----------./test/test_upgrade_detection.py----------------------
./test/test_upgrade_detection.py
# test/test_upgrade_detection.py
#!/usr/bin/env python3

import cv2
import numpy as np
import os
import sys

sys.path.append(".")  # so core/, utils/ etc. work if run from root

from utils.template_matcher import match_region
from core.clickmap_access import resolve_dot_path
from core.ss_capture import capture_and_save_screenshot


# ---- Behavior-critical constants (were magic numbers) ----
OFFSET_X = 220        # horizontal offset from match point to sample the color box
OFFSET_Y = 40         # vertical offset from match point to sample the color box
SAMPLE_HALF = 10      # half-size of the sampled square region (total = 2*SAMPLE_HALF)
MAXED_RANGE = (45, 50)         # inclusive BGR average range considered "maxed"
UPGRADEABLE_RANGE = (57, 60)   # inclusive BGR average range considered "upgradeable"


def classify_color(bgr):
    """
    Classify upgrade affordance by average BGR brightness.

    Args:
        bgr (array-like): A (B, G, R) triple or ndarray representing average color.

    Returns:
        str: One of {"maxed", "upgradeable", "unaffordable"} based on avg thresholds.
    """
    b, g, r = bgr
    avg = (b + g + r) / 3
    print(f"[CLASSIFY] avg={avg:.1f} from BGR={bgr}")

    if MAXED_RANGE[0] <= avg <= MAXED_RANGE[1]:
        return "maxed"
    elif UPGRADEABLE_RANGE[0] <= avg <= UPGRADEABLE_RANGE[1]:
        return "upgradeable"
    else:
        return "unaffordable"


def detect_upgrades(screen, keys):
    """
    Detect upgrade buttons and classify their affordability by sampling a nearby color box.

    For each key (dot_path) in `keys`:
      - Resolve clickmap entry.
      - Template match to find the UI element.
      - Sample a small color region at (match_point + OFFSET_X/Y).
      - Classify via `classify_color`.
      - Draw a small green rectangle over the sampled area (in-place on `screen`).

    Args:
        screen (np.ndarray): BGR screenshot image.
        keys (list[str]): Dot-path keys to check.

    Returns:
        dict: key -> status dict. Example on visible:
              {
                "status": "upgradeable" | "maxed" | "unaffordable",
                "confidence": float,
                "tap_point": (x, y),
                "avg_color": [B, G, R]
              }
              If not visible / errors:
              {
                "status": "not visible" | "clickmap entry missing" | "sample_oob",
                "confidence": float? (if matched),
              }
    """
    results = {}
    h, w = screen.shape[:2]

    for key in keys:
        entry = resolve_dot_path(key)
        if not entry:
            results[key] = {"status": "clickmap entry missing"}
            continue

        match_point, confidence = match_region(screen, entry)
        if match_point:
            x, y = match_point

            color_x = x + OFFSET_X
            color_y = y + OFFSET_Y

            # Bounds-check the sampled region to avoid IndexError
            x0 = color_x - SAMPLE_HALF
            x1 = color_x + SAMPLE_HALF
            y0 = color_y - SAMPLE_HALF
            y1 = color_y + SAMPLE_HALF

            if x0 < 0 or y0 < 0 or x1 > w or y1 > h:
                # Do not crash; report out-of-bounds to caller
                results[key] = {
                    "status": "sample_oob",
                    "confidence": round(confidence, 3),
                    "tap_point": (x, y)
                }
                continue

            color_region = screen[y0:y1, x0:x1]
            avg = color_region.mean(axis=(0, 1))

            # Visual marker for debugging
            cv2.rectangle(
                screen,  # image
                (color_x - 5, color_y - 5),
                (color_x + 5, color_y + 5),
                (0, 255, 0),  # green box
                2  # thickness
            )

            avg_color = avg.astype(int).tolist()
            status = classify_color(avg)
            print(f"[DEBUG] {key} → avg={(avg_color[0] + avg_color[1] + avg_color[2]) / 3:.1f}  raw={avg_color} → {status}")

            results[key] = {
                "status": status,
                "confidence": round(confidence, 3),
                "tap_point": (x, y),
                "avg_color": avg_color
            }
        else:
            results[key] = {
                "status": "not visible",
                "confidence": round(confidence, 3)
            }

    return results


def main(argv=None):
    """
    Script entrypoint.

    Behavior:
      - Loads image from CLI arg or defaults to 'screenshots/latest.png'.
      - Runs detect_upgrades on four hardcoded upgrade keys.
      - Prints results and shows an OpenCV window with the debug overlay.

    CLI:
      test_upgrade_detection.py [image_path]
    """
    argv = argv if argv is not None else sys.argv[1:]

    # Default image path
    img_path = argv[0] if len(argv) >= 1 else "screenshots/latest.png"
    screen = cv2.imread(img_path)
    if screen is None:
        print(f"[ERROR] Failed to load image: {img_path}")
        return 1

    keys = [
        "upgrades.attack.left.upgrade_super_crit_mult",
        "upgrades.attack.right.upgrade_super_crit_chance",
        "upgrades.attack.left.upgrade_rend_armor_mult",
        "upgrades.attack.right.upgrade_rend_armor_chance"
    ]

    results = detect_upgrades(screen, keys)
    for key, info in results.items():
        print(f"{key}: {info}")

    cv2.imshow("Debug Overlay", screen)
    cv2.waitKey(0)  # Waits for a keypress
    cv2.destroyAllWindows()
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
----------./test/visualize_regions.py----------------------
./test/visualize_regions.py
#!/usr/bin/env python3
"""
Generic clickmap/region visualizer with optional detector overlays.

Features:
- Load an image (or capture via ADB) and draw:
  * Shared regions from _shared_match_regions (e.g., floating_buttons)
  * Entries by role (e.g., --roles floating_button,indicator)
  * Arbitrary clickmap dot paths (--dot-paths indicators.attack_menu ...)
  * All entries under a clickmap namespace (--namespace floating_buttons)
- Optional floating-button detector overlay (scores + best boxes)
- JSON dump of boxes for downstream tooling

Usage examples:
  # Visualize shared floating_buttons slice and draw floating_button entries
  test/visualize_regions.py --image screenshots/latest.png \
    --shared floating_buttons --roles floating_button --out out/regions.png

  # Capture via ADB, run floating button detector, write heatmaps
  test/visualize_regions.py --adb --shared floating_buttons --roles floating_button \
    --detector floating_buttons --heatmaps --out out/fb_overlay.png

  # Visualize arbitrary dot paths
  test/visualize_regions.py --image screenshots/latest.png \
    --dot-paths "floating_buttons.missile_barrage" "indicators.wall_icon" \
    --out out/selected_boxes.png
"""

import argparse, os, sys, json, pathlib
import cv2
import numpy as np

HERE = os.path.dirname(os.path.abspath(__file__))
REPO = os.path.dirname(HERE)
sys.path.insert(0, REPO)

from utils.logger import log
from core.clickmap_access import get_clickmap, resolve_dot_path, get_entries_by_role
from core.label_tapper import resolve_region
from core.ss_capture import capture_adb_screenshot, capture_and_save_screenshot

# Optional detector imports (kept local to avoid import cycles when unused)
def _import_detector(name: str):
    if name == "floating_buttons":
        from core.floating_button_detector import detect_floating_buttons
        return detect_floating_buttons
    raise ValueError(f"Unknown detector: {name}")

def _heatmap(res):
    r = cv2.normalize(res, None, 0, 255, cv2.NORM_MINMAX).astype("uint8")
    return cv2.applyColorMap(r, cv2.COLORMAP_JET)

def _ensure_dir(path: str):
    d = os.path.dirname(path)
    if d and not os.path.exists(d):
        os.makedirs(d, exist_ok=True)

def _add_box(group, name, region, boxes):
    try:
        x,y,w,h = int(region["x"]), int(region["y"]), int(region["w"]), int(region["h"])
        boxes.setdefault(group, []).append({"name": name, "x": x, "y": y, "w": w, "h": h})
    except Exception as e:
        log(f"Bad region for {group}:{name} -> {region} ({e})", "WARN")

def collect_boxes(clickmap, shared_names, roles, dot_paths, namespace):
    """Return dict[group] -> [ {name,x,y,w,h}, ... ]"""
    boxes = {}

    # Shared regions
    shared = (clickmap.get("_shared_match_regions") or {})
    for s in shared_names or []:
        reg = (shared.get(s) or {}).get("match_region")
        if reg:
            _add_box("shared", s, reg, boxes)
        else:
            log(f"Shared region '{s}' missing in _shared_match_regions", "WARN")

    # Roles
    for role in roles or []:
        entries = get_entries_by_role(role)
        for name, entry in entries.items():
            try:
                r = resolve_region(entry, clickmap)
                _add_box(f"role:{role}", name, r, boxes)
            except Exception as e:
                log(f"resolve_region failed for role:{role} {name}: {e}", "WARN")

    # Dot paths
    for dp in dot_paths or []:
        obj = resolve_dot_path(dp)
        if isinstance(obj, dict):
            # If this is a clickmap entry, resolve its region; else if it's a region, draw it directly
            if "match_region" in obj or "region_ref" in obj:
                try:
                    r = resolve_region(obj, clickmap)
                    _add_box("dot", dp, r, boxes)
                except Exception as e:
                    log(f"resolve_region failed for dot:{dp}: {e}", "WARN")
            elif all(k in obj for k in ("x","y","w","h")):
                _add_box("dot", dp, obj, boxes)
            else:
                log(f"dot-path '{dp}' does not resolve to a region or entry", "WARN")
        else:
            log(f"dot-path '{dp}' not found", "WARN")

    # Namespace: draw everything under a top-level clickmap key (e.g., floating_buttons)
    # Assumes entries under namespace are entry dicts with region info or refs.
    if namespace:
        ns = clickmap.get(namespace, {})
        if not isinstance(ns, dict):
            log(f"Namespace '{namespace}' not found or not a dict", "WARN")
        else:
            for k, entry in ns.items():
                if isinstance(entry, dict) and ('match_region' in entry or 'region_ref' in entry or 'match_template' in entry):
                    try:
                        r = resolve_region(entry, clickmap)
                        _add_box(f"ns:{namespace}", f"{namespace}.{k}", r, boxes)
                    except Exception as e:
                        log(f"resolve_region failed for ns:{namespace}.{k}: {e}", "WARN")

    return boxes

def draw_overlay(img, groups, scale=1.0, thickness=2):
    out = img.copy()
    # deterministic colors per group
    def _color(name):
        h = abs(hash(name)) % (1<<24)
        return (h & 255, (h>>8) & 255, (h>>16) & 255)
    for group_name, boxes in groups:
        color = _color(group_name)
        for b in boxes:
            p1 = (b["x"], b["y"])
            p2 = (b["x"] + b["w"], b["y"] + b["h"])
            cv2.rectangle(out, p1, p2, color, thickness)
            label = f'{group_name}:{b["name"]}'
            cv2.putText(out, label, (b["x"]+2, max(0, b["y"]-6)),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 1, cv2.LINE_AA)
    if scale != 1.0:
        h, w = out.shape[:2]
        out = cv2.resize(out, (int(w*scale), int(h*scale)), interpolation=cv2.INTER_AREA)
    return out

def run_floating_button_scoring(img, clickmap, out_dir, thresh_bump=0.0, draw_best=True, heatmaps=False):
    # Enforce shared slice for scoring to reflect intended behavior
    shared = (clickmap.get("_shared_match_regions") or {}).get("floating_buttons", {})
    reg = shared.get("match_region")
    if not reg:
        log("Shared region for floating_buttons missing", "ERROR"); return []
    xs, ys, ws, hs = [int(reg[k]) for k in ("x","y","w","h")]
    roi = img[ys:ys+hs, xs:xs+ws].copy()

    entries = get_entries_by_role("floating_button")
    results = []
    for name, e in entries.items():
        t_rel = e.get("match_template")
        if not t_rel:
            continue
        t_path = os.path.join(REPO, "assets", "match_templates", t_rel)
        templ = cv2.imread(t_path, cv2.IMREAD_COLOR)
        if templ is None:
            log(f"Missing template: {t_rel}", "ERROR")
            continue
        res = cv2.matchTemplate(roi, templ, cv2.TM_CCOEFF_NORMED)
        _, maxVal, _, maxLoc = cv2.minMaxLoc(res)
        thr = float(e.get("match_threshold", 0.9)) - float(thresh_bump)
        thr = max(0.0, min(1.0, thr))
        th_, tw_ = templ.shape[:2]
        if draw_best:
            tl = (maxLoc[0], maxLoc[1]); br = (tl[0]+tw_, tl[1]+th_)
            cv2.rectangle(roi, tl, br, (0,200,0) if maxVal>=thr else (0,0,255), 2)
            cv2.putText(roi, f"{name.split('.')[-1]}:{maxVal:.2f}",
                        (tl[0]+2, max(0, tl[1]-6)), cv2.FONT_HERSHEY_SIMPLEX, 0.5,
                        (0,200,0) if maxVal>=thr else (0,0,255), 1, cv2.LINE_AA)
        if heatmaps:
            hm = _heatmap(res)
            cv2.imwrite(os.path.join(out_dir, f"fb_{name.split('.')[-1]}_heatmap.png"), hm)
        results.append({"name": name, "max": float(maxVal), "thr": float(thr), "template_wh": [int(tw_), int(th_)]})
    # paste back annotated ROI for context (caller draws the outer box via groups)
    return results, (xs, ys, ws, hs), roi

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--adb", action="store_true", help="Capture via ADB before processing")
    ap.add_argument("--image", default="screenshots/latest.png", help="Input image path if not using --adb")
    ap.add_argument("--save-capture", default="screenshots/latest.png", help="Where to save the ADB capture")
    ap.add_argument("--out", default="out/regions_overlay.png", help="Output overlay image")
    ap.add_argument("--dump", default=None, help="Optional JSON dump of drawn boxes")
    ap.add_argument("--scale", type=float, default=1.0, help="Overlay scale")
    ap.add_argument("--thickness", type=int, default=2, help="Box line thickness")

    # What to draw
    ap.add_argument("--shared", nargs="*", default=[], help="Names from _shared_match_regions (e.g., floating_buttons coins)")
    ap.add_argument("--roles", default="", help="Comma-separated roles (e.g., floating_button,indicator)")
    ap.add_argument("--dot-paths", nargs="*", default=[], help="Arbitrary clickmap dot paths to draw")
    ap.add_argument("--namespace", default="", help="Draw all entries under a clickmap namespace (e.g., floating_buttons)")

    # Optional detector overlay and scoring
    ap.add_argument("--detector", default="", help="Detector name to run (e.g., floating_buttons)")
    ap.add_argument("--heatmaps", action="store_true", help="Also emit heatmaps for detector scoring")
    ap.add_argument("--thresh-bump", type=float, default=0.0, help="Subtract from match_threshold (e.g., 0.05)")

    args = ap.parse_args()
    _ensure_dir(args.out)
    if args.dump: _ensure_dir(args.dump)

    # Load or capture image
    if args.adb:
        img = capture_adb_screenshot()
        if img is None:
            log("ADB capture returned None", "ERROR"); sys.exit(2)
        if args.save_capture:
            _ensure_dir(args.save_capture)
            cv2.imwrite(args.save_capture, img)
            log(f"ADB capture saved: {args.save_capture}", "INFO")
    else:
        img = cv2.imread(args.image, cv2.IMREAD_COLOR)
        if img is None:
            log(f"Could not read image: {args.image}", "ERROR"); sys.exit(2)

    clickmap = get_clickmap()

    # Collect requested boxes
    roles = [r.strip() for r in args.roles.split(",") if r.strip()] if args.roles else []
    boxes_by_group = collect_boxes(clickmap, args.shared, roles, args.dot_paths, args.namespace)

    # If a detector was specified, run it and augment overlay
    detector_results = None
    annotated_roi = None
    if args.detector:
        det = _import_detector(args.detector)
        out_dir = os.path.dirname(args.out) or "."
        # For floating_buttons, score inside shared slice and annotate ROI with best boxes & scores
        if args.detector == "floating_buttons":
            detector_results, shared_rect, roi_annot = run_floating_button_scoring(
                img, clickmap, out_dir, thresh_bump=args.thresh_bump,
                draw_best=True, heatmaps=args.heatmaps
            )
            if shared_rect:
                xs, ys, ws, hs = shared_rect
                # ensure the shared rect is drawn in groups (if not already requested)
                if not any(g for g in boxes_by_group if g == "shared"):
                    boxes_by_group.setdefault("shared", []).append({"name": "floating_buttons", "x": xs, "y": ys, "w": ws, "h": hs})
                # paste annotated ROI for context
                annotated_roi = (shared_rect, roi_annot)
        else:
            # Generic path: run detector and draw match boxes returned by detector
            matches = det(img) or []
            for m in matches:
                mr = m.get("match_region") or {}
                _add_box(f"det:{args.detector}", m.get("name","item"), mr, boxes_by_group)

    # Render
    groups_sorted = sorted(boxes_by_group.items(), key=lambda kv: kv[0])
    overlay = draw_overlay(img, groups_sorted, scale=1.0, thickness=args.thickness)

    # If we have an annotated ROI from detector scoring, composite it back (already colored)
    if annotated_roi:
        (xs, ys, ws, hs), roi_ann = annotated_roi
        overlay[ys:ys+hs, xs:xs+ws] = roi_ann

    # Scale and write
    if args.scale != 1.0:
        h, w = overlay.shape[:2]
        overlay = cv2.resize(overlay, (int(w*args.scale), int(h*args.scale)), interpolation=cv2.INTER_AREA)
    cv2.imwrite(args.out, overlay)
    print(f"[OK] wrote {args.out}")

    # Dump JSON if requested
    if args.dump:
        payload = {
            "image": args.image if not args.adb else args.save_capture,
            "image_shape": img.shape,
            "groups": {name: boxes for name, boxes in groups_sorted},
            "detector": args.detector or None,
            "detector_results": detector_results,
        }
        with open(args.dump, "w", encoding="utf-8") as f:
            json.dump(payload, f, indent=2)
        print(f"[OK] wrote {args.dump}")

if __name__ == "__main__":
    main()
----------./test/clickmap_integrity.py----------------------
./test/clickmap_integrity.py
# test/clickmap_integrity.py

import os
import json
from core.clickmap_access import get_clickmap

clickmap = get_clickmap()
TEMPLATE_DIR = "assets/match_templates"


def validate_entry(name, entry):
    errors = []
    if "match_template" in entry:
        path = os.path.join(TEMPLATE_DIR, entry["match_template"])
        if not os.path.exists(path):
            errors.append(f"Missing template image: {entry['match_template']}")

    if "match_region" in entry:
        region = entry["match_region"]
        for key in ["x", "y", "w", "h"]:
            if key not in region:
                errors.append(f"Missing match_region key '{key}'")
            elif not isinstance(region[key], int):
                errors.append(f"match_region.{key} is not an integer")

    if "tap" in entry:
        for k in ["x", "y"]:
            if k not in entry["tap"]:
                errors.append(f"tap.{k} missing")

    if "swipe" in entry:
        for k in ["x1", "y1", "x2", "y2", "duration_ms"]:
            if k not in entry["swipe"]:
                errors.append(f"swipe.{k} missing")

    return errors


def main():
    total_errors = 0
    for name, entry in clickmap.items():
        errs = validate_entry(name, entry)
        if errs:
            total_errors += len(errs)
            print(f"[FAIL] {name}:")
            for e in errs:
                print(f"    - {e}")

    if total_errors == 0:
        print("[PASS] All clickmap entries look valid.")
    else:
        print(f"[SUMMARY] {total_errors} total issues found.")


if __name__ == "__main__":
    main()
----------./test/test_gesture.py----------------------
./test/test_gesture.py
#!/usr/bin/env python3

import argparse
import sys
from core.clickmap_access import resolve_dot_path, tap_now, swipe_now
from core.label_tapper import tap_label_now
from utils.logger import log


def run_gesture(dot_path):
    """
    Execute a single gesture defined in clickmap.json.

    Resolution order:
      1) If entry has "match_template": use visual tap via tap_label_now(dot_path).
      2) Else if entry has "tap": perform static tap via tap_now(dot_path).
      3) Else if entry has "swipe": perform swipe via swipe_now(dot_path).
      4) Otherwise: log an error.

    Args:
      dot_path (str): Dot-path key to an entry in clickmap.json.

    Returns:
      bool: True if a gesture was executed (and, for visual path, the match/tap returned True);
            False if resolution failed or no actionable gesture was found.

    Errors:
      Exceptions from resolve_dot_path are caught and logged; function returns False.
      Underlying ADB/tap errors may surface via called utilities (logged elsewhere).
    """
    try:
        entry = resolve_dot_path(dot_path)
    except Exception as e:
        log(f"[ERROR] Failed to resolve dot_path '{dot_path}': {e}", "FAIL")
        return False

    if not entry:
        log(f"[ERROR] No entry found for dot_path: '{dot_path}'", "FAIL")
        return False

    # 1. Try visual tap if match_template is defined
    if "match_template" in entry:
        log(f"[INFO] Using visual matcher for: {dot_path}", "DEBUG")
        success = tap_label_now(dot_path)
        if not success:
            log(f"[ERROR] tap_label_now failed for: {dot_path}", "FAIL")
            return False
        return True

    # 2. Try static tap
    if "tap" in entry:
        log(f"[INFO] Executing static tap gesture: {dot_path}", "DEBUG")
        tap_now(dot_path)
        return True

    # 3. Try swipe
    if "swipe" in entry:
        log(f"[INFO] Executing swipe gesture: {dot_path}", "DEBUG")
        swipe_now(dot_path)
        return True

    log(f"[ERROR] No actionable gesture defined in entry: '{dot_path}'", "FAIL")
    return False


def main():
    """
    CLI entrypoint for executing a single clickmap gesture.

    Usage:
      test/test_gesture.py <dot_path>

    Behavior:
      Resolves <dot_path> in clickmap.json and triggers the appropriate gesture.
      Exit code is 0 on success, 1 on failure.
    """
    parser = argparse.ArgumentParser(description="Execute a single gesture by dot-path from clickmap.json")
    parser.add_argument("dot_path", help="Dot path to the gesture in clickmap.json")
    args = parser.parse_args()

    ok = run_gesture(args.dot_path)
    sys.exit(0 if ok else 1)


if __name__ == "__main__":
    main()
----------./test/test_game_over_handler.py----------------------
./test/test_game_over_handler.py
#!/usr/bin/env python3
# test/test_game_over_handler.py

import traceback
from handlers.game_over_handler import handle_game_over
from core.automation_state import AUTOMATION, ExecMode
from utils.logger import log


def run_test():
    """
    Exercise the Game Over handler safely.

    Behavior:
      - Saves current AUTOMATION.mode, switches to WAIT for safety, runs handle_game_over(),
        logs any exception with traceback, then restores the original mode.

    Returns:
      Action result (logs lifecycle; no explicit return).

    Side effects:
      Temporarily mutates global automation mode; invokes handler which may perform ADB I/O,
      template matching, taps/swipes, and filesystem writes.

    Errors:
      Exceptions from the handler are caught and logged; original mode is always restored.
    """
    log("[TEST] Starting Game Over handler test", "INFO")

    original_mode = AUTOMATION.mode
    AUTOMATION.mode = ExecMode.WAIT
    log(f"[TEST] Automation mode set to: {AUTOMATION.mode.value}", "INFO")

    try:
        handle_game_over()
    except Exception as e:
        log(f"[TEST] Exception raised during handler: {e}", "ERROR")
        log(traceback.format_exc(), "ERROR")
    finally:
        AUTOMATION.mode = original_mode
        log(f"[TEST] Automation mode restored to: {AUTOMATION.mode.value}", "INFO")

    log("[TEST] Game Over handler test complete", "INFO")


if __name__ == "__main__":
    run_test()
----------./test/detect_floating_buttons.py----------------------
./test/detect_floating_buttons.py
#!/usr/bin/env python3
# test/detect_floating_buttons.py

"""
CLI test harness:
- Captures a screen via ADB
- Runs floating button detection
- Prints human-readable matches

Intended for quick manual verification. No JSON or tap actions here.
"""

from core.floating_button_detector import detect_floating_buttons
from core.ss_capture import capture_adb_screenshot


def main():
    """
    Capture the current screen and print detected floating buttons.

    Returns: None (prints results only)
    Side effects: Uses ADB to capture the screen; CPU-bound image matching.
    Exit behavior:
      - Prints an error and returns early if the screen capture fails.
      - Prints a summary when no buttons are detected.
      - Prints details for each detected button otherwise.
    """
    print("[INFO] Capturing screen...")
    screen = capture_adb_screenshot()
    if screen is None:
        print("[ERROR] Failed to capture screen.")
        return

    print("[INFO] Detecting floating buttons...")
    matches = detect_floating_buttons(screen)

    if not matches:
        print("[RESULT] No floating buttons detected.")
        return

    for match in matches:
        print(f"[MATCH] {match['name']}:")
        print(f"  confidence = {match['confidence']:.2f}")
        print(f"  match_region = {match['match_region']}")
        print(f"  tap_point = {match['tap_point']}")


if __name__ == "__main__":
    main()
----------./test/detect_state_test.py----------------------
./test/detect_state_test.py
#!/usr/bin/env python3
# test/detect_state_test.py

import argparse
import os
import cv2
from core.state_detector import detect_state_and_overlays
from core.ss_capture import capture_and_save_screenshot

def main():
    """
    CLI test harness for state detection.

    Flags:
      --image PATH       Path to screenshot image (default: screenshots/latest.png).
      --highlight        Save an annotated copy alongside the input (drawing must be implemented in detector).
      --refresh          Capture a fresh screenshot to PATH before detection.

    Returns:
      Action result (prints detected state/overlays; optionally writes annotated image).

    Errors:
      Exits early if image file is missing or cannot be loaded.
    """
    parser = argparse.ArgumentParser(description="Test state detection from screenshot")
    parser.add_argument("--image", default="screenshots/latest.png", help="Path to screenshot image")
    parser.add_argument("--highlight", action="store_true", help="Draw match region on output")
    parser.add_argument("--refresh", action="store_true", help="Capture new screenshot before running")
    args = parser.parse_args()

    # Refresh first so it works even if the image doesn't exist yet.
    if args.refresh:
        print("[INFO] Capturing new screenshot...")
        capture_and_save_screenshot(args.image)

    if not os.path.exists(args.image):
        print(f("[ERROR] Image not found: {args.image}"))
        return

    screen = cv2.imread(args.image)
    if screen is None:
        print("[ERROR] Failed to load image.")
        return

    result = detect_state_and_overlays(screen)
    print(f"[TEST] Detected state: {result['state']}")
    print(f"[TEST] Detected secondary states: {result['secondary_states']}")
    print(f"[TEST] Detected overlays: {result['overlays']}")

    # Optional: save a highlighted version (match drawing must be added inside detect_state for now)
    if args.highlight:
        output_path = os.path.splitext(args.image)[0] + "_annotated.png"
        cv2.imwrite(output_path, screen)
        print(f"[INFO] Saved annotated image to: {output_path}")


if __name__ == "__main__":
    main()
----------./test/validate_state_defs.py----------------------
./test/validate_state_defs.py
#!/usr/bin/env python3
"""
Validate state_definitions.yaml against clickmap.json.

- Supports both dict schema and list-of-objects schema {name, match_keys, ...}
- Uses clickmap_access.{dot_path_exists, resolve_dot_path} (no flattening)
- Fails if required states are missing, or any state has 0 valid match_keys,
  or if there are dangling match_keys that don't exist in the clickmap.

Usage:
  python test/validate_state_defs.py
  python test/validate_state_defs.py --require RUNNING HOME_SCREEN GAME_OVER
"""
import argparse, os, sys

HERE = os.path.dirname(os.path.abspath(__file__))
REPO = os.path.dirname(HERE)
if REPO not in sys.path:
    sys.path.insert(0, REPO)

from core.clickmap_access import dot_path_exists, resolve_dot_path  # type: ignore
from core.state_detector import load_state_definitions              # type: ignore

TRIM_SUFFIXES = (".match_region",".region_ref",".match_template",".match_threshold",".roles",".tap",".swipe")

def _trim(key: str) -> str:
    for suf in TRIM_SUFFIXES:
        i = key.find(suf)
        if i != -1:
            return key[:i]
    return key

def _collect_sections(state_defs):
    """Return (states: dict[name->block], overlays: dict[name->block]) for dict or list schema."""
    states, overlays = {}, {}
    if not isinstance(state_defs, dict):
        return states, overlays

    def coerce(sec):
        out = {}
        if isinstance(sec, dict):
            for name, blk in sec.items():
                if isinstance(name, str) and isinstance(blk, dict):
                    out[name] = blk
        elif isinstance(sec, list):
            for item in sec:
                if isinstance(item, dict):
                    name = item.get("name") or item.get("id") or item.get("state")
                    if isinstance(name, str):
                        out[name] = item
        return out

    states = coerce(state_defs.get("states"))
    overlays = coerce(state_defs.get("overlays"))
    return states, overlays

def _extract_match_keys(block):
    keys = []
    mk = block.get("match_keys")
    if isinstance(mk, list):
        keys = [k for k in mk if isinstance(k, str)]
    return keys

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--require", nargs="*", default=["GAME_OVER", "HOME_SCREEN", "RUNNING"])
    args = ap.parse_args()

    defs = load_state_definitions()
    states, overlays = _collect_sections(defs)

    ok = True

    # 1) Required states present
    missing = [s for s in args.require if s not in states]
    if missing:
        print("[ERROR] Missing required states:", ", ".join(missing))
        ok = False

    # 2) Validate each state's match_keys
    bad_refs = []
    zero_valid = []
    for st_name, blk in sorted(states.items()):
        keys = _extract_match_keys(blk)
        valid_count = 0
        for raw in keys:
            key = _trim(raw)
            if not dot_path_exists(key):
                bad_refs.append((st_name, raw))
                continue
            try:
                obj = resolve_dot_path(key)
                # must be either an entry dict with match_region/region_ref or a bare region dict
                if isinstance(obj, dict) and (("match_region" in obj) or ("region_ref" in obj) or all(k in obj for k in ("x","y","w","h"))):
                    valid_count += 1
                else:
                    bad_refs.append((st_name, raw))
            except Exception:
                bad_refs.append((st_name, raw))
        if valid_count == 0:
            zero_valid.append(st_name)

    for st in zero_valid:
        print(f"[ERROR] State {st} references 0 valid clickmap paths.")
        ok = False

    if bad_refs:
        print("\n[WARN] YAML match_keys not found/invalid in clickmap (showing up to 20):")
        shown = 0
        for st, raw in bad_refs:
            print(f"  - {st}: {raw}")
            shown += 1
            if shown >= 20:
                break
        # treat as error so CI blocks on drift/typos
        ok = False

    if ok:
        print("[OK] state_definitions.yaml passes validation.")
        sys.exit(0)
    else:
        sys.exit(1)

if __name__ == "__main__":
    main()
----------./test/scratch.py----------------------
./test/scratch.py
# quick_match_probe.py
import cv2
from core.clickmap_access import get_clickmap, resolve_dot_path
from core.matcher import _match_entry

get_clickmap()  # ensure cache is warm

screen = cv2.imread("screenshots/latest.png")
entry = resolve_dot_path("indicators.game_over")
print("Resolved?", bool(entry))
if entry:
    print("Entry:", {k: entry[k] for k in ("match_template","match_region","match_threshold") if k in entry})
    (pt, conf) = _match_entry(screen, entry, template_dir="assets/match_templates")
    print("Result:", pt, conf)


----------./test/visualize_state_regions.py----------------------
./test/visualize_state_regions.py
#!/usr/bin/env python3
"""
Visualize which clickmap boxes are referenced by selected states/overlays.

Relies ONLY on your real APIs:
- core.clickmap_access: get_clickmap, dot_path_exists, resolve_dot_path
- core.label_tapper:   resolve_region
- core.state_detector: load_state_definitions

YAML support:
- states/overlays may be dicts OR lists of objects with {name, match_keys, ...}.

Usage:
  # draw GAME_OVER + overlays
  test/visualize_state_regions.py --states GAME_OVER --include-overlays --scale 0.8 --thickness 4 --dump out/boxes.json

  # draw multiple states
  test/visualize_state_regions.py --states GAME_OVER HOME_SCREEN --scale 0.8

Notes:
- Boxes fully off the screenshot won’t be visible; counts still print.
"""
import argparse, json, os, sys
import cv2

# repo import path
HERE = os.path.dirname(os.path.abspath(__file__))
REPO = os.path.dirname(HERE)
if REPO not in sys.path:
    sys.path.insert(0, REPO)

from core.clickmap_access import get_clickmap, dot_path_exists, resolve_dot_path  # type: ignore
from core.label_tapper import resolve_region  # type: ignore
from core.state_detector import load_state_definitions  # type: ignore
from utils.logger import log  # type: ignore


TRIM_SUFFIXES = (
    ".match_region",
    ".region_ref",
    ".match_template",
    ".match_threshold",
    ".roles",
    ".tap",
    ".swipe",
)

def _trim_to_parent(key: str) -> str:
    for suf in TRIM_SUFFIXES:
        i = key.find(suf)
        if i != -1:
            return key[:i]
    return key

def _font(img_shape):
    h, w = img_shape[:2]
    base = min(w, h)
    if base <= 1080: return 0.7, 2
    if base <= 1440: return 0.8, 2
    if base <= 2160: return 1.0, 2
    return 1.3, 3

def _hash_color(name: str):
    h = 0
    for ch in name: h = (h * 131 + ord(ch)) & 0xFFFFFFFF
    return int(50 + (h & 0x7F)), int(50 + ((h >> 7) & 0x7F)), int(50 + ((h >> 14) & 0x7F))  # B,G,R

def _ensure_dir(path):
    d = os.path.dirname(path)
    if d and not os.path.exists(d):
        os.makedirs(d, exist_ok=True)

def _collect_state_blocks(state_defs):
    """Return (states: dict[name->block], overlays: dict[name->block]) for dict or list schema."""
    states, overlays = {}, {}
    if not isinstance(state_defs, dict):
        return states, overlays
    def coerce(sec):
        out = {}
        if isinstance(sec, dict):
            for name, blk in sec.items():
                if isinstance(name, str) and isinstance(blk, dict):
                    out[name] = blk
        elif isinstance(sec, list):
            for item in sec:
                if not isinstance(item, dict): continue
                name = item.get("name") or item.get("id") or item.get("state")
                if isinstance(name, str): out[name] = item
        return out
    states = coerce(state_defs.get("states"))
    overlays = coerce(state_defs.get("overlays"))
    return states, overlays

def _extract_match_keys(block):
    """Prefer explicit match_keys; otherwise scan for strings (lightweight)."""
    keys = []
    mk = block.get("match_keys")
    if isinstance(mk, list):
        for s in mk:
            if isinstance(s, str):
                keys.append(s)
    return keys

def _resolve_key_to_region(key: str, clickmap: dict):
    """
    key -> entry dict (match_region/region_ref) -> resolve_region
       OR key -> region dict with x/y/w/h
       returns (x,y,w,h) or raises
    """
    obj = resolve_dot_path(key)
    if not isinstance(obj, dict):
        raise TypeError(f"dot path is not a dict: {key}")
    # entry dict?
    if ("match_region" in obj) or ("region_ref" in obj):
        reg = resolve_region(obj, clickmap)
        return int(reg["x"]), int(reg["y"]), int(reg["w"]), int(reg["h"])
    # or a bare region
    if all(k in obj for k in ("x", "y", "w", "h")):
        return int(obj["x"]), int(obj["y"]), int(obj["w"]), int(obj["h"])
    raise ValueError(f"dot path has no region: {key}")

def _draw(img, groups, scale=1.0, thickness=2, title=None):
    out = img.copy()
    font_scale, default_th = _font(out.shape)
    if thickness <= 0: thickness = default_th
    for group_name, boxes in groups:
        color = _hash_color(group_name)
        for b in boxes:
            p1 = (b["x"], b["y"])
            p2 = (b["x"] + b["w"], b["y"] + b["h"])
            cv2.rectangle(out, p1, p2, color, thickness)
            label = f'{group_name}:{b["name"]}'
            (tw, th), _ = cv2.getTextSize(label, cv2.FONT_HERSHEY_SIMPLEX, font_scale, max(1, thickness - 1))
            tx, ty = p1[0], max(0, p1[1] - 4)
            cv2.rectangle(out, (tx, ty - th - 4), (tx + tw + 6, ty + 3), (0, 0, 0), -1)
            cv2.putText(out, label, (tx + 3, ty - 2), cv2.FONT_HERSHEY_SIMPLEX, font_scale, color, max(1, thickness - 1), cv2.LINE_AA)
    if title:
        (tw, th), _ = cv2.getTextSize(title, cv2.FONT_HERSHEY_SIMPLEX, font_scale, thickness)
        cv2.rectangle(out, (10, 10), (10 + tw + 12, 10 + th + 12), (0, 0, 0), -1)
        cv2.putText(out, title, (16, 10 + th + 2), cv2.FONT_HERSHEY_SIMPLEX, font_scale, (255, 255, 255), thickness, cv2.LINE_AA)
    if scale != 1.0:
        out = cv2.resize(out, (int(out.shape[1] * scale), int(out.shape[0] * scale)), interpolation=cv2.INTER_AREA)
    return out

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--image", default="screenshots/latest.png")
    ap.add_argument("--out", default="out/visual_state_regions.png")
    ap.add_argument("--states", nargs="*", help="Limit to specific state names")
    ap.add_argument("--include-overlays", action="store_true")
    ap.add_argument("--scale", type=float, default=1.0)
    ap.add_argument("--thickness", type=int, default=2)
    ap.add_argument("--dump", default=None)
    args = ap.parse_args()

    _ensure_dir(args.out)
    img = cv2.imread(args.image, cv2.IMREAD_COLOR)
    if img is None:
        print(f"[ERROR] Could not read image: {args.image}")
        sys.exit(2)
    clickmap = get_clickmap()
    state_defs = load_state_definitions()
    states_map, overlays_map = _collect_state_blocks(state_defs)

    # Filter states if requested
    if args.states:
        want = set(args.states)
        states_map = {k: v for k, v in states_map.items() if k in want}
        if not states_map:
            print("[WARN] No matching states after --states filter.")

    # Build worklist of (group_name, keys[])
    work = []
    for st_name, blk in states_map.items():
        keys = _extract_match_keys(blk)
        work.append((st_name, keys))
    if args.include_overlays:
        for ov_name, blk in overlays_map.items():
            keys = _extract_match_keys(blk)
            work.append((f"OV:{ov_name}", keys))

    # Resolve and draw
    groups = []
    summary = []
    missing = []
    offscreen_total = 0

    for group_name, keys in work:
        boxes = []
        onscreen = 0
        offscreen = 0
        for raw in keys:
            if not isinstance(raw, str): continue
            key = _trim_to_parent(raw)
            if not dot_path_exists(key):
                missing.append(key)
                continue
            try:
                x, y, w, h = _resolve_key_to_region(key, clickmap)
                boxes.append({"name": key.split(".")[-1], "x": x, "y": y, "w": w, "h": h, "dot_path": key})
                # crude on/off classification
                H, W = img.shape[:2]
                if (x + w) <= 0 or (y + h) <= 0 or x >= W or y >= H:
                    offscreen += 1
                else:
                    onscreen += 1
            except Exception as e:
                log(f"[WARN] Failed to resolve {key}: {e}", "WARN")
        if boxes:
            groups.append((group_name, boxes))
        summary.append((group_name, len(boxes), onscreen, offscreen))
        offscreen_total += offscreen

    print("\n[DISCOVERY]")
    for name, n, on, off in summary:
        print(f"  {name}: {n} boxes (onscreen={on}, offscreen={off})")
    if missing:
        uniq = sorted(set(missing))
        print("\n[WARN] YAML match_keys not found in clickmap (after normalization), first 20:")
        for s in uniq[:20]:
            print("   -", s)

    composed = _draw(img, groups, scale=args.scale, thickness=args.thickness, title="visualize_state_regions")
    cv2.imwrite(args.out, composed)
    print(f"[INFO] Wrote: {args.out}")

    if args.dump:
        payload = {
            "image": args.image,
            "image_shape": img.shape,
            "groups": {name: boxes for name, boxes in groups},
            "missing_keys": sorted(set(missing)),
        }
        _ensure_dir(args.dump)
        with open(args.dump, "w", encoding="utf-8") as f:
            json.dump(payload, f, indent=2)
        print(f"[INFO] Wrote JSON dump: {args.dump}")

if __name__ == "__main__":
    main()
